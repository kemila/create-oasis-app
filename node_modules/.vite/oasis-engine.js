// node_modules/@oasis-engine/math/dist/module.js
var ContainmentType;
(function(ContainmentType2) {
  ContainmentType2[ContainmentType2["Disjoint"] = 0] = "Disjoint";
  ContainmentType2[ContainmentType2["Contains"] = 1] = "Contains";
  ContainmentType2[ContainmentType2["Intersects"] = 2] = "Intersects";
})(ContainmentType || (ContainmentType = {}));
var PlaneIntersectionType;
(function(PlaneIntersectionType2) {
  PlaneIntersectionType2[PlaneIntersectionType2["Back"] = 0] = "Back";
  PlaneIntersectionType2[PlaneIntersectionType2["Front"] = 1] = "Front";
  PlaneIntersectionType2[PlaneIntersectionType2["Intersecting"] = 2] = "Intersecting";
})(PlaneIntersectionType || (PlaneIntersectionType = {}));
var MathUtil = function() {
  function MathUtil2() {
  }
  MathUtil2.clamp = function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  };
  MathUtil2.equals = function equals(a, b) {
    return Math.abs(a - b) <= MathUtil2.zeroTolerance;
  };
  MathUtil2.isPowerOf2 = function isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  MathUtil2.radianToDegree = function radianToDegree(r) {
    return r * MathUtil2.radToDegreeFactor;
  };
  MathUtil2.degreeToRadian = function degreeToRadian(d) {
    return d * MathUtil2.degreeToRadFactor;
  };
  return MathUtil2;
}();
MathUtil.zeroTolerance = 1e-6;
MathUtil.radToDegreeFactor = 180 / Math.PI;
MathUtil.degreeToRadFactor = Math.PI / 180;
var Vector3 = function() {
  Vector32.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
  };
  Vector32.subtract = function subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
    out.z = left.z - right.z;
  };
  Vector32.multiply = function multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
    out.z = left.z * right.z;
  };
  Vector32.divide = function divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
    out.z = left.z / right.z;
  };
  Vector32.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z;
  };
  Vector32.cross = function cross(left, right, out) {
    var ax = left.x;
    var ay = left.y;
    var az = left.z;
    var bx = right.x;
    var by = right.y;
    var bz = right.z;
    out.x = ay * bz - az * by;
    out.y = az * bx - ax * bz;
    out.z = ax * by - ay * bx;
  };
  Vector32.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    return Math.sqrt(x * x + y * y + z * z);
  };
  Vector32.distanceSquared = function distanceSquared(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    return x * x + y * y + z * z;
  };
  Vector32.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);
  };
  Vector32.lerp = function lerp(start, end, t, out) {
    var x = start.x, y = start.y, z = start.z;
    out.x = x + (end.x - x) * t;
    out.y = y + (end.y - y) * t;
    out.z = z + (end.z - z) * t;
  };
  Vector32.max = function max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
    out.z = Math.max(left.z, right.z);
  };
  Vector32.min = function min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
    out.z = Math.min(left.z, right.z);
  };
  Vector32.negate = function negate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
  };
  Vector32.normalize = function normalize(a, out) {
    var x = a.x, y = a.y, z = a.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    if (len > 0) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
    }
  };
  Vector32.scale = function scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
  };
  Vector32.transformNormal = function transformNormal(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8];
    out.y = x * e[1] + y * e[5] + z * e[9];
    out.z = x * e[2] + y * e[6] + z * e[10];
  };
  Vector32.transformToVec3 = function transformToVec3(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
  };
  Vector32.transformToVec4 = function transformToVec4(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
    out.w = x * e[3] + y * e[7] + z * e[11] + e[15];
  };
  Vector32.transformCoordinate = function transformCoordinate(v, m, out) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    var w = x * e[3] + y * e[7] + z * e[11] + e[15];
    w = 1 / w;
    out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;
    out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;
    out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;
  };
  Vector32.transformByQuat = function transformByQuat(v, quaternion, out) {
    var x = v.x, y = v.y, z = v.z;
    var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out.x = ix * qw - iw * qx - iy * qz + iz * qy;
    out.y = iy * qw - iw * qy - iz * qx + ix * qz;
    out.z = iz * qw - iw * qz - ix * qy + iy * qx;
  };
  function Vector32(x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  var _proto = Vector32.prototype;
  _proto.setValue = function setValue(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  };
  _proto.add = function add(right) {
    this.x += right.x;
    this.y += right.y;
    this.z += right.z;
    return this;
  };
  _proto.subtract = function subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    this.z -= right.z;
    return this;
  };
  _proto.multiply = function multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    this.z *= right.z;
    return this;
  };
  _proto.divide = function divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    this.z /= right.z;
    return this;
  };
  _proto.length = function length() {
    var x = this.x, y = this.y, z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y, z = this.z;
    return x * x + y * y + z * z;
  };
  _proto.negate = function negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  };
  _proto.normalize = function normalize() {
    Vector32.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
  };
  _proto.clone = function clone2() {
    return new Vector32(this.x, this.y, this.z);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    return out;
  };
  _proto.transformNormal = function transformNormal(m) {
    Vector32.transformNormal(this, m, this);
    return this;
  };
  _proto.transformToVec3 = function transformToVec3(m) {
    Vector32.transformToVec3(this, m, this);
    return this;
  };
  _proto.transformCoordinate = function transformCoordinate(m) {
    Vector32.transformCoordinate(this, m, this);
    return this;
  };
  _proto.transformByQuat = function transformByQuat(quaternion) {
    Vector32.transformByQuat(this, quaternion, this);
    return this;
  };
  return Vector32;
}();
Vector3._zero = new Vector3(0, 0, 0);
Vector3._one = new Vector3(1, 1, 1);
Vector3._tempVector3 = new Vector3();
var BoundingSphere = function() {
  BoundingSphere2.fromPoints = function fromPoints(points, out) {
    if (!points || points.length === 0) {
      throw new Error("points must be array and length must > 0");
    }
    var len = points.length;
    var center = BoundingSphere2._tempVec30;
    center.x = center.y = center.z = 0;
    for (var i = 0; i < len; ++i) {
      Vector3.add(points[i], center, center);
    }
    Vector3.scale(center, 1 / len, out.center);
    var radius = 0;
    for (var _i = 0; _i < len; ++_i) {
      var distance = Vector3.distanceSquared(center, points[_i]);
      distance > radius && (radius = distance);
    }
    out.radius = Math.sqrt(radius);
  };
  BoundingSphere2.fromBox = function fromBox(box, out) {
    var center = out.center;
    var min = box.min, max = box.max;
    center.x = (min.x + max.x) * 0.5;
    center.y = (min.y + max.y) * 0.5;
    center.z = (min.z + max.z) * 0.5;
    out.radius = Vector3.distance(center, max);
  };
  function BoundingSphere2(center, radius) {
    if (center === void 0) {
      center = null;
    }
    if (radius === void 0) {
      radius = 0;
    }
    this.center = new Vector3();
    this.radius = 0;
    center && center.cloneTo(this.center);
    this.radius = radius;
  }
  var _proto = BoundingSphere2.prototype;
  _proto.clone = function clone2() {
    return new BoundingSphere2(this.center, this.radius);
  };
  _proto.cloneTo = function cloneTo(out) {
    this.center.cloneTo(out.center);
    out.radius = this.radius;
    return out;
  };
  return BoundingSphere2;
}();
BoundingSphere._tempVec30 = new Vector3();
var BoundingBox = function() {
  BoundingBox2.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
    Vector3.subtract(center, extent, out.min);
    Vector3.add(center, extent, out.max);
  };
  BoundingBox2.fromPoints = function fromPoints(points, out) {
    if (!points || points.length === 0) {
      throw new Error("points must be array and length must > 0");
    }
    var min = out.min, max = out.max;
    min.x = min.y = min.z = Number.MAX_VALUE;
    max.x = max.y = max.z = -Number.MAX_VALUE;
    for (var i = 0, l = points.length; i < l; ++i) {
      var point = points[i];
      Vector3.min(min, point, min);
      Vector3.max(max, point, max);
    }
  };
  BoundingBox2.fromSphere = function fromSphere(shpere, out) {
    var center = shpere.center, radius = shpere.radius;
    var min = out.min, max = out.max;
    min.x = center.x - radius;
    min.y = center.y - radius;
    min.z = center.z - radius;
    max.x = center.x + radius;
    max.y = center.y + radius;
    max.z = center.z + radius;
  };
  BoundingBox2.transform = function transform(source, matrix, out) {
    var center = BoundingBox2._tempVec30;
    var extent = BoundingBox2._tempVec31;
    source.getCenter(center);
    source.getExtent(extent);
    Vector3.transformCoordinate(center, matrix, center);
    var x = extent.x, y = extent.y, z = extent.z;
    var e = matrix.elements;
    extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
    extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
    extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);
    Vector3.subtract(center, extent, out.min);
    Vector3.add(center, extent, out.max);
  };
  BoundingBox2.merge = function merge(box1, box2, out) {
    Vector3.min(box1.min, box2.min, out.min);
    Vector3.max(box1.max, box2.max, out.max);
    return out;
  };
  function BoundingBox2(min, max) {
    if (min === void 0) {
      min = null;
    }
    if (max === void 0) {
      max = null;
    }
    this.min = new Vector3();
    this.max = new Vector3();
    min && min.cloneTo(this.min);
    max && max.cloneTo(this.max);
  }
  var _proto = BoundingBox2.prototype;
  _proto.clone = function clone2() {
    return new BoundingBox2(this.min, this.max);
  };
  _proto.cloneTo = function cloneTo(out) {
    this.min.cloneTo(out.min);
    this.max.cloneTo(out.max);
    return out;
  };
  _proto.getCenter = function getCenter(out) {
    Vector3.add(this.min, this.max, out);
    Vector3.scale(out, 0.5, out);
    return out;
  };
  _proto.getExtent = function getExtent(out) {
    Vector3.subtract(this.max, this.min, out);
    Vector3.scale(out, 0.5, out);
    return out;
  };
  _proto.getCorners = function getCorners(out) {
    if (out === void 0) {
      out = [];
    }
    var min = this.min, max = this.max;
    var minX = min.x;
    var minY = min.y;
    var minZ = min.z;
    var maxX = max.x;
    var maxY = max.y;
    var maxZ = max.z;
    var len = out.length;
    if (len < 8) {
      for (var i = 0, l = 8 - len; i < l; ++i) {
        out[len + i] = new Vector3();
      }
    }
    out[0].setValue(minX, maxY, maxZ);
    out[1].setValue(maxX, maxY, maxZ);
    out[2].setValue(maxX, minY, maxZ);
    out[3].setValue(minX, minY, maxZ);
    out[4].setValue(minX, maxY, minZ);
    out[5].setValue(maxX, maxY, minZ);
    out[6].setValue(maxX, minY, minZ);
    out[7].setValue(minX, minY, minZ);
    return out;
  };
  _proto.transform = function transform(matrix) {
    BoundingBox2.transform(this, matrix, this);
    return this;
  };
  return BoundingBox2;
}();
BoundingBox._tempVec30 = new Vector3();
BoundingBox._tempVec31 = new Vector3();
var CollisionUtil = function() {
  function CollisionUtil2() {
  }
  CollisionUtil2.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
    return Vector3.dot(plane.normal, point) + plane.distance;
  };
  CollisionUtil2.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
    var distance = CollisionUtil2.distancePlaneAndPoint(plane, point);
    if (distance > 0) {
      return PlaneIntersectionType.Front;
    }
    if (distance < 0) {
      return PlaneIntersectionType.Back;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
    var min = box.min, max = box.max;
    var normal = plane.normal;
    var front = CollisionUtil2._tempVec30;
    var back = CollisionUtil2._tempVec31;
    if (normal.x >= 0) {
      front.x = max.x;
      back.x = min.x;
    } else {
      front.x = min.x;
      back.x = max.x;
    }
    if (normal.y >= 0) {
      front.y = max.y;
      back.y = min.y;
    } else {
      front.y = min.y;
      back.y = max.y;
    }
    if (normal.z >= 0) {
      front.z = max.z;
      back.z = min.z;
    } else {
      front.z = min.z;
      back.z = max.z;
    }
    if (CollisionUtil2.distancePlaneAndPoint(plane, front) < 0) {
      return PlaneIntersectionType.Back;
    }
    if (CollisionUtil2.distancePlaneAndPoint(plane, back) > 0) {
      return PlaneIntersectionType.Front;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
    var center = sphere.center, radius = sphere.radius;
    var distance = CollisionUtil2.distancePlaneAndPoint(plane, center);
    if (distance > radius) {
      return PlaneIntersectionType.Front;
    }
    if (distance < -radius) {
      return PlaneIntersectionType.Back;
    }
    return PlaneIntersectionType.Intersecting;
  };
  CollisionUtil2.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
    var normal = plane.normal;
    var zeroTolerance = MathUtil.zeroTolerance;
    var dir = Vector3.dot(normal, ray.direction);
    if (Math.abs(dir) < zeroTolerance) {
      return -1;
    }
    var position = Vector3.dot(normal, ray.origin);
    var distance = (-plane.distance - position) / dir;
    if (distance < 0) {
      if (distance < -zeroTolerance) {
        return -1;
      }
      distance = 0;
    }
    return distance;
  };
  CollisionUtil2.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
    var zeroTolerance = MathUtil.zeroTolerance;
    var origin = ray.origin, direction = ray.direction;
    var min = box.min, max = box.max;
    var dirX = direction.x;
    var dirY = direction.y;
    var dirZ = direction.z;
    var oriX = origin.x;
    var oriY = origin.y;
    var oriZ = origin.z;
    var distance = 0;
    var tmax = Number.MAX_VALUE;
    if (Math.abs(dirX) < zeroTolerance) {
      if (oriX < min.x || oriX > max.x) {
        return -1;
      }
    } else {
      var inverse = 1 / dirX;
      var t1 = (min.x - oriX) * inverse;
      var t2 = (max.x - oriX) * inverse;
      if (t1 > t2) {
        var temp = t1;
        t1 = t2;
        t2 = temp;
      }
      distance = Math.max(t1, distance);
      tmax = Math.min(t2, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    if (Math.abs(dirY) < zeroTolerance) {
      if (oriY < min.y || oriY > max.y) {
        return -1;
      }
    } else {
      var _inverse = 1 / dirY;
      var _t = (min.y - oriY) * _inverse;
      var _t2 = (max.y - oriY) * _inverse;
      if (_t > _t2) {
        var _temp3 = _t;
        _t = _t2;
        _t2 = _temp3;
      }
      distance = Math.max(_t, distance);
      tmax = Math.min(_t2, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    if (Math.abs(dirZ) < zeroTolerance) {
      if (oriZ < min.z || oriZ > max.z) {
        return -1;
      }
    } else {
      var _inverse2 = 1 / dirZ;
      var _t3 = (min.z - oriZ) * _inverse2;
      var _t4 = (max.z - oriZ) * _inverse2;
      if (_t3 > _t4) {
        var _temp22 = _t3;
        _t3 = _t4;
        _t4 = _temp22;
      }
      distance = Math.max(_t3, distance);
      tmax = Math.min(_t4, tmax);
      if (distance > tmax) {
        return -1;
      }
    }
    return distance;
  };
  CollisionUtil2.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
    var origin = ray.origin, direction = ray.direction;
    var center = sphere.center, radius = sphere.radius;
    var m = CollisionUtil2._tempVec30;
    Vector3.subtract(origin, center, m);
    var b = Vector3.dot(m, direction);
    var c = Vector3.dot(m, m) - radius * radius;
    if (b > 0 && c > 0) {
      return -1;
    }
    var discriminant = b * b - c;
    if (discriminant < 0) {
      return -1;
    }
    var distance = -b - Math.sqrt(discriminant);
    if (distance < 0) {
      distance = 0;
    }
    return distance;
  };
  CollisionUtil2.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
    var min = box.min, max = box.max;
    var back = CollisionUtil2._tempVec30;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var normal = plane.normal;
      back.x = normal.x >= 0 ? min.x : max.x;
      back.y = normal.y >= 0 ? min.y : max.y;
      back.z = normal.z >= 0 ? min.z : max.z;
      if (Vector3.dot(plane.normal, back) > -plane.distance) {
        return false;
      }
    }
    return true;
  };
  CollisionUtil2.frustumContainsBox = function frustumContainsBox(frustum, box) {
    var min = box.min, max = box.max;
    var front = CollisionUtil2._tempVec30;
    var back = CollisionUtil2._tempVec31;
    var result = ContainmentType.Contains;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var normal = plane.normal;
      if (normal.x >= 0) {
        front.x = max.x;
        back.x = min.x;
      } else {
        front.x = min.x;
        back.x = max.x;
      }
      if (normal.y >= 0) {
        front.y = max.y;
        back.y = min.y;
      } else {
        front.y = min.y;
        back.y = max.y;
      }
      if (normal.z >= 0) {
        front.z = max.z;
        back.z = min.z;
      } else {
        front.z = min.z;
        back.z = max.z;
      }
      if (CollisionUtil2.intersectsPlaneAndPoint(plane, back) === PlaneIntersectionType.Front) {
        return ContainmentType.Disjoint;
      }
      if (CollisionUtil2.intersectsPlaneAndPoint(plane, front) === PlaneIntersectionType.Front) {
        result = ContainmentType.Intersects;
      }
    }
    return result;
  };
  CollisionUtil2.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
    var result = ContainmentType.Contains;
    for (var i = 0; i < 6; ++i) {
      var plane = frustum.getPlane(i);
      var intersectionType = CollisionUtil2.intersectsPlaneAndSphere(plane, sphere);
      if (intersectionType === PlaneIntersectionType.Front) {
        return ContainmentType.Disjoint;
      } else if (intersectionType === PlaneIntersectionType.Intersecting) {
        result = ContainmentType.Intersects;
        break;
      }
    }
    return result;
  };
  return CollisionUtil2;
}();
CollisionUtil._tempVec30 = new Vector3();
CollisionUtil._tempVec31 = new Vector3();
var Plane = function() {
  Plane2.normalize = function normalize(p, out) {
    var normal = p.normal;
    var factor = 1 / normal.length();
    var outNormal = out.normal;
    outNormal.x = normal.x * factor;
    outNormal.y = normal.y * factor;
    outNormal.z = normal.z * factor;
    out.distance = p.distance * factor;
  };
  Plane2.fromPoints = function fromPoints(point0, point1, point2, out) {
    var x0 = point0.x;
    var y0 = point0.y;
    var z0 = point0.z;
    var x1 = point1.x - x0;
    var y1 = point1.y - y0;
    var z1 = point1.z - z0;
    var x2 = point2.x - x0;
    var y2 = point2.y - y0;
    var z2 = point2.z - z0;
    var yz = y1 * z2 - z1 * y2;
    var xz = z1 * x2 - x1 * z2;
    var xy = x1 * y2 - y1 * x2;
    var invPyth = 1 / Math.sqrt(yz * yz + xz * xz + xy * xy);
    var x = yz * invPyth;
    var y = xz * invPyth;
    var z = xy * invPyth;
    var normal = out.normal;
    normal.x = x;
    normal.y = y;
    normal.z = z;
    out.distance = -(x * x0 + y * y0 + z * z0);
  };
  function Plane2(normal, distance) {
    if (normal === void 0) {
      normal = null;
    }
    if (distance === void 0) {
      distance = 0;
    }
    this.normal = new Vector3();
    this.distance = 0;
    normal && normal.cloneTo(this.normal);
    this.distance = distance;
  }
  var _proto = Plane2.prototype;
  _proto.normalize = function normalize() {
    Plane2.normalize(this, this);
    return this;
  };
  _proto.clone = function clone2() {
    var out = new Plane2();
    this.cloneTo(out);
    return out;
  };
  _proto.cloneTo = function cloneTo(out) {
    this.normal.cloneTo(out.normal);
    out.distance = this.distance;
    return out;
  };
  return Plane2;
}();
var BoundingFrustum = function() {
  function BoundingFrustum2(matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    this.near = void 0;
    this.far = void 0;
    this.left = void 0;
    this.right = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.near = new Plane();
    this.far = new Plane();
    this.left = new Plane();
    this.right = new Plane();
    this.top = new Plane();
    this.bottom = new Plane();
    matrix && this.calculateFromMatrix(matrix);
  }
  var _proto = BoundingFrustum2.prototype;
  _proto.clone = function clone2() {
    var bf = new BoundingFrustum2();
    this.cloneTo(bf);
    return bf;
  };
  _proto.cloneTo = function cloneTo(out) {
    this.near.cloneTo(out.near);
    this.far.cloneTo(out.far);
    this.left.cloneTo(out.left);
    this.right.cloneTo(out.right);
    this.top.cloneTo(out.top);
    this.bottom.cloneTo(out.bottom);
    return out;
  };
  _proto.getPlane = function getPlane(index) {
    switch (index) {
      case 0:
        return this.near;
      case 1:
        return this.far;
      case 2:
        return this.left;
      case 3:
        return this.right;
      case 4:
        return this.top;
      case 5:
        return this.bottom;
      default:
        return null;
    }
  };
  _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
    var me = matrix.elements;
    var m11 = me[0];
    var m12 = me[1];
    var m13 = me[2];
    var m14 = me[3];
    var m21 = me[4];
    var m22 = me[5];
    var m23 = me[6];
    var m24 = me[7];
    var m31 = me[8];
    var m32 = me[9];
    var m33 = me[10];
    var m34 = me[11];
    var m41 = me[12];
    var m42 = me[13];
    var m43 = me[14];
    var m44 = me[15];
    var nearNormal = this.near.normal;
    nearNormal.x = -m14 - m13;
    nearNormal.y = -m24 - m23;
    nearNormal.z = -m34 - m33;
    this.near.distance = -m44 - m43;
    this.near.normalize();
    var farNormal = this.far.normal;
    farNormal.x = m13 - m14;
    farNormal.y = m23 - m24;
    farNormal.z = m33 - m34;
    this.far.distance = m43 - m44;
    this.far.normalize();
    var leftNormal = this.left.normal;
    leftNormal.x = -m14 - m11;
    leftNormal.y = -m24 - m21;
    leftNormal.z = -m34 - m31;
    this.left.distance = -m44 - m41;
    this.left.normalize();
    var rightNormal = this.right.normal;
    rightNormal.x = m11 - m14;
    rightNormal.y = m21 - m24;
    rightNormal.z = m31 - m34;
    this.right.distance = m41 - m44;
    this.right.normalize();
    var topNormal = this.top.normal;
    topNormal.x = m12 - m14;
    topNormal.y = m22 - m24;
    topNormal.z = m32 - m34;
    this.top.distance = m42 - m44;
    this.top.normalize();
    var bottomNormal = this.bottom.normal;
    bottomNormal.x = -m14 - m12;
    bottomNormal.y = -m24 - m22;
    bottomNormal.z = -m34 - m32;
    this.bottom.distance = -m44 - m42;
    this.bottom.normalize();
  };
  _proto.intersectsBox = function intersectsBox(box) {
    return CollisionUtil.intersectsFrustumAndBox(this, box);
  };
  _proto.intersectsSphere = function intersectsSphere(sphere) {
    return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;
  };
  return BoundingFrustum2;
}();
var Matrix3x3 = function() {
  Matrix3x32.add = function add(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    oe[0] = le[0] + re[0];
    oe[1] = le[1] + re[1];
    oe[2] = le[2] + re[2];
    oe[3] = le[3] + re[3];
    oe[4] = le[4] + re[4];
    oe[5] = le[5] + re[5];
    oe[6] = le[6] + re[6];
    oe[7] = le[7] + re[7];
    oe[8] = le[8] + re[8];
  };
  Matrix3x32.subtract = function subtract(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    oe[0] = le[0] - re[0];
    oe[1] = le[1] - re[1];
    oe[2] = le[2] - re[2];
    oe[3] = le[3] - re[3];
    oe[4] = le[4] - re[4];
    oe[5] = le[5] - re[5];
    oe[6] = le[6] - re[6];
    oe[7] = le[7] - re[7];
    oe[8] = le[8] - re[8];
  };
  Matrix3x32.multiply = function multiply(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    var l11 = le[0], l12 = le[1], l13 = le[2];
    var l21 = le[3], l22 = le[4], l23 = le[5];
    var l31 = le[6], l32 = le[7], l33 = le[8];
    var r11 = re[0], r12 = re[1], r13 = re[2];
    var r21 = re[3], r22 = re[4], r23 = re[5];
    var r31 = re[6], r32 = re[7], r33 = re[8];
    oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
    oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
    oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
    oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
    oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
    oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
    oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
    oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
    oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
  };
  Matrix3x32.equals = function equals(left, right) {
    var le = left.elements;
    var re = right.elements;
    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
  };
  Matrix3x32.rotationQuaternion = function rotationQuaternion(quaternion, out) {
    var oe = out.elements;
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    oe[0] = 1 - yy - zz;
    oe[3] = yx - wz;
    oe[6] = zx + wy;
    oe[1] = yx + wz;
    oe[4] = 1 - xx - zz;
    oe[7] = zy - wx;
    oe[2] = zx - wy;
    oe[5] = zy + wx;
    oe[8] = 1 - xx - yy;
  };
  Matrix3x32.scaling = function scaling(s, out) {
    var oe = out.elements;
    oe[0] = s.x;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = s.y;
    oe[5] = 0;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 1;
  };
  Matrix3x32.translation = function translation(_translation, out) {
    var oe = out.elements;
    oe[0] = 1;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 1;
    oe[5] = 0;
    oe[6] = _translation.x;
    oe[7] = _translation.y;
    oe[8] = 1;
  };
  Matrix3x32.invert = function invert(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2];
    var a21 = ae[3], a22 = ae[4], a23 = ae[5];
    var a31 = ae[6], a32 = ae[7], a33 = ae[8];
    var b12 = a33 * a22 - a23 * a32;
    var b22 = -a33 * a21 + a23 * a31;
    var b32 = a32 * a21 - a22 * a31;
    var det = a11 * b12 + a12 * b22 + a13 * b32;
    if (!det) {
      return;
    }
    det = 1 / det;
    oe[0] = b12 * det;
    oe[1] = (-a33 * a12 + a13 * a32) * det;
    oe[2] = (a23 * a12 - a13 * a22) * det;
    oe[3] = b22 * det;
    oe[4] = (a33 * a11 - a13 * a31) * det;
    oe[5] = (-a23 * a11 + a13 * a21) * det;
    oe[6] = b32 * det;
    oe[7] = (-a32 * a11 + a12 * a31) * det;
    oe[8] = (a22 * a11 - a12 * a21) * det;
  };
  Matrix3x32.normalMatrix = function normalMatrix(mat4, out) {
    var ae = mat4.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
    var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
    var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
    var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
  };
  Matrix3x32.rotate = function rotate(a, r, out) {
    var ae = a.elements;
    var oe = out.elements;
    var s = Math.sin(r);
    var c = Math.cos(r);
    var a11 = ae[0], a12 = ae[1], a13 = ae[2];
    var a21 = ae[3], a22 = ae[4], a23 = ae[5];
    var a31 = ae[6], a32 = ae[7], a33 = ae[8];
    oe[0] = c * a11 + s * a21;
    oe[1] = c * a12 + s * a22;
    oe[2] = c * a13 + s * a23;
    oe[3] = c * a21 - s * a11;
    oe[4] = c * a22 - s * a12;
    oe[5] = c * a23 - s * a13;
    oe[6] = a31;
    oe[7] = a32;
    oe[8] = a33;
  };
  Matrix3x32.scale = function scale(m, s, out) {
    var x = s.x, y = s.y;
    var ae = m.elements;
    var oe = out.elements;
    oe[0] = x * ae[0];
    oe[1] = x * ae[1];
    oe[2] = x * ae[2];
    oe[3] = y * ae[3];
    oe[4] = y * ae[4];
    oe[5] = y * ae[5];
    oe[6] = ae[6];
    oe[7] = ae[7];
    oe[8] = ae[8];
  };
  Matrix3x32.translate = function translate(m, translation, out) {
    var x = translation.x, y = translation.y;
    var ae = m.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2];
    var a21 = ae[3], a22 = ae[4], a23 = ae[5];
    var a31 = ae[6], a32 = ae[7], a33 = ae[8];
    oe[0] = a11;
    oe[1] = a12;
    oe[2] = a13;
    oe[3] = a21;
    oe[4] = a22;
    oe[5] = a23;
    oe[6] = x * a11 + y * a21 + a31;
    oe[7] = x * a12 + y * a22 + a32;
    oe[8] = x * a13 + y * a23 + a33;
  };
  Matrix3x32.transpose = function transpose(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    if (out === a) {
      var a12 = ae[1];
      var a13 = ae[2];
      var a23 = ae[5];
      oe[1] = ae[3];
      oe[2] = ae[6];
      oe[3] = a12;
      oe[5] = ae[7];
      oe[6] = a13;
      oe[7] = a23;
    } else {
      oe[0] = ae[0];
      oe[1] = ae[3];
      oe[2] = ae[6];
      oe[3] = ae[1];
      oe[4] = ae[4];
      oe[5] = ae[7];
      oe[6] = ae[2];
      oe[7] = ae[5];
      oe[8] = ae[8];
    }
  };
  function Matrix3x32(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    if (m11 === void 0) {
      m11 = 1;
    }
    if (m12 === void 0) {
      m12 = 0;
    }
    if (m13 === void 0) {
      m13 = 0;
    }
    if (m21 === void 0) {
      m21 = 0;
    }
    if (m22 === void 0) {
      m22 = 1;
    }
    if (m23 === void 0) {
      m23 = 0;
    }
    if (m31 === void 0) {
      m31 = 0;
    }
    if (m32 === void 0) {
      m32 = 0;
    }
    if (m33 === void 0) {
      m33 = 1;
    }
    this.elements = new Float32Array(9);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
  }
  var _proto = Matrix3x32.prototype;
  _proto.setValue = function setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m21;
    e[4] = m22;
    e[5] = m23;
    e[6] = m31;
    e[7] = m32;
    e[8] = m33;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var srce = this.elements;
    for (var i = 0; i < 12; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  };
  _proto.setValueByMatrix = function setValueByMatrix(a) {
    var ae = a.elements;
    var e = this.elements;
    e[0] = ae[0];
    e[1] = ae[1];
    e[2] = ae[2];
    e[3] = ae[4];
    e[4] = ae[5];
    e[5] = ae[6];
    e[6] = ae[8];
    e[7] = ae[9];
    e[8] = ae[10];
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    var e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
  };
  _proto.clone = function clone2() {
    var e = this.elements;
    var ret = new Matrix3x32(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    var e = this.elements;
    var oe = out.elements;
    oe[0] = e[0];
    oe[1] = e[1];
    oe[2] = e[2];
    oe[3] = e[3];
    oe[4] = e[4];
    oe[5] = e[5];
    oe[6] = e[6];
    oe[7] = e[7];
    oe[8] = e[8];
    return out;
  };
  _proto.add = function add(right) {
    Matrix3x32.add(this, right, this);
    return this;
  };
  _proto.subtract = function subtract(right) {
    Matrix3x32.subtract(this, right, this);
    return this;
  };
  _proto.multiply = function multiply(right) {
    Matrix3x32.multiply(this, right, this);
    return this;
  };
  _proto.determinant = function determinant() {
    var e = this.elements;
    var a11 = e[0], a12 = e[1], a13 = e[2];
    var a21 = e[3], a22 = e[4], a23 = e[5];
    var a31 = e[6], a32 = e[7], a33 = e[8];
    var b12 = a33 * a22 - a23 * a32;
    var b22 = -a33 * a21 + a23 * a31;
    var b32 = a32 * a21 - a22 * a31;
    return a11 * b12 + a12 * b22 + a13 * b32;
  };
  _proto.identity = function identity() {
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
    return this;
  };
  _proto.invert = function invert() {
    Matrix3x32.invert(this, this);
    return this;
  };
  _proto.rotate = function rotate(r) {
    Matrix3x32.rotate(this, r, this);
    return this;
  };
  _proto.scale = function scale(s) {
    Matrix3x32.scale(this, s, this);
    return this;
  };
  _proto.translate = function translate(translation) {
    Matrix3x32.translate(this, translation, this);
    return this;
  };
  _proto.transpose = function transpose() {
    Matrix3x32.transpose(this, this);
    return this;
  };
  return Matrix3x32;
}();
var Quaternion = function() {
  Quaternion2.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
    out.w = left.w + right.w;
  };
  Quaternion2.multiply = function multiply(left, right, out) {
    var ax = left.x, ay = left.y, az = left.z, aw = left.w;
    var bx = right.x, by = right.y, bz = right.z, bw = right.w;
    out.x = ax * bw + aw * bx + ay * bz - az * by;
    out.y = ay * bw + aw * by + az * bx - ax * bz;
    out.z = az * bw + aw * bz + ax * by - ay * bx;
    out.w = aw * bw - ax * bx - ay * by - az * bz;
  };
  Quaternion2.conjugate = function conjugate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = a.w;
  };
  Quaternion2.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };
  Quaternion2.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
  };
  Quaternion2.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
    var normalAxis = Quaternion2._tempVector3;
    Vector3.normalize(axis, normalAxis);
    rad *= 0.5;
    var s = Math.sin(rad);
    out.x = normalAxis.x * s;
    out.y = normalAxis.y * s;
    out.z = normalAxis.z * s;
    out.w = Math.cos(rad);
  };
  Quaternion2.rotationEuler = function rotationEuler(x, y, z, out) {
    Quaternion2.rotationYawPitchRoll(y, x, z, out);
  };
  Quaternion2.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
    var halfRoll = roll * 0.5;
    var halfPitch = pitch * 0.5;
    var halfYaw = yaw * 0.5;
    var sinRoll = Math.sin(halfRoll);
    var cosRoll = Math.cos(halfRoll);
    var sinPitch = Math.sin(halfPitch);
    var cosPitch = Math.cos(halfPitch);
    var sinYaw = Math.sin(halfYaw);
    var cosYaw = Math.cos(halfYaw);
    var cosYawPitch = cosYaw * cosPitch;
    var sinYawPitch = sinYaw * sinPitch;
    out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
    out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
  };
  Quaternion2.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
    var me = m.elements;
    var m11 = me[0], m12 = me[1], m13 = me[2];
    var m21 = me[3], m22 = me[4], m23 = me[5];
    var m31 = me[6], m32 = me[7], m33 = me[8];
    var scale = m11 + m22 + m33;
    var sqrt, half;
    if (scale > 0) {
      sqrt = Math.sqrt(scale + 1);
      out.w = sqrt * 0.5;
      sqrt = 0.5 / sqrt;
      out.x = (m23 - m32) * sqrt;
      out.y = (m31 - m13) * sqrt;
      out.z = (m12 - m21) * sqrt;
    } else if (m11 >= m22 && m11 >= m33) {
      sqrt = Math.sqrt(1 + m11 - m22 - m33);
      half = 0.5 / sqrt;
      out.x = 0.5 * sqrt;
      out.y = (m12 + m21) * half;
      out.z = (m13 + m31) * half;
      out.w = (m23 - m32) * half;
    } else if (m22 > m33) {
      sqrt = Math.sqrt(1 + m22 - m11 - m33);
      half = 0.5 / sqrt;
      out.x = (m21 + m12) * half;
      out.y = 0.5 * sqrt;
      out.z = (m32 + m23) * half;
      out.w = (m31 - m13) * half;
    } else {
      sqrt = Math.sqrt(1 + m33 - m11 - m22);
      half = 0.5 / sqrt;
      out.x = (m13 + m31) * half;
      out.y = (m23 + m32) * half;
      out.z = 0.5 * sqrt;
      out.w = (m12 - m21) * half;
    }
  };
  Quaternion2.invert = function invert(a, out) {
    var x = a.x, y = a.y, z = a.z, w = a.w;
    var dot = x * x + y * y + z * z + w * w;
    if (dot > MathUtil.zeroTolerance) {
      var invDot = 1 / dot;
      out.x = -x * invDot;
      out.y = -y * invDot;
      out.z = -z * invDot;
      out.w = w * invDot;
    }
  };
  Quaternion2.lerp = function lerp(start, end, t, out) {
    var inv = 1 - t;
    if (Quaternion2.dot(start, end) >= 0) {
      out.x = start.x * inv + end.x * t;
      out.y = start.y * inv + end.y * t;
      out.z = start.z * inv + end.z * t;
      out.w = start.w * inv + end.w * t;
    } else {
      out.x = start.x * inv - end.x * t;
      out.y = start.y * inv - end.y * t;
      out.z = start.z * inv - end.z * t;
      out.w = start.w * inv - end.w * t;
    }
    out.normalize();
  };
  Quaternion2.slerp = function slerp(start, end, t, out) {
    var ax = start.x;
    var ay = start.y;
    var az = start.z;
    var aw = start.w;
    var bx = end.x;
    var by = end.y;
    var bz = end.z;
    var bw = end.w;
    var scale0, scale1;
    var cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > MathUtil.zeroTolerance) {
      var omega = Math.acos(cosom);
      var sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out.x = scale0 * ax + scale1 * bx;
    out.y = scale0 * ay + scale1 * by;
    out.z = scale0 * az + scale1 * bz;
    out.w = scale0 * aw + scale1 * bw;
  };
  Quaternion2.normalize = function normalize(a, out) {
    var x = a.x, y = a.y, z = a.z, w = a.w;
    var len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }
  };
  Quaternion2.rotationX = function rotationX(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.x = s;
    out.y = 0;
    out.z = 0;
    out.w = c;
  };
  Quaternion2.rotationY = function rotationY(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.x = 0;
    out.y = s;
    out.z = 0;
    out.w = c;
  };
  Quaternion2.rotationZ = function rotationZ(rad, out) {
    rad *= 0.5;
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out.x = 0;
    out.y = 0;
    out.z = s;
    out.w = c;
  };
  Quaternion2.rotateX = function rotateX(quaternion, rad, out) {
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    rad *= 0.5;
    var bx = Math.sin(rad);
    var bw = Math.cos(rad);
    out.x = x * bw + w * bx;
    out.y = y * bw + z * bx;
    out.z = z * bw - y * bx;
    out.w = w * bw - x * bx;
  };
  Quaternion2.rotateY = function rotateY(quaternion, rad, out) {
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    rad *= 0.5;
    var by = Math.sin(rad);
    var bw = Math.cos(rad);
    out.x = x * bw - z * by;
    out.y = y * bw + w * by;
    out.z = z * bw + x * by;
    out.w = w * bw - y * by;
  };
  Quaternion2.rotateZ = function rotateZ(quaternion, rad, out) {
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    rad *= 0.5;
    var bz = Math.sin(rad);
    var bw = Math.cos(rad);
    out.x = x * bw + y * bz;
    out.y = y * bw - x * bz;
    out.z = z * bw + w * bz;
    out.w = w * bw - z * bz;
  };
  Quaternion2.scale = function scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
    out.w = a.w * s;
  };
  function Quaternion2(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 1;
    }
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  var _proto = Quaternion2.prototype;
  _proto.setValue = function setValue(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  };
  _proto.conjugate = function conjugate() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  _proto.getAxisAngle = function getAxisAngle(out) {
    var x = this.x, y = this.y, z = this.z;
    var length = x * x + y * y + z * z;
    if (length < MathUtil.zeroTolerance) {
      out.x = 1;
      out.y = 0;
      out.z = 0;
      return 0;
    } else {
      var inv = 1 / length;
      out.x = this.x * inv;
      out.y = this.y * inv;
      out.z = this.z * inv;
      return Math.acos(this.w) * 2;
    }
  };
  _proto.identity = function identity() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.w = 1;
    return this;
  };
  _proto.length = function length() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return x * x + y * y + z * z + w * w;
  };
  _proto.normalize = function normalize() {
    Quaternion2.normalize(this, this);
    return this;
  };
  _proto.toEuler = function toEuler(out) {
    this.toYawPitchRoll(out);
    var t = out.x;
    out.x = out.y;
    out.y = t;
    return out;
  };
  _proto.toYawPitchRoll = function toYawPitchRoll(out) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var xy = x * y;
    var zw = z * w;
    var zx = z * x;
    var yw = y * w;
    var yz = y * z;
    var xw = x * w;
    out.y = Math.asin(2 * (xw - yz));
    if (Math.cos(out.y) > MathUtil.zeroTolerance) {
      out.z = Math.atan2(2 * (xy + zw), 1 - 2 * (zz + xx));
      out.x = Math.atan2(2 * (zx + yw), 1 - 2 * (yy + xx));
    } else {
      out.z = Math.atan2(-2 * (xy - zw), 1 - 2 * (yy + zz));
      out.x = 0;
    }
    return out;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
    out[outOffset + 3] = this.w;
  };
  _proto.clone = function clone2() {
    return new Quaternion2(this.x, this.y, this.z, this.w);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    out.w = this.w;
    return out;
  };
  _proto.rotateX = function rotateX(rad) {
    Quaternion2.rotateX(this, rad, this);
    return this;
  };
  _proto.rotateY = function rotateY(rad) {
    Quaternion2.rotateY(this, rad, this);
    return this;
  };
  _proto.rotateZ = function rotateZ(rad) {
    Quaternion2.rotateZ(this, rad, this);
    return this;
  };
  _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
    Quaternion2.rotationAxisAngle(axis, rad, this);
    return this;
  };
  _proto.multiply = function multiply(quat) {
    Quaternion2.multiply(this, quat, this);
    return this;
  };
  _proto.invert = function invert() {
    Quaternion2.invert(this, this);
    return this;
  };
  _proto.dot = function dot(quat) {
    return Quaternion2.dot(this, quat);
  };
  _proto.lerp = function lerp(quat, t) {
    Quaternion2.lerp(this, quat, t, this);
    return this;
  };
  return Quaternion2;
}();
Quaternion._tempVector3 = new Vector3();
var Matrix = function() {
  Matrix2.multiply = function multiply(left, right, out) {
    var le = left.elements;
    var re = right.elements;
    var oe = out.elements;
    var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3];
    var l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7];
    var l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11];
    var l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
    var r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3];
    var r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7];
    var r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11];
    var r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
    oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
    oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
    oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
    oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
    oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
    oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
    oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
    oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
    oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
    oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
    oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
    oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
    oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
    oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
    oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
    oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
  };
  Matrix2.equals = function equals(left, right) {
    var le = left.elements;
    var re = right.elements;
    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
  };
  Matrix2.rotationQuaternion = function rotationQuaternion(quaternion, out) {
    var oe = out.elements;
    var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    oe[0] = 1 - yy - zz;
    oe[1] = yx + wz;
    oe[2] = zx - wy;
    oe[3] = 0;
    oe[4] = yx - wz;
    oe[5] = 1 - xx - zz;
    oe[6] = zy + wx;
    oe[7] = 0;
    oe[8] = zx + wy;
    oe[9] = zy - wx;
    oe[10] = 1 - xx - yy;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  };
  Matrix2.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
    var oe = out.elements;
    var x = axis.x, y = axis.y, z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    var s, c, t;
    if (Math.abs(len) < MathUtil.zeroTolerance) {
      return;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    oe[0] = x * x * t + c;
    oe[1] = y * x * t + z * s;
    oe[2] = z * x * t - y * s;
    oe[3] = 0;
    oe[4] = x * y * t - z * s;
    oe[5] = y * y * t + c;
    oe[6] = z * y * t + x * s;
    oe[7] = 0;
    oe[8] = x * z * t + y * s;
    oe[9] = y * z * t - x * s;
    oe[10] = z * z * t + c;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  };
  Matrix2.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
    Matrix2.rotationQuaternion(quaternion, out);
    var oe = out.elements;
    oe[12] = translation.x;
    oe[13] = translation.y;
    oe[14] = translation.z;
  };
  Matrix2.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
    var oe = out.elements;
    var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = scale.x;
    var sy = scale.y;
    var sz = scale.z;
    oe[0] = (1 - (yy + zz)) * sx;
    oe[1] = (xy + wz) * sx;
    oe[2] = (xz - wy) * sx;
    oe[3] = 0;
    oe[4] = (xy - wz) * sy;
    oe[5] = (1 - (xx + zz)) * sy;
    oe[6] = (yz + wx) * sy;
    oe[7] = 0;
    oe[8] = (xz + wy) * sz;
    oe[9] = (yz - wx) * sz;
    oe[10] = (1 - (xx + yy)) * sz;
    oe[11] = 0;
    oe[12] = translation.x;
    oe[13] = translation.y;
    oe[14] = translation.z;
    oe[15] = 1;
  };
  Matrix2.scaling = function scaling(s, out) {
    var oe = out.elements;
    oe[0] = s.x;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = s.y;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = s.z;
    oe[11] = 0;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 0;
    oe[15] = 1;
  };
  Matrix2.translation = function translation(_translation, out) {
    var oe = out.elements;
    oe[0] = 1;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = 1;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = 1;
    oe[11] = 0;
    oe[12] = _translation.x;
    oe[13] = _translation.y;
    oe[14] = _translation.z;
    oe[15] = 1;
  };
  Matrix2.invert = function invert(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
    var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
    var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
    var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
    oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
    oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
    oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
    oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
    oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
    oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
    oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
    oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
    oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
    oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
    oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
    oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
    oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
    oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
  };
  Matrix2.lookAt = function lookAt(eye, target, up, out) {
    var oe = out.elements;
    var xAxis = Matrix2._tempVec30;
    var yAxis = Matrix2._tempVec31;
    var zAxis = Matrix2._tempVec32;
    Vector3.subtract(eye, target, zAxis);
    zAxis.normalize();
    Vector3.cross(up, zAxis, xAxis);
    xAxis.normalize();
    Vector3.cross(zAxis, xAxis, yAxis);
    oe[0] = xAxis.x;
    oe[1] = yAxis.x;
    oe[2] = zAxis.x;
    oe[3] = 0;
    oe[4] = xAxis.y;
    oe[5] = yAxis.y;
    oe[6] = zAxis.y;
    oe[7] = 0;
    oe[8] = xAxis.z;
    oe[9] = yAxis.z;
    oe[10] = zAxis.z;
    oe[11] = 0;
    oe[12] = -Vector3.dot(xAxis, eye);
    oe[13] = -Vector3.dot(yAxis, eye);
    oe[14] = -Vector3.dot(zAxis, eye);
    oe[15] = 1;
  };
  Matrix2.ortho = function ortho(left, right, bottom, top, near, far, out) {
    var oe = out.elements;
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    oe[0] = -2 * lr;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = -2 * bt;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = 2 * nf;
    oe[11] = 0;
    oe[12] = (left + right) * lr;
    oe[13] = (top + bottom) * bt;
    oe[14] = (far + near) * nf;
    oe[15] = 1;
  };
  Matrix2.perspective = function perspective(fovy, aspect, near, far, out) {
    var oe = out.elements;
    var f = 1 / Math.tan(fovy / 2);
    var nf = 1 / (near - far);
    oe[0] = f / aspect;
    oe[1] = 0;
    oe[2] = 0;
    oe[3] = 0;
    oe[4] = 0;
    oe[5] = f;
    oe[6] = 0;
    oe[7] = 0;
    oe[8] = 0;
    oe[9] = 0;
    oe[10] = (far + near) * nf;
    oe[11] = -1;
    oe[12] = 0;
    oe[13] = 0;
    oe[14] = 2 * far * near * nf;
    oe[15] = 0;
  };
  Matrix2.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
    var x = axis.x, y = axis.y, z = axis.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    if (Math.abs(len) < MathUtil.zeroTolerance) {
      return;
    }
    var me = m.elements;
    var oe = out.elements;
    var s, c, t;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(r);
    c = Math.cos(r);
    t = 1 - c;
    var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
    var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
    var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
    var b11 = x * x * t + c;
    var b12 = y * x * t + z * s;
    var b13 = z * x * t - y * s;
    var b21 = x * y * t - z * s;
    var b22 = y * y * t + c;
    var b23 = z * y * t + x * s;
    var b31 = x * z * t + y * s;
    var b32 = y * z * t - x * s;
    var b33 = z * z * t + c;
    oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
    oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
    oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
    oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
    oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
    oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
    oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
    oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
    oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
    oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
    oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
    oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
    if (m !== out) {
      oe[12] = me[12];
      oe[13] = me[13];
      oe[14] = me[14];
      oe[15] = me[15];
    }
  };
  Matrix2.scale = function scale(m, s, out) {
    var me = m.elements;
    var oe = out.elements;
    var x = s.x, y = s.y, z = s.z;
    oe[0] = me[0] * x;
    oe[1] = me[1] * x;
    oe[2] = me[2] * x;
    oe[3] = me[3] * x;
    oe[4] = me[4] * y;
    oe[5] = me[5] * y;
    oe[6] = me[6] * y;
    oe[7] = me[7] * y;
    oe[8] = me[8] * z;
    oe[9] = me[9] * z;
    oe[10] = me[10] * z;
    oe[11] = me[11] * z;
    oe[12] = me[12];
    oe[13] = me[13];
    oe[14] = me[14];
    oe[15] = me[15];
  };
  Matrix2.translate = function translate(m, v, out) {
    var me = m.elements;
    var oe = out.elements;
    var x = v.x, y = v.y, z = v.z;
    if (m === out) {
      oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
      oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
      oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
      oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
    } else {
      var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
      var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
      var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
      oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
      oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
      oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
      oe[12] = a11 * x + a21 * y + a31 * z + me[12];
      oe[13] = a12 * x + a22 * y + a32 * z + me[13];
      oe[14] = a13 * x + a23 * y + a33 * z + me[14];
      oe[15] = a14 * x + a24 * y + a34 * z + me[15];
    }
  };
  Matrix2.transpose = function transpose(a, out) {
    var ae = a.elements;
    var oe = out.elements;
    if (out === a) {
      var a12 = ae[1];
      var a13 = ae[2];
      var a14 = ae[3];
      var a23 = ae[6];
      var a24 = ae[7];
      var a34 = ae[11];
      oe[1] = ae[4];
      oe[2] = ae[8];
      oe[3] = ae[12];
      oe[4] = a12;
      oe[6] = ae[9];
      oe[7] = ae[13];
      oe[8] = a13;
      oe[9] = a23;
      oe[11] = ae[14];
      oe[12] = a14;
      oe[13] = a24;
      oe[14] = a34;
    } else {
      oe[0] = ae[0];
      oe[1] = ae[4];
      oe[2] = ae[8];
      oe[3] = ae[12];
      oe[4] = ae[1];
      oe[5] = ae[5];
      oe[6] = ae[9];
      oe[7] = ae[13];
      oe[8] = ae[2];
      oe[9] = ae[6];
      oe[10] = ae[10];
      oe[11] = ae[14];
      oe[12] = ae[3];
      oe[13] = ae[7];
      oe[14] = ae[11];
      oe[15] = ae[15];
    }
  };
  function Matrix2(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    if (m11 === void 0) {
      m11 = 1;
    }
    if (m12 === void 0) {
      m12 = 0;
    }
    if (m13 === void 0) {
      m13 = 0;
    }
    if (m14 === void 0) {
      m14 = 0;
    }
    if (m21 === void 0) {
      m21 = 0;
    }
    if (m22 === void 0) {
      m22 = 1;
    }
    if (m23 === void 0) {
      m23 = 0;
    }
    if (m24 === void 0) {
      m24 = 0;
    }
    if (m31 === void 0) {
      m31 = 0;
    }
    if (m32 === void 0) {
      m32 = 0;
    }
    if (m33 === void 0) {
      m33 = 1;
    }
    if (m34 === void 0) {
      m34 = 0;
    }
    if (m41 === void 0) {
      m41 = 0;
    }
    if (m42 === void 0) {
      m42 = 0;
    }
    if (m43 === void 0) {
      m43 = 0;
    }
    if (m44 === void 0) {
      m44 = 1;
    }
    this.elements = new Float32Array(16);
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
  }
  var _proto = Matrix2.prototype;
  _proto.setValue = function setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
    var e = this.elements;
    e[0] = m11;
    e[1] = m12;
    e[2] = m13;
    e[3] = m14;
    e[4] = m21;
    e[5] = m22;
    e[6] = m23;
    e[7] = m24;
    e[8] = m31;
    e[9] = m32;
    e[10] = m33;
    e[11] = m34;
    e[12] = m41;
    e[13] = m42;
    e[14] = m43;
    e[15] = m44;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var srce = this.elements;
    for (var i = 0; i < 16; i++) {
      srce[i] = array[i + offset];
    }
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    var e = this.elements;
    out[outOffset] = e[0];
    out[outOffset + 1] = e[1];
    out[outOffset + 2] = e[2];
    out[outOffset + 3] = e[3];
    out[outOffset + 4] = e[4];
    out[outOffset + 5] = e[5];
    out[outOffset + 6] = e[6];
    out[outOffset + 7] = e[7];
    out[outOffset + 8] = e[8];
    out[outOffset + 9] = e[9];
    out[outOffset + 10] = e[10];
    out[outOffset + 11] = e[11];
    out[outOffset + 12] = e[12];
    out[outOffset + 13] = e[13];
    out[outOffset + 14] = e[14];
    out[outOffset + 15] = e[15];
  };
  _proto.clone = function clone2() {
    var e = this.elements;
    var ret = new Matrix2(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    var e = this.elements;
    var oe = out.elements;
    oe[0] = e[0];
    oe[1] = e[1];
    oe[2] = e[2];
    oe[3] = e[3];
    oe[4] = e[4];
    oe[5] = e[5];
    oe[6] = e[6];
    oe[7] = e[7];
    oe[8] = e[8];
    oe[9] = e[9];
    oe[10] = e[10];
    oe[11] = e[11];
    oe[12] = e[12];
    oe[13] = e[13];
    oe[14] = e[14];
    oe[15] = e[15];
    return out;
  };
  _proto.multiply = function multiply(right) {
    Matrix2.multiply(this, right, this);
    return this;
  };
  _proto.determinant = function determinant() {
    var e = this.elements;
    var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
    var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
    var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
    var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
    var b00 = a11 * a22 - a12 * a21;
    var b01 = a11 * a23 - a13 * a21;
    var b02 = a11 * a24 - a14 * a21;
    var b03 = a12 * a23 - a13 * a22;
    var b04 = a12 * a24 - a14 * a22;
    var b05 = a13 * a24 - a14 * a23;
    var b06 = a31 * a42 - a32 * a41;
    var b07 = a31 * a43 - a33 * a41;
    var b08 = a31 * a44 - a34 * a41;
    var b09 = a32 * a43 - a33 * a42;
    var b10 = a32 * a44 - a34 * a42;
    var b11 = a33 * a44 - a34 * a43;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  };
  _proto.decompose = function decompose(translation, rotation, scale) {
    var rm = Matrix2._tempMat30;
    var e = this.elements;
    var rme = rm.elements;
    var m11 = e[0];
    var m12 = e[1];
    var m13 = e[2];
    var m14 = e[3];
    var m21 = e[4];
    var m22 = e[5];
    var m23 = e[6];
    var m24 = e[7];
    var m31 = e[8];
    var m32 = e[9];
    var m33 = e[10];
    var m34 = e[11];
    translation.x = e[12];
    translation.y = e[13];
    translation.z = e[14];
    var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
    var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
    var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
    var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
      rotation.identity();
      return false;
    } else {
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      rme[0] = m11 * invSX;
      rme[1] = m12 * invSX;
      rme[2] = m13 * invSX;
      rme[3] = m21 * invSY;
      rme[4] = m22 * invSY;
      rme[5] = m23 * invSY;
      rme[6] = m31 * invSZ;
      rme[7] = m32 * invSZ;
      rme[8] = m33 * invSZ;
      Quaternion.rotationMatrix3x3(rm, rotation);
      return true;
    }
  };
  _proto.getRotation = function getRotation(out) {
    var e = this.elements;
    var trace = e[0] + e[5] + e[10];
    if (trace > MathUtil.zeroTolerance) {
      var S = Math.sqrt(trace + 1) * 2;
      out.w = 0.25 * S;
      out.x = (e[6] - e[9]) / S;
      out.y = (e[8] - e[2]) / S;
      out.z = (e[1] - e[4]) / S;
    } else if (e[0] > e[5] && e[0] > e[10]) {
      var _S = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;
      out.w = (e[6] - e[9]) / _S;
      out.x = 0.25 * _S;
      out.y = (e[1] + e[4]) / _S;
      out.z = (e[8] + e[2]) / _S;
    } else if (e[5] > e[10]) {
      var _S2 = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;
      out.w = (e[8] - e[2]) / _S2;
      out.x = (e[1] + e[4]) / _S2;
      out.y = 0.25 * _S2;
      out.z = (e[6] + e[9]) / _S2;
    } else {
      var _S3 = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;
      out.w = (e[1] - e[4]) / _S3;
      out.x = (e[8] + e[2]) / _S3;
      out.y = (e[6] + e[9]) / _S3;
      out.z = 0.25 * _S3;
    }
    return out;
  };
  _proto.getScaling = function getScaling(out) {
    var e = this.elements;
    var m11 = e[0], m12 = e[1], m13 = e[2];
    var m21 = e[4], m22 = e[5], m23 = e[6];
    var m31 = e[8], m32 = e[9], m33 = e[10];
    out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  };
  _proto.getTranslation = function getTranslation(out) {
    var e = this.elements;
    out.x = e[12];
    out.y = e[13];
    out.z = e[14];
    return out;
  };
  _proto.identity = function identity() {
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 1;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
    e[9] = 0;
    e[10] = 1;
    e[11] = 0;
    e[12] = 0;
    e[13] = 0;
    e[14] = 0;
    e[15] = 1;
    return this;
  };
  _proto.invert = function invert() {
    Matrix2.invert(this, this);
    return this;
  };
  _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
    Matrix2.rotateAxisAngle(this, axis, r, this);
    return this;
  };
  _proto.scale = function scale(s) {
    Matrix2.scale(this, s, this);
    return this;
  };
  _proto.translate = function translate(v) {
    Matrix2.translate(this, v, this);
    return this;
  };
  _proto.transpose = function transpose() {
    Matrix2.transpose(this, this);
    return this;
  };
  return Matrix2;
}();
Matrix._tempVec30 = new Vector3();
Matrix._tempVec31 = new Vector3();
Matrix._tempVec32 = new Vector3();
Matrix._tempMat30 = new Matrix3x3();
Matrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
var Ray = function() {
  function Ray2(origin, direction) {
    if (origin === void 0) {
      origin = null;
    }
    if (direction === void 0) {
      direction = null;
    }
    this.origin = new Vector3();
    this.direction = new Vector3();
    origin && origin.cloneTo(this.origin);
    direction && direction.cloneTo(this.direction);
  }
  var _proto = Ray2.prototype;
  _proto.intersectPlane = function intersectPlane(plane) {
    return CollisionUtil.intersectsRayAndPlane(this, plane);
  };
  _proto.intersectSphere = function intersectSphere(sphere) {
    return CollisionUtil.intersectsRayAndSphere(this, sphere);
  };
  _proto.intersectBox = function intersectBox(box) {
    return CollisionUtil.intersectsRayAndBox(this, box);
  };
  _proto.getPoint = function getPoint(distance, out) {
    Vector3.scale(this.direction, distance, out);
    return out.add(this.origin);
  };
  return Ray2;
}();
var ESP = MathUtil.zeroTolerance;
var Spherical = function() {
  function Spherical2(radius, phi, theta) {
    this.radius = void 0;
    this.phi = void 0;
    this.theta = void 0;
    this.radius = radius !== void 0 ? radius : 1;
    this.phi = phi !== void 0 ? phi : 0;
    this.theta = theta !== void 0 ? theta : 0;
  }
  var _proto = Spherical2.prototype;
  _proto.set = function set4(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  };
  _proto.makeSafe = function makeSafe() {
    this.phi = MathUtil.clamp(this.phi, ESP, Math.PI - ESP);
    return this;
  };
  _proto.setFromVec3 = function setFromVec3(v3) {
    this.radius = v3.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(v3.x, v3.z);
      this.phi = Math.acos(MathUtil.clamp(v3.y / this.radius, -1, 1));
    }
    return this;
  };
  _proto.setToVec3 = function setToVec3(v3) {
    var sinPhiRadius = Math.sin(this.phi) * this.radius;
    v3.x = sinPhiRadius * Math.sin(this.theta);
    v3.y = Math.cos(this.phi) * this.radius;
    v3.z = sinPhiRadius * Math.cos(this.theta);
    return this;
  };
  return Spherical2;
}();
var Vector2 = function() {
  Vector22.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
  };
  Vector22.subtract = function subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
  };
  Vector22.multiply = function multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
  };
  Vector22.divide = function divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
  };
  Vector22.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y;
  };
  Vector22.distance = function distance(left, right) {
    var x = right.x - left.x;
    var y = right.y - left.y;
    return Math.sqrt(x * x + y * y);
  };
  Vector22.distanceSquared = function distanceSquared(left, right) {
    var x = right.x - left.x;
    var y = right.y - left.y;
    return x * x + y * y;
  };
  Vector22.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);
  };
  Vector22.lerp = function lerp(left, right, t, out) {
    var x = left.x, y = left.y;
    out.x = x + (right.x - x) * t;
    out.y = y + (right.y - y) * t;
  };
  Vector22.max = function max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
  };
  Vector22.min = function min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
  };
  Vector22.negate = function negate(left, out) {
    out.x = -left.x;
    out.y = -left.y;
  };
  Vector22.normalize = function normalize(left, out) {
    var x = left.x, y = left.y;
    var len = Math.sqrt(x * x + y * y);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
    }
  };
  Vector22.scale = function scale(left, s, out) {
    out.x = left.x * s;
    out.y = left.y * s;
  };
  function Vector22(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Vector22.prototype;
  _proto.setValue = function setValue(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  };
  _proto.add = function add(right) {
    this.x += right.x;
    this.y += right.y;
    return this;
  };
  _proto.subtract = function subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    return this;
  };
  _proto.multiply = function multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    return this;
  };
  _proto.divide = function divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    return this;
  };
  _proto.length = function length() {
    var x = this.x, y = this.y;
    return Math.sqrt(x * x + y * y);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y;
    return x * x + y * y;
  };
  _proto.negate = function negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  _proto.normalize = function normalize() {
    Vector22.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
  };
  _proto.clone = function clone2() {
    return new Vector22(this.x, this.y);
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    return out;
  };
  return Vector22;
}();
Vector2._zero = new Vector2(0, 0);
Vector2._one = new Vector2(1, 1);
var Vector4 = function() {
  Vector42.add = function add(left, right, out) {
    out.x = left.x + right.x;
    out.y = left.y + right.y;
    out.z = left.z + right.z;
    out.w = left.w + right.w;
  };
  Vector42.subtract = function subtract(left, right, out) {
    out.x = left.x - right.x;
    out.y = left.y - right.y;
    out.z = left.z - right.z;
    out.w = left.w - right.w;
  };
  Vector42.multiply = function multiply(left, right, out) {
    out.x = left.x * right.x;
    out.y = left.y * right.y;
    out.z = left.z * right.z;
    out.w = left.w * right.w;
  };
  Vector42.divide = function divide(left, right, out) {
    out.x = left.x / right.x;
    out.y = left.y / right.y;
    out.z = left.z / right.z;
    out.w = left.w / right.w;
  };
  Vector42.dot = function dot(left, right) {
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
  };
  Vector42.distance = function distance(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    var w = b.w - a.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  Vector42.distanceSquared = function distanceSquared(a, b) {
    var x = b.x - a.x;
    var y = b.y - a.y;
    var z = b.z - a.z;
    var w = b.w - a.w;
    return x * x + y * y + z * z + w * w;
  };
  Vector42.equals = function equals(left, right) {
    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
  };
  Vector42.lerp = function lerp(start, end, t, out) {
    var x = start.x, y = start.y, z = start.z, w = start.w;
    out.x = x + (end.x - x) * t;
    out.y = y + (end.y - y) * t;
    out.z = z + (end.z - z) * t;
    out.w = w + (end.w - w) * t;
  };
  Vector42.max = function max(left, right, out) {
    out.x = Math.max(left.x, right.x);
    out.y = Math.max(left.y, right.y);
    out.z = Math.max(left.z, right.z);
    out.w = Math.max(left.w, right.w);
  };
  Vector42.min = function min(left, right, out) {
    out.x = Math.min(left.x, right.x);
    out.y = Math.min(left.y, right.y);
    out.z = Math.min(left.z, right.z);
    out.w = Math.min(left.w, right.w);
  };
  Vector42.negate = function negate(a, out) {
    out.x = -a.x;
    out.y = -a.y;
    out.z = -a.z;
    out.w = -a.w;
  };
  Vector42.normalize = function normalize(a, out) {
    var x = a.x, y = a.y, z = a.z, w = a.w;
    var len = Math.sqrt(x * x + y * y + z * z + w * w);
    if (len > MathUtil.zeroTolerance) {
      len = 1 / len;
      out.x = x * len;
      out.y = y * len;
      out.z = z * len;
      out.w = w * len;
    }
  };
  Vector42.scale = function scale(a, s, out) {
    out.x = a.x * s;
    out.y = a.y * s;
    out.z = a.z * s;
    out.w = a.w * s;
  };
  Vector42.transform = function transform(v, m, out) {
    var x = v.x, y = v.y, z = v.z, w = v.w;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];
    out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];
    out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];
    out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];
  };
  Vector42.transformByQuat = function transformByQuat(v, q, out) {
    var x = v.x, y = v.y, z = v.z, w = v.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    out.x = ix * qw - iw * qx - iy * qz + iz * qy;
    out.y = iy * qw - iw * qy - iz * qx + ix * qz;
    out.z = iz * qw - iw * qz - ix * qy + iy * qx;
    out.w = w;
  };
  function Vector42(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 0;
    }
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  var _proto = Vector42.prototype;
  _proto.setValue = function setValue(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  _proto.setValueByArray = function setValueByArray(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  };
  _proto.add = function add(right) {
    this.x += right.x;
    this.y += right.y;
    this.z += right.z;
    this.w += right.w;
    return this;
  };
  _proto.subtract = function subtract(right) {
    this.x -= right.x;
    this.y -= right.y;
    this.z -= right.z;
    this.w -= right.w;
    return this;
  };
  _proto.multiply = function multiply(right) {
    this.x *= right.x;
    this.y *= right.y;
    this.z *= right.z;
    this.w *= right.w;
    return this;
  };
  _proto.divide = function divide(right) {
    this.x /= right.x;
    this.y /= right.y;
    this.z /= right.z;
    this.w /= right.w;
    return this;
  };
  _proto.length = function length() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  _proto.lengthSquared = function lengthSquared() {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    return x * x + y * y + z * z + w * w;
  };
  _proto.negate = function negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  };
  _proto.normalize = function normalize() {
    Vector42.normalize(this, this);
    return this;
  };
  _proto.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;
    this.w *= s;
    return this;
  };
  _proto.toArray = function toArray(out, outOffset) {
    if (outOffset === void 0) {
      outOffset = 0;
    }
    out[outOffset] = this.x;
    out[outOffset + 1] = this.y;
    out[outOffset + 2] = this.z;
    out[outOffset + 3] = this.w;
  };
  _proto.clone = function clone2() {
    var ret = new Vector42(this.x, this.y, this.z, this.w);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    out.x = this.x;
    out.y = this.y;
    out.z = this.z;
    out.w = this.w;
    return out;
  };
  return Vector42;
}();
Vector4._zero = new Vector4(0, 0, 0, 0);
Vector4._one = new Vector4(1, 1, 1, 1);
var Color = function() {
  Color2.gammaToLinearSpace = function gammaToLinearSpace(value) {
    if (value <= 0)
      return 0;
    else if (value <= 0.04045)
      return value / 12.92;
    else if (value < 1)
      return Math.pow((value + 0.055) / 1.055, 2.4);
    else
      return Math.pow(value, 2.4);
  };
  Color2.linearToGammaSpace = function linearToGammaSpace(value) {
    if (value <= 0)
      return 0;
    else if (value < 31308e-7)
      return 12.92 * value;
    else if (value < 1)
      return 1.055 * Math.pow(value, 0.41666) - 0.055;
    else
      return Math.pow(value, 0.41666);
  };
  Color2.equals = function equals(left, right) {
    return MathUtil.equals(left.r, right.r) && MathUtil.equals(left.g, right.g) && MathUtil.equals(left.b, right.b) && MathUtil.equals(left.a, right.a);
  };
  function Color2(r, g, b, a) {
    if (r === void 0) {
      r = 1;
    }
    if (g === void 0) {
      g = 1;
    }
    if (b === void 0) {
      b = 1;
    }
    if (a === void 0) {
      a = 1;
    }
    this.r = void 0;
    this.g = void 0;
    this.b = void 0;
    this.a = void 0;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  var _proto = Color2.prototype;
  _proto.clone = function clone2() {
    var ret = new Color2(this.r, this.g, this.b, this.a);
    return ret;
  };
  _proto.cloneTo = function cloneTo(out) {
    out.r = this.r;
    out.g = this.g;
    out.b = this.b;
    out.a = this.a;
    return out;
  };
  _proto.toLinear = function toLinear(out) {
    out.r = Color2.gammaToLinearSpace(this.r);
    out.g = Color2.gammaToLinearSpace(this.g);
    out.b = Color2.gammaToLinearSpace(this.b);
    return out;
  };
  _proto.toGamma = function toGamma(out) {
    out.r = Color2.linearToGammaSpace(this.r);
    out.g = Color2.linearToGammaSpace(this.g);
    out.b = Color2.linearToGammaSpace(this.b);
    return out;
  };
  return Color2;
}();

// node_modules/@oasis-engine/core/dist/module.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct3(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor)
    return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var AssetPromiseStatus;
(function(AssetPromiseStatus2) {
  AssetPromiseStatus2[AssetPromiseStatus2["Success"] = 0] = "Success";
  AssetPromiseStatus2[AssetPromiseStatus2["Pending"] = 1] = "Pending";
  AssetPromiseStatus2[AssetPromiseStatus2["Failed"] = 2] = "Failed";
})(AssetPromiseStatus || (AssetPromiseStatus = {}));
var AssetPromise = function(_Promise) {
  _inheritsLoose(AssetPromise2, _Promise);
  AssetPromise2.all = function all(promises) {
    return new AssetPromise2(function(resolve, reject, setProgress) {
      if (!Array.isArray(promises)) {
        return resolve([promises]);
      }
      var completed = 0;
      var total = promises.length;
      var results = new Array(total);
      promises.forEach(function(value, index) {
        Promise.resolve(value).then(function(result) {
          results[index] = result;
          completed += 1;
          setProgress(completed / total);
          if (completed == total) {
            resolve(results);
          }
        }).catch(function(err) {
          return reject(err);
        });
      });
    });
  };
  var _proto = AssetPromise2.prototype;
  _proto.onProgress = function onProgress(callback) {
    this._listeners.add(callback);
    return this;
  };
  _proto.cancel = function cancel() {
    if (this._status !== AssetPromiseStatus.Pending) {
      return this;
    }
    this._reject("Promise Canceled");
    return this;
  };
  function AssetPromise2(executor) {
    var _this;
    var newReject;
    var setProgress = function setProgress2(progress) {
      if (progress <= _this._progress) {
        return;
      }
      _this._progress = progress;
      for (var _iterator = _createForOfIteratorHelperLoose(_this._listeners), _step; !(_step = _iterator()).done; ) {
        var listener = _step.value;
        listener(progress);
      }
    };
    _this = _Promise.call(this, function(resolve, reject) {
      newReject = function newReject2(reason) {
        Promise.resolve().then(function() {
          _this._status = AssetPromiseStatus.Failed;
          reject(reason);
        });
      };
      executor(function(value) {
        Promise.resolve().then(function() {
          setProgress(1);
          _this._status = AssetPromiseStatus.Success;
          resolve(value);
        });
      }, newReject, function(progress) {
        Promise.resolve().then(function() {
          setProgress(progress);
        });
      });
    }) || this;
    _this._status = void 0;
    _this._progress = void 0;
    _this._reject = void 0;
    _this._listeners = void 0;
    _this._reject = newReject;
    _this._listeners = new Set();
    _this._progress = 0;
    _this._status = AssetPromiseStatus.Pending;
    return _this;
  }
  _createClass(AssetPromise2, [{
    key: "status",
    get: function get4() {
      return this._status;
    }
  }, {
    key: "progress",
    get: function get4() {
      return this._progress;
    }
  }]);
  return AssetPromise2;
}(_wrapNativeSuper(Promise));
var Util = {
  isArray: "isArray" in Array ? Array.isArray : function(value) {
    return toString.call(value) === "[object Array]";
  },
  isArrayLike: function isArrayLike(x) {
    return !!x && typeof x.length === "number" && typeof x !== "function";
  },
  clone: function clone(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (Util.isArrayLike(obj)) {
      rst = obj.slice();
      for (var i = 0, l = obj.length; i < l; i++) {
        rst[i] = Util.clone(obj[i]);
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
          rst[k] = Util.clone(obj[k]);
        }
      }
    }
    return rst;
  },
  downloadBlob: function downloadBlob(blob, fileName) {
    if (fileName === void 0) {
      fileName = "";
    }
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function() {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
};
function removeFromArray(array, item) {
  var index = array.indexOf(item);
  if (index < 0) {
    return false;
  }
  var last = array.length - 1;
  if (index !== last) {
    var end = array[last];
    array[index] = end;
  }
  array.length--;
  return true;
}
function ObjectValues(obj) {
  return Object.keys(obj).map(function(key) {
    return obj[key];
  });
}
var ResourceManager = function() {
  ResourceManager2._addLoader = function _addLoader(type, loader, extnames) {
    this._loaders[type] = loader;
    for (var i = 0, len = extnames.length; i < len; i++) {
      this._extTypeMapping[extnames[i]] = type;
    }
  };
  ResourceManager2._getTypeByUrl = function _getTypeByUrl(url) {
    var path = url.split("?")[0];
    return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
  };
  function ResourceManager2(engine) {
    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = 2e4;
    this._assetPool = Object.create(null);
    this._assetUrlPool = Object.create(null);
    this._refObjectPool = Object.create(null);
    this._loadingPromises = {};
  }
  var _proto = ResourceManager2.prototype;
  _proto.load = function load(assetInfo) {
    var _this = this;
    if (!Array.isArray(assetInfo)) {
      return this._loadSingleItem(assetInfo);
    }
    var promises = assetInfo.map(function(item) {
      return _this._loadSingleItem(item);
    });
    return AssetPromise.all(promises);
  };
  _proto.cancelNotLoaded = function cancelNotLoaded(url) {
    var _this2 = this;
    if (!url) {
      ObjectValues(this._loadingPromises).forEach(function(promise) {
        promise.cancel();
      });
    } else if (typeof url === "string") {
      var _this$_loadingPromise;
      (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
    } else {
      url.forEach(function(p) {
        var _this2$_loadingPromis;
        (_this2$_loadingPromis = _this2._loadingPromises[p]) === null || _this2$_loadingPromis === void 0 ? void 0 : _this2$_loadingPromis.cancel();
      });
    }
  };
  _proto.gc = function gc() {
    var objects = ObjectValues(this._refObjectPool);
    for (var i = 0, len = objects.length; i < len; i++) {
      if (!objects[i].isGCIgnored) {
        objects[i].destroy();
      }
    }
  };
  _proto.getAssetPath = function getAssetPath(instanceId) {
    return this._assetPool[instanceId];
  };
  _proto._addAsset = function _addAsset(path, asset) {
    this._assetPool[asset.instanceId] = path;
    this._assetUrlPool[path] = asset;
  };
  _proto._deleteAsset = function _deleteAsset(asset) {
    var id = asset.instanceId;
    var path = this._assetPool[id];
    if (path) {
      delete this._assetPool[id];
      delete this._assetUrlPool[path];
    }
  };
  _proto._addRefObject = function _addRefObject(id, asset) {
    this._refObjectPool[id] = asset;
  };
  _proto._deleteRefObject = function _deleteRefObject(id) {
    delete this._refObjectPool[id];
  };
  _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
    var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;
    assetInfo.type = (_assetInfo$type = assetInfo.type) != null ? _assetInfo$type : ResourceManager2._getTypeByUrl(assetInfo.url);
    if (assetInfo.type === void 0) {
      throw "asset type should be specified: " + assetInfo.url;
    }
    assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) != null ? _assetInfo$retryCount : this.retryCount;
    assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) != null ? _assetInfo$timeout : this.timeout;
    assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) != null ? _assetInfo$retryInter : this.retryInterval;
    assetInfo.url = (_assetInfo$url = assetInfo.url) != null ? _assetInfo$url : assetInfo.urls.join(",");
    return assetInfo;
  };
  _proto._loadSingleItem = function _loadSingleItem(item) {
    var _this3 = this;
    var info2 = this._assignDefaultOptions(typeof item === "string" ? {
      url: item
    } : item);
    var url = info2.url;
    if (this._assetUrlPool[url]) {
      return new AssetPromise(function(resolve) {
        resolve(_this3._assetUrlPool[url]);
      });
    }
    if (this._loadingPromises[url]) {
      return this._loadingPromises[info2.url];
    }
    var loader = ResourceManager2._loaders[info2.type];
    var promise = loader.load(info2, this);
    this._loadingPromises[url] = promise;
    promise.then(function(res) {
      if (loader.useCache)
        _this3._addAsset(url, res);
      delete _this3._loadingPromises[url];
    }).catch(function() {
    });
    return promise;
  };
  return ResourceManager2;
}();
ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
function resourceLoader(assetType, extnames, useCache) {
  if (useCache === void 0) {
    useCache = true;
  }
  return function(Target) {
    var loader = new Target(useCache);
    ResourceManager._addLoader(assetType, loader, extnames);
  };
}
var Event = function() {
  function Event2(type, target, data, bubbles) {
    if (target === void 0) {
      target = null;
    }
    if (data === void 0) {
      data = {};
    }
    if (bubbles === void 0) {
      bubbles = true;
    }
    this.data = void 0;
    this._timeStamp = void 0;
    this._target = void 0;
    this._currentTarget = void 0;
    this._bubbles = void 0;
    this._propagationStopped = void 0;
    this._type = void 0;
    this._timeStamp = new Date().getTime();
    this._target = target;
    this.data = data;
    this._currentTarget = null;
    this._bubbles = bubbles;
    this._propagationStopped = false;
    this._type = type;
  }
  var _proto = Event2.prototype;
  _proto.stopPropagation = function stopPropagation() {
    this._propagationStopped = true;
  };
  _createClass(Event2, [{
    key: "propagationStopped",
    get: function get4() {
      return this._propagationStopped;
    }
  }, {
    key: "target",
    get: function get4() {
      return this._target;
    },
    set: function set4(t) {
      this._target = t;
    }
  }, {
    key: "timeStamp",
    get: function get4() {
      return this._timeStamp;
    }
  }, {
    key: "currentTarget",
    get: function get4() {
      return this._currentTarget;
    },
    set: function set4(t) {
      this._currentTarget = t;
    }
  }, {
    key: "bubbles",
    get: function get4() {
      return this._bubbles;
    }
  }, {
    key: "type",
    get: function get4() {
      return this._type;
    }
  }]);
  return Event2;
}();
var CloneMode;
(function(CloneMode2) {
  CloneMode2[CloneMode2["Ignore"] = 0] = "Ignore";
  CloneMode2[CloneMode2["Assignment"] = 1] = "Assignment";
  CloneMode2[CloneMode2["Shallow"] = 2] = "Shallow";
  CloneMode2[CloneMode2["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));
function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
function assignmentClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}
function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
var CloneManager = function() {
  function CloneManager2() {
  }
  CloneManager2.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
    var targetMap = CloneManager2._subCloneModeMap.get(target.constructor);
    if (!targetMap) {
      targetMap = Object.create(null);
      CloneManager2._subCloneModeMap.set(target.constructor, targetMap);
    }
    targetMap[propertyKey] = mode;
  };
  CloneManager2.getCloneMode = function getCloneMode(type) {
    var cloneModes = CloneManager2._cloneModeMap.get(type);
    if (!cloneModes) {
      cloneModes = Object.create(null);
      CloneManager2._cloneModeMap.set(type, cloneModes);
      var obejctType = CloneManager2._obejctType;
      var cloneModeMap = CloneManager2._subCloneModeMap;
      while (type !== obejctType) {
        var subCloneModes = cloneModeMap.get(type);
        if (subCloneModes) {
          _extends(cloneModes, subCloneModes);
        }
        type = Object.getPrototypeOf(type);
      }
    }
    return cloneModes;
  };
  CloneManager2.deepCloneObject = function deepCloneObject(source, target) {
    var type = source.constructor;
    switch (type) {
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case Float32Array:
      case Float64Array:
        target.set(source);
        break;
      case Array:
        for (var i = 0, n = source.length; i < n; i++) {
          CloneManager2._deepCloneObjectItem(source, target, i);
        }
        break;
      default:
        var customSource = source;
        if (customSource.clone && customSource.cloneTo) {
          customSource.cloneTo(target);
        } else {
          var keys = Object.keys(source);
          for (var _i = 0, _n = keys.length; _i < _n; _i++) {
            CloneManager2._deepCloneObjectItem(source, target, keys[_i]);
          }
        }
    }
  };
  CloneManager2._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k) {
    var sourceItem = source[k];
    if (sourceItem instanceof Object) {
      var itemType = sourceItem.constructor;
      switch (itemType) {
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          var sourceTypeArrayItem = sourceItem;
          var targetTypeArrayItem = target[k];
          if (targetTypeArrayItem == null) {
            target[k] = sourceTypeArrayItem.slice();
          } else {
            targetTypeArrayItem.set(sourceTypeArrayItem);
          }
          break;
        case Array:
          var sourceArryItem = sourceItem;
          var targetArrayItem = target[k];
          if (targetArrayItem == null) {
            target[k] = new Array(sourceArryItem.length);
          } else {
            targetArrayItem.length = sourceArryItem.length;
          }
          CloneManager2.deepCloneObject(sourceArryItem, targetArrayItem);
          break;
        default:
          if (sourceItem.clone && sourceItem.cloneTo) {
            var sourceCustomItem = sourceItem;
            var targetCustomItem = target[k];
            if (targetCustomItem) {
              sourceCustomItem.cloneTo(targetCustomItem);
            } else {
              target[k] = sourceCustomItem.clone();
            }
          } else {
            var targetItem = target[k];
            targetItem == null && (target[k] = targetItem = new sourceItem.constructor());
            CloneManager2.deepCloneObject(sourceItem, targetItem);
            break;
          }
      }
    } else {
      target[k] = sourceItem;
    }
  };
  return CloneManager2;
}();
CloneManager._subCloneModeMap = new Map();
CloneManager._cloneModeMap = new Map();
CloneManager._obejctType = Object.getPrototypeOf(Object);
var _class;
var _descriptor;
var _descriptor2;
var _class2;
var _temp;
var EngineObject = (_class = (_temp = _class2 = function EngineObject2(engine) {
  _initializerDefineProperty(this, "instanceId", _descriptor, this);
  _initializerDefineProperty(this, "_engine", _descriptor2, this);
  this._engine = engine;
}, _class2._instanceIdCounter = 0, _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "instanceId", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return ++EngineObject._instanceIdCounter;
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "_engine", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _class);
var _class$1;
var _descriptor$1;
var _temp$1;
var EventDispatcher = (_class$1 = (_temp$1 = function(_EngineObject) {
  _inheritsLoose(EventDispatcher2, _EngineObject);
  function EventDispatcher2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_evts", _descriptor$1, _assertThisInitialized(_this));
    _this._evtCount = 0;
    return _this;
  }
  var _proto = EventDispatcher2.prototype;
  _proto.hasEvent = function hasEvent(event) {
    return this._evts[event] != null;
  };
  _proto.eventNames = function eventNames() {
    if (this._evtCount === 0)
      return [];
    return Object.keys(this._evts);
  };
  _proto.listenerCount = function listenerCount(event) {
    var listeners = this._evts[event];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  _proto.dispatch = function dispatch(event, data) {
    if (!this._evts[event]) {
      return false;
    }
    var listeners = this._evts[event];
    if (listeners.fn) {
      if (listeners.once)
        this.removeEventListener(event, listeners.fn);
      listeners.fn(data);
    } else {
      var l = listeners.length;
      for (var i = 0; i < l; i++) {
        if (listeners[i].once)
          this.removeEventListener(event, listeners[i].fn);
        listeners[i].fn(data);
      }
    }
    return true;
  };
  _proto.on = function on(event, fn) {
    return this.addEventListener(event, fn);
  };
  _proto.once = function once(event, fn) {
    return this.addEventListener(event, fn, true);
  };
  _proto.addEventListener = function addEventListener(event, fn, once) {
    var listener = {
      fn,
      once
    };
    var events = this._evts;
    if (!events[event]) {
      events[event] = listener;
      this._evtCount++;
    } else if (!events[event].fn) {
      events[event].push(listener);
    } else {
      events[event] = [events[event], listener];
    }
    return this;
  };
  _proto.off = function off(event, fn) {
    if (!this._evts[event])
      return this;
    if (!fn) {
      this._clearEvent(event);
      return this;
    }
    var listeners = this._evts[event];
    if (listeners.fn && listeners.fn === fn) {
      this._clearEvent(event);
    } else {
      var index = listeners.indexOf(fn);
      if (index > -1) {
        var temp = listeners[listeners.length - 1];
        listeners[index] = temp;
        listeners.length--;
        if (listeners.length === 1) {
          this._evts[event] = listeners[0];
        }
      }
    }
    return this;
  };
  _proto.removeEventListener = function removeEventListener(event, fn) {
    return this.off(event, fn);
  };
  _proto.removeAllEventListeners = function removeAllEventListeners(event) {
    if (event) {
      if (this._evts[event])
        this._clearEvent(event);
    } else {
      this._evts = Object.create(null);
      this._evtCount = 0;
    }
  };
  _proto.trigger = function trigger(e) {
    this.dispatch(e.type, e.data);
  };
  _proto._clearEvent = function _clearEvent(event) {
    if (--this._evtCount === 0) {
      this._evts = Object.create(null);
    } else {
      delete this._evts[event];
    }
  };
  return EventDispatcher2;
}(EngineObject), _temp$1), _descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "_evts", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer2() {
    return Object.create(null);
  }
}), _class$1);
var noop = function noop2(message) {
};
var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,
  enable: function enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },
  disable: function disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};
var Time = function() {
  function Time2() {
    this._clock = void 0;
    this._timeScale = void 0;
    this._deltaTime = void 0;
    this._startTime = void 0;
    this._lastTickTime = void 0;
    this._clock = performance ? performance : Date;
    this._timeScale = 1;
    this._deltaTime = 1e-4;
    var now = this._clock.now();
    this._startTime = now;
    this._lastTickTime = now;
  }
  var _proto = Time2.prototype;
  _proto.reset = function reset() {
    this._lastTickTime = this._clock.now();
  };
  _proto.tick = function tick() {
    var now = this.nowTime;
    this._deltaTime = (now - this._lastTickTime) * this._timeScale;
    this._lastTickTime = now;
  };
  _createClass(Time2, [{
    key: "nowTime",
    get: function get4() {
      return this._clock.now();
    }
  }, {
    key: "deltaTime",
    get: function get4() {
      return this._deltaTime;
    }
  }, {
    key: "timeScale",
    get: function get4() {
      return this._timeScale;
    },
    set: function set4(s) {
      this._timeScale = s;
    }
  }, {
    key: "unscaledDeltaTime",
    get: function get4() {
      return this._deltaTime / this._timeScale;
    }
  }, {
    key: "timeSinceStartup",
    get: function get4() {
      return this.nowTime - this._startTime;
    }
  }]);
  return Time2;
}();
var InternalAssetType;
(function(InternalAssetType2) {
  InternalAssetType2[InternalAssetType2["Scene"] = 1] = "Scene";
  InternalAssetType2[InternalAssetType2["Cache"] = 2] = "Cache";
})(InternalAssetType || (InternalAssetType = {}));
var ClearMode;
(function(ClearMode2) {
  ClearMode2[ClearMode2["DONT_CLEAR"] = 0] = "DONT_CLEAR";
  ClearMode2[ClearMode2["SOLID_COLOR"] = 1] = "SOLID_COLOR";
  ClearMode2[ClearMode2["DEPTH_ONLY"] = 2] = "DEPTH_ONLY";
  ClearMode2[ClearMode2["COLOR_ONLY"] = 3] = "COLOR_ONLY";
  ClearMode2[ClearMode2["STENCIL_ONLY"] = 4] = "STENCIL_ONLY";
  ClearMode2[ClearMode2["ALL_CLEAR"] = 5] = "ALL_CLEAR";
})(ClearMode || (ClearMode = {}));
var MaterialType;
(function(MaterialType2) {
  MaterialType2[MaterialType2["OPAQUE"] = 1e3] = "OPAQUE";
  MaterialType2[MaterialType2["TRANSPARENT"] = 2e3] = "TRANSPARENT";
})(MaterialType || (MaterialType = {}));
var RenderState;
(function(RenderState2) {
  RenderState2[RenderState2["BLEND"] = 3042] = "BLEND";
  RenderState2[RenderState2["CULL_FACE"] = 2884] = "CULL_FACE";
  RenderState2[RenderState2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  RenderState2[RenderState2["ALPHA_TEST"] = 3008] = "ALPHA_TEST";
  RenderState2[RenderState2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  RenderState2[RenderState2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  RenderState2[RenderState2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
})(RenderState || (RenderState = {}));
var FrontFace;
(function(FrontFace2) {
  FrontFace2[FrontFace2["CW"] = 2304] = "CW";
  FrontFace2[FrontFace2["CCW"] = 2305] = "CCW";
})(FrontFace || (FrontFace = {}));
var CullFace;
(function(CullFace2) {
  CullFace2[CullFace2["FRONT"] = 1028] = "FRONT";
  CullFace2[CullFace2["BACK"] = 1029] = "BACK";
  CullFace2[CullFace2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(CullFace || (CullFace = {}));
var Side;
(function(Side2) {
  Side2[Side2["FRONT"] = 0] = "FRONT";
  Side2[Side2["BACK"] = 1] = "BACK";
  Side2[Side2["NONE"] = 2] = "NONE";
  Side2[Side2["DOUBLE"] = 3] = "DOUBLE";
})(Side || (Side = {}));
var CompFunc;
(function(CompFunc2) {
  CompFunc2[CompFunc2["NEVER"] = 512] = "NEVER";
  CompFunc2[CompFunc2["LESS"] = 513] = "LESS";
  CompFunc2[CompFunc2["EQUAL"] = 514] = "EQUAL";
  CompFunc2[CompFunc2["LEQUAL"] = 515] = "LEQUAL";
  CompFunc2[CompFunc2["GREATER"] = 516] = "GREATER";
  CompFunc2[CompFunc2["NOTEQUAL"] = 517] = "NOTEQUAL";
  CompFunc2[CompFunc2["GEQUAL"] = 518] = "GEQUAL";
  CompFunc2[CompFunc2["ALWAYS"] = 519] = "ALWAYS";
})(CompFunc || (CompFunc = {}));
var DataType;
(function(DataType2) {
  DataType2[DataType2["FLOAT"] = 5126] = "FLOAT";
  DataType2[DataType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType2[DataType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType2[DataType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType2[DataType2["INT"] = 5124] = "INT";
  DataType2[DataType2["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType2[DataType2["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType2[DataType2["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType2[DataType2["BOOL"] = 35670] = "BOOL";
  DataType2[DataType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType2[DataType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType2[DataType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType2[DataType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType2[DataType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType2[DataType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType2[DataType2["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType2[DataType2["FLOAT_VEC2_ARRAY"] = 1e5] = "FLOAT_VEC2_ARRAY";
  DataType2[DataType2["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType2[DataType2["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType2[DataType2["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType2[DataType2["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType2[DataType2["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType2[DataType2["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType2[DataType2["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType2[DataType2["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType2[DataType2["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType2[DataType2["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType2[DataType2["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType2[DataType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType2[DataType2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType2[DataType2["BYTE"] = 5120] = "BYTE";
  DataType2[DataType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType2[DataType2["SHORT"] = 5122] = "SHORT";
  DataType2[DataType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType2[DataType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(DataType || (DataType = {}));
var UniformSemantic;
(function(UniformSemantic2) {
  UniformSemantic2[UniformSemantic2["LOCAL"] = 1] = "LOCAL";
  UniformSemantic2[UniformSemantic2["MODEL"] = 2] = "MODEL";
  UniformSemantic2[UniformSemantic2["VIEW"] = 3] = "VIEW";
  UniformSemantic2[UniformSemantic2["PROJECTION"] = 4] = "PROJECTION";
  UniformSemantic2[UniformSemantic2["MODELVIEW"] = 5] = "MODELVIEW";
  UniformSemantic2[UniformSemantic2["VIEWPROJECTION"] = 21] = "VIEWPROJECTION";
  UniformSemantic2[UniformSemantic2["MODELVIEWPROJECTION"] = 6] = "MODELVIEWPROJECTION";
  UniformSemantic2[UniformSemantic2["MODELINVERSE"] = 7] = "MODELINVERSE";
  UniformSemantic2[UniformSemantic2["VIEWINVERSE"] = 8] = "VIEWINVERSE";
  UniformSemantic2[UniformSemantic2["PROJECTIONINVERSE"] = 9] = "PROJECTIONINVERSE";
  UniformSemantic2[UniformSemantic2["MODELVIEWINVERSE"] = 10] = "MODELVIEWINVERSE";
  UniformSemantic2[UniformSemantic2["MODELVIEWPROJECTIONINVERSE"] = 11] = "MODELVIEWPROJECTIONINVERSE";
  UniformSemantic2[UniformSemantic2["MODELINVERSETRANSPOSE"] = 12] = "MODELINVERSETRANSPOSE";
  UniformSemantic2[UniformSemantic2["MODELVIEWINVERSETRANSPOSE"] = 13] = "MODELVIEWINVERSETRANSPOSE";
  UniformSemantic2[UniformSemantic2["VIEWPORT"] = 14] = "VIEWPORT";
  UniformSemantic2[UniformSemantic2["JOINTMATRIX"] = 15] = "JOINTMATRIX";
  UniformSemantic2[UniformSemantic2["MORPHWEIGHTS"] = 16] = "MORPHWEIGHTS";
  UniformSemantic2[UniformSemantic2["EYEPOS"] = 17] = "EYEPOS";
  UniformSemantic2[UniformSemantic2["TIME"] = 18] = "TIME";
  UniformSemantic2[UniformSemantic2["JOINTTEXTURE"] = 19] = "JOINTTEXTURE";
  UniformSemantic2[UniformSemantic2["JOINTCOUNT"] = 20] = "JOINTCOUNT";
})(UniformSemantic || (UniformSemantic = {}));
var BlendFunc;
(function(BlendFunc2) {
  BlendFunc2[BlendFunc2["ZERO"] = 0] = "ZERO";
  BlendFunc2[BlendFunc2["ONE"] = 1] = "ONE";
  BlendFunc2[BlendFunc2["SRC_COLOR"] = 768] = "SRC_COLOR";
  BlendFunc2[BlendFunc2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  BlendFunc2[BlendFunc2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  BlendFunc2[BlendFunc2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  BlendFunc2[BlendFunc2["DST_ALPHA"] = 772] = "DST_ALPHA";
  BlendFunc2[BlendFunc2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  BlendFunc2[BlendFunc2["DST_COLOR"] = 774] = "DST_COLOR";
  BlendFunc2[BlendFunc2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  BlendFunc2[BlendFunc2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  BlendFunc2[BlendFunc2["enumANT_COLOR"] = 32769] = "enumANT_COLOR";
  BlendFunc2[BlendFunc2["ONE_MINUS_enumANT_COLOR"] = 32770] = "ONE_MINUS_enumANT_COLOR";
  BlendFunc2[BlendFunc2["enumANT_ALPHA"] = 32771] = "enumANT_ALPHA";
  BlendFunc2[BlendFunc2["ONE_MINUS_enumANT_ALPHA"] = 32772] = "ONE_MINUS_enumANT_ALPHA";
})(BlendFunc || (BlendFunc = {}));
var RefreshRate;
(function(RefreshRate2) {
  RefreshRate2[RefreshRate2["ONCE"] = 1] = "ONCE";
  RefreshRate2[RefreshRate2["EVERYFRAME"] = 2] = "EVERYFRAME";
})(RefreshRate || (RefreshRate = {}));
var GLCapabilityType;
(function(GLCapabilityType2) {
  GLCapabilityType2["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType2["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType2["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType2["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType2["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType2["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType2["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType2["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType2["textureFloat"] = "OES_texture_float";
  GLCapabilityType2["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType2["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType2["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType2["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType2["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType2["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType2["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType2["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType2["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType2["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType2["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType2["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType2["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
})(GLCapabilityType || (GLCapabilityType = {}));
var DisorderedArray = function() {
  function DisorderedArray2(count) {
    if (count === void 0) {
      count = 0;
    }
    this._elements = void 0;
    this.length = 0;
    this._elements = new Array(count);
  }
  var _proto = DisorderedArray2.prototype;
  _proto.add = function add(element) {
    if (this.length === this._elements.length)
      this._elements.push(element);
    else
      this._elements[this.length] = element;
    this.length++;
  };
  _proto.delete = function _delete(element) {
    var index = this._elements.indexOf(element);
    this.deleteByIndex(index);
  };
  _proto.deleteByIndex = function deleteByIndex(index) {
    var elements = this._elements;
    var end = null;
    var lastIndex = this.length - 1;
    if (index !== lastIndex) {
      end = elements[lastIndex];
      elements[index] = end;
    }
    this.length--;
    return end;
  };
  _proto.garbageCollection = function garbageCollection() {
    this._elements.length = this.length;
  };
  return DisorderedArray2;
}();
var ShaderMacroCollection = function() {
  function ShaderMacroCollection2() {
    this._mask = [];
    this._length = 0;
  }
  ShaderMacroCollection2.unionCollection = function unionCollection(left, right, out) {
    var outMask = out._mask;
    var minSize, maxSize;
    var minMask, maxMask;
    if (left._length < right._length) {
      minSize = left._length;
      maxSize = right._length;
      minMask = left._mask;
      maxMask = right._mask;
    } else {
      minSize = right._length;
      maxSize = left._length;
      minMask = right._mask;
      maxMask = left._mask;
    }
    var i = 0;
    outMask.length < maxSize && (outMask.length = maxSize);
    for (; i < minSize; i++) {
      outMask[i] = minMask[i] | maxMask[i];
    }
    for (; i < maxSize; i++) {
      outMask[i] = maxMask[i];
    }
    out._length = maxSize;
  };
  var _proto = ShaderMacroCollection2.prototype;
  _proto.enable = function enable2(macro) {
    var index = macro._index;
    var size = index + 1;
    var mask = this._mask;
    var maskStart = this._length;
    if (maskStart < size) {
      mask.length < size && (mask.length = size);
      for (; maskStart < index; maskStart++) {
        mask[maskStart] = 0;
      }
      mask[index] = macro._value;
      this._length = size;
    } else {
      mask[index] |= macro._value;
    }
  };
  _proto.disable = function disable2(macro) {
    var index = macro._index;
    var mask = this._mask;
    var endIndex = this._length - 1;
    if (index > endIndex) {
      return;
    }
    var newValue = mask[index] & ~macro._value;
    if (index == endIndex && newValue === 0) {
      this._length--;
    } else {
      mask[index] = newValue;
    }
  };
  _proto.unionCollection = function unionCollection(macroCollection) {
    var addMask = macroCollection._mask;
    var addSize = macroCollection._length;
    var mask = this._mask;
    var maskSize = this._length;
    if (maskSize < addSize) {
      mask.length < addSize && (mask.length = addSize);
      var i = 0;
      for (; i < maskSize; i++) {
        mask[i] |= addMask[i];
      }
      for (; i < addSize; i++) {
        mask[i] = addMask[i];
      }
      this._length = addSize;
    } else {
      for (var _i = 0; _i < addSize; _i++) {
        mask[_i] |= addMask[_i];
      }
    }
  };
  _proto.complementaryCollection = function complementaryCollection(macroCollection) {
    var removeMask = macroCollection._mask;
    var mask = this._mask;
    var endIndex = this._length - 1;
    var i = Math.min(macroCollection._length - 1, endIndex);
    for (; i >= 0; i--) {
      var newValue = mask[i] & ~removeMask[i];
      if (i == endIndex && newValue === 0) {
        endIndex--;
        this._length--;
      } else {
        mask[i] = newValue;
      }
    }
  };
  _proto.intersectionCollection = function intersectionCollection(macroCollection) {
    var unionMask = macroCollection._mask;
    var mask = this._mask;
    for (var i = this._length - 1; i >= 0; i--) {
      var value = mask[i] & unionMask[i];
      if (value == 0 && i == this._length - 1) {
        this._length--;
      } else {
        mask[i] = value;
      }
    }
  };
  _proto.isEnable = function isEnable(macro) {
    var index = macro._index;
    if (index >= this._length) {
      return false;
    }
    return (this._mask[index] & macro._value) !== 0;
  };
  _proto.clear = function clear() {
    this._length = 0;
  };
  return ShaderMacroCollection2;
}();
var ComponentsManager = function() {
  function ComponentsManager2() {
    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._destoryComponents = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._renderers = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }
  var _proto = ComponentsManager2.prototype;
  _proto.addRenderer = function addRenderer(renderer) {
    renderer._rendererIndex = this._renderers.length;
    this._renderers.add(renderer);
  };
  _proto.removeRenderer = function removeRenderer(renderer) {
    var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
    replaced && (replaced._rendererIndex = renderer._rendererIndex);
    renderer._rendererIndex = -1;
  };
  _proto.addOnStartScript = function addOnStartScript(script2) {
    script2._onStartIndex = this._onStartScripts.length;
    this._onStartScripts.add(script2);
  };
  _proto.removeOnStartScript = function removeOnStartScript(script2) {
    var replaced = this._onStartScripts.deleteByIndex(script2._onStartIndex);
    replaced && (replaced._onStartIndex = script2._onStartIndex);
    script2._onStartIndex = -1;
  };
  _proto.addOnUpdateScript = function addOnUpdateScript(script2) {
    script2._onUpdateIndex = this._onUpdateScripts.length;
    this._onUpdateScripts.add(script2);
  };
  _proto.removeOnUpdateScript = function removeOnUpdateScript(script2) {
    var replaced = this._onUpdateScripts.deleteByIndex(script2._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = script2._onUpdateIndex);
    script2._onUpdateIndex = -1;
  };
  _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script2) {
    script2._onLateUpdateIndex = this._onLateUpdateScripts.length;
    this._onLateUpdateScripts.add(script2);
  };
  _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script2) {
    var replaced = this._onLateUpdateScripts.deleteByIndex(script2._onLateUpdateIndex);
    replaced && (replaced._onLateUpdateIndex = script2._onLateUpdateIndex);
    script2._onLateUpdateIndex = -1;
  };
  _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
    animation._onUpdateIndex = this._onUpdateAnimations.length;
    this._onUpdateAnimations.add(animation);
  };
  _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
    var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
    animation._onUpdateIndex = -1;
  };
  _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
    renderer._onUpdateIndex = this._onUpdateRenderers.length;
    this._onUpdateRenderers.add(renderer);
  };
  _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
    var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
    renderer._onUpdateIndex = -1;
  };
  _proto.addDestoryComponent = function addDestoryComponent(component) {
    this._destoryComponents.push(component);
  };
  _proto.callScriptOnStart = function callScriptOnStart() {
    var onStartScripts = this._onStartScripts;
    if (onStartScripts.length > 0) {
      var elements = onStartScripts._elements;
      for (var i = 0; i < onStartScripts.length; i++) {
        var script2 = elements[i];
        script2._started = true;
        script2._onStartIndex = -1;
        script2.onStart();
      }
      onStartScripts.length = 0;
    }
  };
  _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
    var elements = this._onUpdateScripts._elements;
    for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (element._started) {
        element.onUpdate(deltaTime);
      }
    }
  };
  _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
    var elements = this._onLateUpdateScripts._elements;
    for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (element._started) {
        element.onLateUpdate(deltaTime);
      }
    }
  };
  _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
    var elements = this._onUpdateAnimations._elements;
    for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };
  _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
    var elements = this._onUpdateRenderers._elements;
    for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  };
  _proto.callRender = function callRender(context) {
    var camera = context._camera;
    var elements = this._renderers._elements;
    for (var i = this._renderers.length - 1; i >= 0; --i) {
      var element = elements[i];
      if (!(camera.cullingMask & element._entity.layer)) {
        continue;
      }
      if (camera.enableFrustumCulling) {
        element.isCulled = !camera._frustum.intersectsBox(element.bounds);
        if (element.isCulled) {
          continue;
        }
      }
      element._updateShaderData(context);
      ShaderMacroCollection.unionCollection(camera._globalShaderMacro, element.shaderData._macroCollection, element._globalShaderMacro);
      element._render(camera);
    }
  };
  _proto.callComponentDestory = function callComponentDestory() {
    var destoryComponents = this._destoryComponents;
    var length = destoryComponents.length;
    if (length > 0) {
      for (var i = length - 1; i >= 0; --i) {
        destoryComponents[i].onDestroy();
      }
      destoryComponents.length = 0;
    }
  };
  _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
    var camComps = camera.entity._components;
    for (var i = camComps.length - 1; i >= 0; --i) {
      var camComp = camComps[i];
      camComp.onBeginRender && camComp.onBeginRender(camera);
    }
  };
  _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
    var camComps = camera.entity._components;
    for (var i = camComps.length - 1; i >= 0; --i) {
      var camComp = camComps[i];
      camComp.onBeginRender && camComp.onEndRender(camera);
    }
  };
  _proto.getActiveChangedTempList = function getActiveChangedTempList() {
    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
  };
  _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
    componentContainer.length = 0;
    this._componentsContainerPool.push(componentContainer);
  };
  return ComponentsManager2;
}();
var ComponentCloner = function() {
  function ComponentCloner2() {
  }
  ComponentCloner2.cloneComponent = function cloneComponent(source, target) {
    var cloneModes = CloneManager.getCloneMode(source.constructor);
    var keys = Object.keys(source);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var cloneMode = cloneModes[k];
      switch (cloneMode) {
        case void 0:
        case CloneMode.Assignment:
          target[k] = source[k];
          break;
        case CloneMode.Shallow:
          var sourcePropS = source[k];
          if (sourcePropS instanceof Object) {
            var tarProp = target[k];
            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());
            _extends(tarProp, sourcePropS);
          } else {
            target[k] = sourcePropS;
          }
          break;
        case CloneMode.Deep:
          var sourcePropD = source[k];
          if (sourcePropD instanceof Object) {
            var _tarProp = target[k];
            _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());
            CloneManager.deepCloneObject(sourcePropD, _tarProp);
          } else {
            target[k] = sourcePropD;
          }
          break;
      }
    }
  };
  return ComponentCloner2;
}();
var ComponentsDependencies = function() {
  ComponentsDependencies2.register = function register(currentComponent, dependentComponent) {
    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);
    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
  };
  ComponentsDependencies2._addCheck = function _addCheck(entity, type) {
    var dependencies2 = ComponentsDependencies2._dependenciesMap.get(type);
    if (dependencies2) {
      for (var i = 0, len = dependencies2.length; i < len; i++) {
        if (!entity.getComponent(dependencies2[i])) {
          throw "you should add " + dependencies2[i] + " before adding " + type;
        }
      }
    }
  };
  ComponentsDependencies2._removeCheck = function _removeCheck(entity, type) {
    var invDenpendencies = ComponentsDependencies2._invDependenciesMap.get(type);
    if (invDenpendencies) {
      for (var i = 0, len = invDenpendencies.length; i < len; i++) {
        if (entity.getComponent(invDenpendencies[i])) {
          throw "you should remove " + invDenpendencies[i] + " before adding " + type;
        }
      }
    }
  };
  ComponentsDependencies2._addDependency = function _addDependency(currentComponent, dependentComponent, map) {
    var components = map.get(currentComponent);
    if (!components) {
      components = [];
      map.set(currentComponent, components);
    }
    if (components.indexOf(dependentComponent) === -1) {
      components.push(dependentComponent);
    }
  };
  function ComponentsDependencies2() {
  }
  return ComponentsDependencies2;
}();
ComponentsDependencies._dependenciesMap = new Map();
ComponentsDependencies._invDependenciesMap = new Map();
function dependencies() {
  for (var _len = arguments.length, abilityClass = new Array(_len), _key = 0; _key < _len; _key++) {
    abilityClass[_key] = arguments[_key];
  }
  return function(target) {
    abilityClass.forEach(function(ability) {
      return ComponentsDependencies.register(target, ability);
    });
  };
}
var Layer;
(function(Layer2) {
  Layer2[Layer2["Layer0"] = 1] = "Layer0";
  Layer2[Layer2["Layer1"] = 2] = "Layer1";
  Layer2[Layer2["Layer2"] = 4] = "Layer2";
  Layer2[Layer2["Layer3"] = 8] = "Layer3";
  Layer2[Layer2["Layer4"] = 16] = "Layer4";
  Layer2[Layer2["Layer5"] = 32] = "Layer5";
  Layer2[Layer2["Layer6"] = 64] = "Layer6";
  Layer2[Layer2["Layer7"] = 128] = "Layer7";
  Layer2[Layer2["Layer8"] = 256] = "Layer8";
  Layer2[Layer2["Layer9"] = 512] = "Layer9";
  Layer2[Layer2["Layer10"] = 1024] = "Layer10";
  Layer2[Layer2["Layer11"] = 2048] = "Layer11";
  Layer2[Layer2["Layer12"] = 4096] = "Layer12";
  Layer2[Layer2["Layer13"] = 8192] = "Layer13";
  Layer2[Layer2["Layer14"] = 16384] = "Layer14";
  Layer2[Layer2["Layer15"] = 32768] = "Layer15";
  Layer2[Layer2["Layer16"] = 65536] = "Layer16";
  Layer2[Layer2["Layer17"] = 131072] = "Layer17";
  Layer2[Layer2["Layer18"] = 262144] = "Layer18";
  Layer2[Layer2["Layer19"] = 524288] = "Layer19";
  Layer2[Layer2["Layer20"] = 1048576] = "Layer20";
  Layer2[Layer2["Layer21"] = 2097152] = "Layer21";
  Layer2[Layer2["Layer22"] = 4194304] = "Layer22";
  Layer2[Layer2["Layer23"] = 8388608] = "Layer23";
  Layer2[Layer2["Layer24"] = 16777216] = "Layer24";
  Layer2[Layer2["Layer25"] = 33554432] = "Layer25";
  Layer2[Layer2["Layer26"] = 67108864] = "Layer26";
  Layer2[Layer2["Layer27"] = 134217728] = "Layer27";
  Layer2[Layer2["Layer28"] = 268435456] = "Layer28";
  Layer2[Layer2["Layer29"] = 536870912] = "Layer29";
  Layer2[Layer2["Layer30"] = 1073741824] = "Layer30";
  Layer2[Layer2["Layer31"] = 2147483648] = "Layer31";
  Layer2[Layer2["Everything"] = 4294967295] = "Everything";
  Layer2[Layer2["Nothing"] = 0] = "Nothing";
})(Layer || (Layer = {}));
var _class$2;
var _descriptor$2;
var _descriptor2$1;
var _descriptor3;
var _descriptor4;
var _temp$2;
var Component = (_class$2 = (_temp$2 = function(_EngineObject) {
  _inheritsLoose(Component2, _EngineObject);
  function Component2(entity) {
    var _this;
    _this = _EngineObject.call(this, entity.engine) || this;
    _initializerDefineProperty(_this, "_entity", _descriptor$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_destroyed", _descriptor2$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_enabled", _descriptor3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_awaked", _descriptor4, _assertThisInitialized(_this));
    _this._renderPriority = 0;
    _this._entity = entity;
    return _this;
  }
  var _proto = Component2.prototype;
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._entity._removeComponent(this);
    if (this._entity.isActiveInHierarchy) {
      this._enabled && this._onDisable();
      this._onInActive();
    }
    this._destroyed = true;
    this._onDestroy();
  };
  _proto._onAwake = function _onAwake() {
  };
  _proto._onEnable = function _onEnable() {
  };
  _proto._onDisable = function _onDisable() {
  };
  _proto._onDestroy = function _onDestroy() {
  };
  _proto._onActive = function _onActive() {
  };
  _proto._onInActive = function _onInActive() {
  };
  _proto._setActive = function _setActive(value) {
    if (value) {
      if (!this._awaked) {
        this._awaked = true;
        this._onAwake();
      }
      if (this._entity._isActiveInHierarchy) {
        this._onActive();
        this._enabled && this._onEnable();
      }
    } else {
      this._enabled && this._onDisable();
      this._onInActive();
    }
  };
  _createClass(Component2, [{
    key: "enabled",
    get: function get4() {
      return this._enabled;
    },
    set: function set4(value) {
      if (value === this._enabled) {
        return;
      }
      this._enabled = value;
      if (value) {
        this._entity.isActiveInHierarchy && this._onEnable();
      } else {
        this._entity.isActiveInHierarchy && this._onDisable();
      }
    }
  }, {
    key: "destroyed",
    get: function get4() {
      return this._destroyed;
    }
  }, {
    key: "entity",
    get: function get4() {
      return this._entity;
    }
  }, {
    key: "scene",
    get: function get4() {
      return this._entity.scene;
    }
  }, {
    key: "engine",
    get: function get4() {
      return this._entity.engine;
    }
  }, {
    key: "renderPriority",
    get: function get4() {
      return this._renderPriority;
    },
    set: function set4(val) {
      this._renderPriority = val;
    }
  }]);
  return Component2;
}(EngineObject), _temp$2), _descriptor$2 = _applyDecoratedDescriptor(_class$2.prototype, "_entity", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$1 = _applyDecoratedDescriptor(_class$2.prototype, "_destroyed", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer3() {
    return false;
  }
}), _descriptor3 = _applyDecoratedDescriptor(_class$2.prototype, "_enabled", [assignmentClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer4() {
    return true;
  }
}), _descriptor4 = _applyDecoratedDescriptor(_class$2.prototype, "_awaked", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer5() {
    return false;
  }
}), _class$2);
var UpdateFlag = function() {
  function UpdateFlag2(_flags) {
    if (_flags === void 0) {
      _flags = [];
    }
    this._flags = _flags;
    this.flag = true;
  }
  var _proto = UpdateFlag2.prototype;
  _proto.destroy = function destroy() {
    var flags = this._flags;
    removeFromArray(flags, this);
    this._flags = null;
  };
  return UpdateFlag2;
}();
var _class$3;
var _descriptor$3;
var _descriptor2$2;
var _descriptor3$1;
var _descriptor4$1;
var _descriptor5;
var _descriptor6;
var _descriptor7;
var _descriptor8;
var _descriptor9;
var _descriptor10;
var _descriptor11;
var _descriptor12;
var _descriptor13;
var _class2$1;
var _temp$3;
var Transform = (_class$3 = (_temp$3 = _class2$1 = function(_Component) {
  _inheritsLoose(Transform2, _Component);
  function Transform2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_position", _descriptor$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rotation", _descriptor2$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rotationQuaternion", _descriptor3$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_scale", _descriptor4$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldPosition", _descriptor5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldRotation", _descriptor6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldRotationQuaternion", _descriptor7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lossyWorldScale", _descriptor8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_localMatrix", _descriptor9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_worldMatrix", _descriptor10, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_changeFlags", _descriptor11, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isParentDirty", _descriptor12, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_parentTransformCache", _descriptor13, _assertThisInitialized(_this));
    _this._dirtyFlag = Transform2._WM_WP_WE_WQ_WS_FLAGS;
    return _this;
  }
  var _proto = Transform2.prototype;
  _proto.setPosition = function setPosition(x, y, z) {
    this._position.setValue(x, y, z);
    this.position = this._position;
  };
  _proto.setRotation = function setRotation(x, y, z) {
    this._rotation.setValue(x, y, z);
    this.rotation = this._rotation;
  };
  _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
    this._rotationQuaternion.setValue(x, y, z, w);
    this.rotationQuaternion = this._rotationQuaternion;
  };
  _proto.setScale = function setScale(x, y, z) {
    this._scale.setValue(x, y, z);
    this.scale = this._scale;
  };
  _proto.setWorldPosition = function setWorldPosition(x, y, z) {
    this._worldPosition.setValue(x, y, z);
    this.worldPosition = this._worldPosition;
  };
  _proto.setWorldRotation = function setWorldRotation(x, y, z) {
    this._worldRotation.setValue(x, y, z);
    this.worldRotation = this._worldRotation;
  };
  _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
    this._worldRotationQuaternion.setValue(x, y, z, w);
    this.worldRotationQuaternion = this._worldRotationQuaternion;
  };
  _proto.getWorldForward = function getWorldForward(forward) {
    var e = this.worldMatrix.elements;
    forward.setValue(-e[8], -e[9], -e[10]);
    return forward.normalize();
  };
  _proto.getWorldRight = function getWorldRight(right) {
    var e = this.worldMatrix.elements;
    right.setValue(e[0], e[1], e[2]);
    return right.normalize();
  };
  _proto.getWorldUp = function getWorldUp(up) {
    var e = this.worldMatrix.elements;
    up.setValue(e[4], e[5], e[6]);
    return up.normalize();
  };
  _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof translationOrX === "number") {
      var _translate2 = Transform2._tempVec3;
      _translate2.setValue(translationOrX, relativeToLocalOrY, z);
      this._translate(_translate2, relativeToLocal);
    } else {
      this._translate(translationOrX, relativeToLocalOrY);
    }
  };
  _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
    if (typeof rotationOrX === "number") {
      this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
    } else {
      this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
    }
  };
  _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    var rad = angle * MathUtil.degreeToRadFactor;
    Quaternion.rotationAxisAngle(axis, rad, Transform2._tempQuat0);
    this._rotateByQuat(Transform2._tempQuat0, relativeToLocal);
  };
  _proto.lookAt = function lookAt(worldPosition, worldUp) {
    var _worldUp;
    var position = this.worldPosition;
    var EPSILON = MathUtil.zeroTolerance;
    if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {
      return;
    }
    var rotMat = Transform2._tempMat43;
    var worldRotationQuaternion = this._worldRotationQuaternion;
    worldUp = (_worldUp = worldUp) != null ? _worldUp : Transform2._tempVec3.setValue(0, 1, 0);
    Matrix.lookAt(position, worldPosition, worldUp, rotMat);
    rotMat.getRotation(worldRotationQuaternion).invert();
    this.worldRotationQuaternion = worldRotationQuaternion;
  };
  _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
    var flag = new UpdateFlag(this._changeFlags);
    this._changeFlags.push(flag);
    return flag;
  };
  _proto._parentChange = function _parentChange() {
    this._isParentDirty = true;
    this._updateAllWorldFlag();
  };
  _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
    if (!this._isContainDirtyFlags(Transform2._WM_WP_FLAGS)) {
      this._worldAssociatedChange(Transform2._WM_WP_FLAGS);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans;
        (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
      }
    }
  };
  _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
    if (!this._isContainDirtyFlags(Transform2._WM_WE_WQ_FLAGS)) {
      this._worldAssociatedChange(Transform2._WM_WE_WQ_FLAGS);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans2;
        (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag();
      }
    }
  };
  _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
    if (!this._isContainDirtyFlags(Transform2._WM_WP_WE_WQ_FLAGS)) {
      this._worldAssociatedChange(Transform2._WM_WP_WE_WQ_FLAGS);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans3;
        (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
      }
    }
  };
  _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
    if (!this._isContainDirtyFlags(Transform2._WM_WS_FLAGS)) {
      this._worldAssociatedChange(Transform2._WM_WS_FLAGS);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans4;
        (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
      }
    }
  };
  _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
    if (!this._isContainDirtyFlags(Transform2._WM_WP_WS_FLAGS)) {
      this._worldAssociatedChange(Transform2._WM_WP_WS_FLAGS);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans5;
        (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
      }
    }
  };
  _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
    if (!this._isContainDirtyFlags(Transform2._WM_WP_WE_WQ_WS_FLAGS)) {
      this._worldAssociatedChange(Transform2._WM_WP_WE_WQ_WS_FLAGS);
      var nodeChildren = this._entity._children;
      for (var i = 0, n = nodeChildren.length; i < n; i++) {
        var _nodeChildren$i$trans6;
        (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
      }
    }
  };
  _proto._getParentTransform = function _getParentTransform() {
    if (!this._isParentDirty) {
      return this._parentTransformCache;
    }
    var parentCache = null;
    var parent = this._entity.parent;
    while (parent) {
      var transform = parent.transform;
      if (transform) {
        parentCache = transform;
        break;
      } else {
        parent = parent.parent;
      }
    }
    this._parentTransformCache = parentCache;
    this._isParentDirty = false;
    return parentCache;
  };
  _proto._getScaleMatrix = function _getScaleMatrix() {
    var invRotation = Transform2._tempQuat0;
    var invRotationMat = Transform2._tempMat30;
    var worldRotScaMat = Transform2._tempMat31;
    var scaMat = Transform2._tempMat32;
    worldRotScaMat.setValueByMatrix(this.worldMatrix);
    Quaternion.invert(this.worldRotationQuaternion, invRotation);
    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
    return scaMat;
  };
  _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
  };
  _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  };
  _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  };
  _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  };
  _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
    this._dirtyFlag |= type;
    var len = this._changeFlags.length;
    for (var i = len - 1; i >= 0; i--) {
      this._changeFlags[i].flag = true;
    }
  };
  _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
    if (relativeToLocal) {
      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
      this.rotationQuaternion = this._rotationQuaternion;
    } else {
      Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;
    }
  };
  _proto._translate = function _translate(translation, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    if (relativeToLocal) {
      var rotationMat = Transform2._tempMat40;
      Matrix.rotationQuaternion(this.rotationQuaternion, rotationMat);
      Vector3.transformCoordinate(translation, rotationMat, Transform2._tempVec3);
      this.position = this._position.add(Transform2._tempVec3);
    } else {
      this.worldPosition = this._worldPosition.add(translation);
    }
  };
  _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    var radFactor = MathUtil.degreeToRadFactor;
    var rotQuat = Transform2._tempQuat0;
    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
    this._rotateByQuat(rotQuat, relativeToLocal);
  };
  _proto.translateXYZ = function translateXYZ(x, y, z, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    this.translate(x, y, z, relativeToLocal);
  };
  _proto.rotateXYZ = function rotateXYZ(x, y, z, relativeToLocal) {
    if (relativeToLocal === void 0) {
      relativeToLocal = true;
    }
    this.rotate(x, y, z, relativeToLocal);
  };
  _createClass(Transform2, [{
    key: "position",
    get: function get4() {
      return this._position;
    },
    set: function set4(value) {
      if (this._position !== value) {
        value.cloneTo(this._position);
      }
      this._setDirtyFlagTrue(Transform2._LOCAL_MATRIX_FLAG);
      this._updateWorldPositionFlag();
    }
  }, {
    key: "worldPosition",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._WORLD_POSITION_FLAG)) {
        if (this._getParentTransform()) {
          this.worldMatrix.getTranslation(this._worldPosition);
        } else {
          this._position.cloneTo(this._worldPosition);
        }
        this._setDirtyFlagFalse(Transform2._WORLD_POSITION_FLAG);
      }
      return this._worldPosition;
    },
    set: function set4(value) {
      if (this._worldPosition !== value) {
        value.cloneTo(this._worldPosition);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform2._tempMat41);
        Vector3.transformCoordinate(value, Transform2._tempMat41, this._position);
      } else {
        value.cloneTo(this._position);
      }
      this.position = this._position;
      this._setDirtyFlagFalse(Transform2._WORLD_POSITION_FLAG);
    }
  }, {
    key: "rotation",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._LOCAL_EULER_FLAG)) {
        this._rotationQuaternion.toEuler(this._rotation);
        this._rotation.scale(MathUtil.radToDegreeFactor);
        this._setDirtyFlagFalse(Transform2._LOCAL_EULER_FLAG);
      }
      return this._rotation;
    },
    set: function set4(value) {
      if (this._rotation !== value) {
        value.cloneTo(this._rotation);
      }
      this._setDirtyFlagTrue(Transform2._LOCAL_MATRIX_FLAG | Transform2._LOCAL_QUAT_FLAG);
      this._setDirtyFlagFalse(Transform2._LOCAL_EULER_FLAG);
      this._updateWorldRotationFlag();
    }
  }, {
    key: "worldRotation",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._WORLD_EULER_FLAG)) {
        this.worldRotationQuaternion.toEuler(this._worldRotation);
        this._worldRotation.scale(MathUtil.radToDegreeFactor);
        this._setDirtyFlagFalse(Transform2._WORLD_EULER_FLAG);
      }
      return this._worldRotation;
    },
    set: function set4(value) {
      if (this._worldRotation !== value) {
        value.cloneTo(this._worldRotation);
      }
      Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x), MathUtil.degreeToRadian(value.y), MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;
      this._setDirtyFlagFalse(Transform2._WORLD_EULER_FLAG);
    }
  }, {
    key: "rotationQuaternion",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._LOCAL_QUAT_FLAG)) {
        Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);
        this._setDirtyFlagFalse(Transform2._LOCAL_QUAT_FLAG);
      }
      return this._rotationQuaternion;
    },
    set: function set4(value) {
      if (this._rotationQuaternion !== value) {
        value.cloneTo(this._rotationQuaternion);
      }
      this._setDirtyFlagTrue(Transform2._LOCAL_MATRIX_FLAG | Transform2._LOCAL_EULER_FLAG);
      this._setDirtyFlagFalse(Transform2._LOCAL_QUAT_FLAG);
      this._updateWorldRotationFlag();
    }
  }, {
    key: "worldRotationQuaternion",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._WORLD_QUAT_FLAG)) {
        var parent = this._getParentTransform();
        if (parent != null) {
          Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
        } else {
          this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);
        }
        this._setDirtyFlagFalse(Transform2._WORLD_QUAT_FLAG);
      }
      return this._worldRotationQuaternion;
    },
    set: function set4(value) {
      if (this._worldRotationQuaternion !== value) {
        value.cloneTo(this._worldRotationQuaternion);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Quaternion.invert(parent.worldRotationQuaternion, Transform2._tempQuat0);
        Quaternion.multiply(value, Transform2._tempQuat0, this._rotationQuaternion);
      } else {
        value.cloneTo(this._rotationQuaternion);
      }
      this.rotationQuaternion = this._rotationQuaternion;
      this._setDirtyFlagFalse(Transform2._WORLD_QUAT_FLAG);
    }
  }, {
    key: "scale",
    get: function get4() {
      return this._scale;
    },
    set: function set4(value) {
      if (this._scale !== value) {
        value.cloneTo(this._scale);
      }
      this._setDirtyFlagTrue(Transform2._LOCAL_MATRIX_FLAG);
      this._updateWorldScaleFlag();
    }
  }, {
    key: "lossyWorldScale",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._WORLD_SCALE_FLAG)) {
        if (this._getParentTransform()) {
          var scaleMat = this._getScaleMatrix();
          var e = scaleMat.elements;
          this._lossyWorldScale.setValue(e[0], e[4], e[8]);
        } else {
          this._scale.cloneTo(this._lossyWorldScale);
        }
        this._setDirtyFlagFalse(Transform2._WORLD_SCALE_FLAG);
      }
      return this._lossyWorldScale;
    }
  }, {
    key: "localMatrix",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._LOCAL_MATRIX_FLAG)) {
        Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
        this._setDirtyFlagFalse(Transform2._LOCAL_MATRIX_FLAG);
      }
      return this._localMatrix;
    },
    set: function set4(value) {
      if (this._localMatrix !== value) {
        value.cloneTo(this._localMatrix);
      }
      this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
      this._setDirtyFlagTrue(Transform2._LOCAL_EULER_FLAG);
      this._setDirtyFlagFalse(Transform2._LOCAL_MATRIX_FLAG);
      this._updateAllWorldFlag();
    }
  }, {
    key: "worldMatrix",
    get: function get4() {
      if (this._isContainDirtyFlag(Transform2._WORLD_MATRIX_FLAG)) {
        var parent = this._getParentTransform();
        if (parent) {
          Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
        } else {
          this.localMatrix.cloneTo(this._worldMatrix);
        }
        this._setDirtyFlagFalse(Transform2._WORLD_MATRIX_FLAG);
      }
      return this._worldMatrix;
    },
    set: function set4(value) {
      if (this._worldMatrix !== value) {
        value.cloneTo(this._worldMatrix);
      }
      var parent = this._getParentTransform();
      if (parent) {
        Matrix.invert(parent.worldMatrix, Transform2._tempMat42);
        Matrix.multiply(value, Transform2._tempMat42, this._localMatrix);
      } else {
        value.cloneTo(this._localMatrix);
      }
      this.localMatrix = this._localMatrix;
      this._setDirtyFlagFalse(Transform2._WORLD_MATRIX_FLAG);
    }
  }]);
  return Transform2;
}(Component), _class2$1._tempQuat0 = new Quaternion(), _class2$1._tempVec3 = new Vector3(), _class2$1._tempMat30 = new Matrix3x3(), _class2$1._tempMat31 = new Matrix3x3(), _class2$1._tempMat32 = new Matrix3x3(), _class2$1._tempMat40 = new Matrix(), _class2$1._tempMat41 = new Matrix(), _class2$1._tempMat42 = new Matrix(), _class2$1._tempMat43 = new Matrix(), _class2$1._LOCAL_EULER_FLAG = 1, _class2$1._LOCAL_QUAT_FLAG = 2, _class2$1._WORLD_POSITION_FLAG = 4, _class2$1._WORLD_EULER_FLAG = 8, _class2$1._WORLD_QUAT_FLAG = 16, _class2$1._WORLD_SCALE_FLAG = 32, _class2$1._LOCAL_MATRIX_FLAG = 64, _class2$1._WORLD_MATRIX_FLAG = 128, _class2$1._WM_WP_FLAGS = 132, _class2$1._WM_WE_WQ_FLAGS = 152, _class2$1._WM_WP_WE_WQ_FLAGS = 156, _class2$1._WM_WS_FLAGS = 160, _class2$1._WM_WP_WS_FLAGS = 164, _class2$1._WM_WP_WE_WQ_WS_FLAGS = 188, _temp$3), _descriptor$3 = _applyDecoratedDescriptor(_class$3.prototype, "_position", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer6() {
    return new Vector3();
  }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class$3.prototype, "_rotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer7() {
    return new Vector3();
  }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class$3.prototype, "_rotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer8() {
    return new Quaternion();
  }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class$3.prototype, "_scale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer9() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor5 = _applyDecoratedDescriptor(_class$3.prototype, "_worldPosition", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer10() {
    return new Vector3();
  }
}), _descriptor6 = _applyDecoratedDescriptor(_class$3.prototype, "_worldRotation", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer11() {
    return new Vector3();
  }
}), _descriptor7 = _applyDecoratedDescriptor(_class$3.prototype, "_worldRotationQuaternion", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer12() {
    return new Quaternion();
  }
}), _descriptor8 = _applyDecoratedDescriptor(_class$3.prototype, "_lossyWorldScale", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer13() {
    return new Vector3(1, 1, 1);
  }
}), _descriptor9 = _applyDecoratedDescriptor(_class$3.prototype, "_localMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer14() {
    return new Matrix();
  }
}), _descriptor10 = _applyDecoratedDescriptor(_class$3.prototype, "_worldMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer15() {
    return new Matrix();
  }
}), _descriptor11 = _applyDecoratedDescriptor(_class$3.prototype, "_changeFlags", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer16() {
    return [];
  }
}), _descriptor12 = _applyDecoratedDescriptor(_class$3.prototype, "_isParentDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer17() {
    return true;
  }
}), _descriptor13 = _applyDecoratedDescriptor(_class$3.prototype, "_parentTransformCache", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer18() {
    return null;
  }
}), _class$3);
var Entity = function(_EngineObject) {
  _inheritsLoose(Entity2, _EngineObject);
  Entity2.findByName = function findByName(name) {
    var entitys = Entity2._entitys;
    var elements = entitys._elements;
    for (var i = entitys.length - 1; i >= 0; i--) {
      var _entity = elements[i];
      if (_entity.name === name) {
        return _entity;
      }
    }
    return null;
  };
  Entity2.findByPath = function findByPath(scene, path) {
    return scene.findEntityByPath(path);
  };
  Entity2._findChildByName = function _findChildByName(root, name) {
    var children = root._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    return null;
  };
  Entity2._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
    entity._scene = scene;
    var children = entity._children;
    for (var i = entity.childCount - 1; i >= 0; i--) {
      this._traverseSetOwnerScene(children[i], scene);
    }
  };
  function Entity2(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.layer = Layer.Layer0;
    _this.transform = void 0;
    _this._isActiveInHierarchy = false;
    _this._components = [];
    _this._children = [];
    _this._scene = void 0;
    _this._isRoot = false;
    _this._isActive = true;
    _this._parent = null;
    _this._activeChangedComponents = void 0;
    _this._invModelMatrix = new Matrix();
    _this._inverseWorldMatFlag = void 0;
    Entity2._entitys.add(_assertThisInitialized(_this));
    _this.name = name;
    _this.transform = _this.addComponent(Transform);
    _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
    return _this;
  }
  var _proto = Entity2.prototype;
  _proto.addComponent = function addComponent(type) {
    ComponentsDependencies._addCheck(this, type);
    var component = new type(this);
    this._components.push(component);
    if (this._isActiveInHierarchy) {
      component._setActive(true);
    }
    return component;
  };
  _proto.getComponent = function getComponent(type) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        return component;
      }
    }
  };
  _proto.getComponents = function getComponents(type, results) {
    results.length = 0;
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    return results;
  };
  _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
    results.length = 0;
    this._getComponentsInChildren(type, results);
    return results;
  };
  _proto.addChild = function addChild(child) {
    child.parent = this;
  };
  _proto.removeChild = function removeChild(child) {
    child.parent = null;
  };
  _proto.getChild = function getChild(index) {
    return this._children[index];
  };
  _proto.findByName = function findByName(name) {
    var children = this._children;
    var child = Entity2._findChildByName(this, name);
    if (child)
      return child;
    for (var i = children.length - 1; i >= 0; i--) {
      var _child = children[i];
      var grandson = _child.findByName(name);
      if (grandson) {
        return grandson;
      }
    }
    return null;
  };
  _proto.findByPath = function findByPath(path) {
    var splits = path.split("/");
    var entity = this;
    for (var i = 0, length = splits.length; i < length; ++i) {
      var split = splits[i];
      if (split) {
        entity = Entity2._findChildByName(entity, split);
        if (!entity) {
          return null;
        }
      }
    }
    return entity;
  };
  _proto.createChild = function createChild(name) {
    var child = new Entity2(this.engine, name);
    child.layer = this.layer;
    child.parent = this;
    return child;
  };
  _proto.clearChildren = function clearChildren() {
    var children = this._children;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      child._parent = null;
      child._isActiveInHierarchy && child._processInActive();
      Entity2._traverseSetOwnerScene(child, null);
    }
    children.length = 0;
  };
  _proto.clone = function clone2() {
    var cloneEntity = new Entity2(this._engine, this.name);
    cloneEntity._isActive = this._isActive;
    cloneEntity.transform.localMatrix = this.transform.localMatrix;
    var children = this._children;
    for (var i = 0, len = this._children.length; i < len; i++) {
      var child = children[i];
      cloneEntity.addChild(child.clone());
    }
    var components = this._components;
    for (var _i = 0, n = components.length; _i < n; _i++) {
      var sourceComp = components[_i];
      if (!(sourceComp instanceof Transform)) {
        var targetComp = cloneEntity.addComponent(sourceComp.constructor);
        ComponentCloner.cloneComponent(sourceComp, targetComp);
      }
    }
    return cloneEntity;
  };
  _proto.destroy = function destroy() {
    var abilityArray = this._components;
    for (var i = abilityArray.length - 1; i >= 0; i--) {
      abilityArray[i].destroy();
    }
    this._components.length = 0;
    var children = this._children;
    for (var _i2 = children.length - 1; _i2 >= 0; _i2--) {
      children[_i2].destroy();
    }
    this._children.length = 0;
    if (this._parent != null) {
      var parentChildren = this._parent._children;
      parentChildren.splice(parentChildren.indexOf(this), 1);
    }
    this._parent = null;
    Entity2._entitys.delete(this);
  };
  _proto._removeComponent = function _removeComponent(component) {
    ComponentsDependencies._removeCheck(this, component.constructor);
    var components = this._components;
    components.splice(components.indexOf(component), 1);
  };
  _proto._removeFromParent = function _removeFromParent() {
    var oldParent = this._parent;
    if (oldParent != null) {
      var oldParentChildren = oldParent._children;
      oldParentChildren.splice(oldParentChildren.indexOf(this), 1);
      this._parent = null;
    }
    return oldParent;
  };
  _proto._processActive = function _processActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(true);
  };
  _proto._processInActive = function _processInActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setInActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(false);
  };
  _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
    for (var i = this._components.length - 1; i >= 0; i--) {
      var component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    for (var _i3 = this._children.length - 1; _i3 >= 0; _i3--) {
      this._children[_i3]._getComponentsInChildren(type, results);
    }
  };
  _proto._setActiveComponents = function _setActiveComponents(isActive) {
    var activeChangedComponents = this._activeChangedComponents;
    for (var i = 0, length = activeChangedComponents.length; i < length; ++i) {
      activeChangedComponents[i]._setActive(isActive);
    }
    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
    this._activeChangedComponents = null;
  };
  _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = true;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }
    var children = this._children;
    for (var _i4 = children.length - 1; _i4 >= 0; _i4--) {
      var child = children[_i4];
      child.isActive && child._setActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = false;
    var components = this._components;
    for (var i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }
    var children = this._children;
    for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
      var child = children[_i5];
      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
    }
  };
  _proto._setTransformDirty = function _setTransformDirty() {
    if (this.transform) {
      this.transform._parentChange();
    } else {
      for (var i = 0, len = this._children.length; i < len; i++) {
        this._children[i]._setTransformDirty();
      }
    }
  };
  _proto.getInvModelMatrix = function getInvModelMatrix() {
    if (this._inverseWorldMatFlag.flag) {
      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
      this._inverseWorldMatFlag.flag = false;
    }
    return this._invModelMatrix;
  };
  _createClass(Entity2, [{
    key: "isActive",
    get: function get4() {
      return this._isActive;
    },
    set: function set4(value) {
      if (value !== this._isActive) {
        this._isActive = value;
        if (value) {
          var parent = this._parent;
          if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
            this._processActive();
          }
        } else {
          if (this._isActiveInHierarchy) {
            this._processInActive();
          }
        }
      }
    }
  }, {
    key: "isActiveInHierarchy",
    get: function get4() {
      return this._isActiveInHierarchy;
    }
  }, {
    key: "parent",
    get: function get4() {
      return this._parent;
    },
    set: function set4(entity) {
      if (entity !== this._parent) {
        var oldParent = this._removeFromParent();
        var newParent = this._parent = entity;
        if (newParent) {
          newParent._children.push(this);
          var parentScene = newParent._scene;
          if (this._scene !== parentScene) {
            Entity2._traverseSetOwnerScene(this, parentScene);
          }
          if (newParent._isActiveInHierarchy) {
            !this._isActiveInHierarchy && this._isActive && this._processActive();
          } else {
            this._isActiveInHierarchy && this._processInActive();
          }
        } else {
          this._isActiveInHierarchy && this._processInActive();
          if (oldParent) {
            Entity2._traverseSetOwnerScene(this, null);
          }
        }
        this._setTransformDirty();
      }
    }
  }, {
    key: "children",
    get: function get4() {
      return this._children;
    }
  }, {
    key: "childCount",
    get: function get4() {
      return this._children.length;
    }
  }, {
    key: "scene",
    get: function get4() {
      return this._scene;
    }
  }, {
    key: "engine",
    get: function get4() {
      return this._engine;
    }
  }, {
    key: "position",
    get: function get4() {
      return this.transform.position;
    },
    set: function set4(val) {
      this.transform.position = val;
    }
  }, {
    key: "worldPosition",
    get: function get4() {
      return this.transform.worldPosition;
    },
    set: function set4(val) {
      this.transform.worldPosition = val;
    }
  }, {
    key: "rotation",
    get: function get4() {
      return this.transform.rotationQuaternion;
    },
    set: function set4(val) {
      this.transform.rotationQuaternion = val;
    }
  }, {
    key: "scale",
    get: function get4() {
      return this.transform.scale;
    },
    set: function set4(val) {
      this.transform.scale = val;
    }
  }]);
  return Entity2;
}(EngineObject);
Entity._entitys = new DisorderedArray();
var FeatureManager = function() {
  function FeatureManager2() {
    this._features = [];
    this._objects = [];
  }
  var _proto = FeatureManager2.prototype;
  _proto.registerFeature = function registerFeature(IFeature) {
    var featureArray = this._features;
    for (var i = 0, len = featureArray.length; i < len; i++) {
      if (featureArray[i] === IFeature) {
        return;
      }
    }
    featureArray.push(IFeature);
    var objectArray = this._objects;
    for (var _i = 0, _len = objectArray.length; _i < _len; _i++) {
      objectArray[_i].features.push(new IFeature());
    }
  };
  _proto.addObject = function addObject(obj) {
    obj.features = [];
    for (var i = 0, len = this._features.length; i < len; i++) {
      var _engine;
      obj.features.push(new this._features[i]((_engine = obj.engine) != null ? _engine : obj));
    }
    this._objects.push(obj);
  };
  _proto.callFeatureMethod = function callFeatureMethod(obj, method, args) {
    var features = obj.features;
    var count = features.length;
    for (var i = 0; i < count; i++) {
      var feature = features[i];
      if (feature[method]) {
        feature[method].apply(feature, args);
      }
    }
  };
  _proto.findFeature = function findFeature(obj, IFeature) {
    var features = obj.features;
    var count = features.length;
    for (var i = 0; i < count; i++) {
      var feature = features[i];
      if (feature.constructor === IFeature) {
        return feature;
      }
    }
    return void 0;
  };
  return FeatureManager2;
}();
var RenderElement = function() {
  function RenderElement2() {
    this.component = void 0;
    this.primitive = void 0;
    this.subPrimitive = void 0;
    this.material = void 0;
  }
  RenderElement2.getFromPool = function getFromPool() {
    var index = RenderElement2._elementPoolIndex, pool = RenderElement2._elementPool;
    RenderElement2._elementPoolIndex++;
    if (pool.length === index) {
      var element = new RenderElement2();
      pool.push(element);
      return element;
    } else {
      return pool[index];
    }
  };
  RenderElement2._restPool = function _restPool() {
    RenderElement2._elementPoolIndex = 0;
  };
  var _proto = RenderElement2.prototype;
  _proto.setValue = function setValue(component, primitive, subPrimitive, material) {
    this.component = component;
    this.primitive = primitive;
    this.subPrimitive = subPrimitive;
    this.material = material;
  };
  return RenderElement2;
}();
RenderElement._elementPoolIndex = 0;
RenderElement._elementPool = [];
var SceneFeature = function() {
  function SceneFeature2() {
  }
  var _proto = SceneFeature2.prototype;
  _proto.preUpdate = function preUpdate(scene) {
  };
  _proto.postUpdate = function postUpdate(scene) {
  };
  _proto.preRender = function preRender(scene, camera) {
  };
  _proto.postRender = function postRender(scene, camera) {
  };
  _proto.destroy = function destroy(scene) {
  };
  return SceneFeature2;
}();
var BlendFactor;
(function(BlendFactor2) {
  BlendFactor2[BlendFactor2["Zero"] = 0] = "Zero";
  BlendFactor2[BlendFactor2["One"] = 1] = "One";
  BlendFactor2[BlendFactor2["SourceColor"] = 2] = "SourceColor";
  BlendFactor2[BlendFactor2["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
  BlendFactor2[BlendFactor2["DestinationColor"] = 4] = "DestinationColor";
  BlendFactor2[BlendFactor2["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
  BlendFactor2[BlendFactor2["SourceAlpha"] = 6] = "SourceAlpha";
  BlendFactor2[BlendFactor2["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
  BlendFactor2[BlendFactor2["DestinationAlpha"] = 8] = "DestinationAlpha";
  BlendFactor2[BlendFactor2["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
  BlendFactor2[BlendFactor2["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
  BlendFactor2[BlendFactor2["BlendColor"] = 11] = "BlendColor";
  BlendFactor2[BlendFactor2["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
})(BlendFactor || (BlendFactor = {}));
var BlendOperation;
(function(BlendOperation2) {
  BlendOperation2[BlendOperation2["Add"] = 0] = "Add";
  BlendOperation2[BlendOperation2["Subtract"] = 1] = "Subtract";
  BlendOperation2[BlendOperation2["ReverseSubtract"] = 2] = "ReverseSubtract";
  BlendOperation2[BlendOperation2["Min"] = 3] = "Min";
  BlendOperation2[BlendOperation2["Max"] = 4] = "Max";
})(BlendOperation || (BlendOperation = {}));
var ColorWriteMask;
(function(ColorWriteMask2) {
  ColorWriteMask2[ColorWriteMask2["None"] = 0] = "None";
  ColorWriteMask2[ColorWriteMask2["Red"] = 1] = "Red";
  ColorWriteMask2[ColorWriteMask2["Green"] = 2] = "Green";
  ColorWriteMask2[ColorWriteMask2["Blue"] = 4] = "Blue";
  ColorWriteMask2[ColorWriteMask2["Alpha"] = 8] = "Alpha";
  ColorWriteMask2[ColorWriteMask2["All"] = 15] = "All";
})(ColorWriteMask || (ColorWriteMask = {}));
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2[CompareFunction2["Never"] = 0] = "Never";
  CompareFunction2[CompareFunction2["Less"] = 1] = "Less";
  CompareFunction2[CompareFunction2["Equal"] = 2] = "Equal";
  CompareFunction2[CompareFunction2["LessEqual"] = 3] = "LessEqual";
  CompareFunction2[CompareFunction2["Greater"] = 4] = "Greater";
  CompareFunction2[CompareFunction2["NotEqual"] = 5] = "NotEqual";
  CompareFunction2[CompareFunction2["GreaterEqual"] = 6] = "GreaterEqual";
  CompareFunction2[CompareFunction2["Always"] = 7] = "Always";
})(CompareFunction || (CompareFunction = {}));
var CullMode;
(function(CullMode2) {
  CullMode2[CullMode2["Off"] = 0] = "Off";
  CullMode2[CullMode2["Front"] = 1] = "Front";
  CullMode2[CullMode2["Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));
var StencilOperation;
(function(StencilOperation2) {
  StencilOperation2[StencilOperation2["Keep"] = 0] = "Keep";
  StencilOperation2[StencilOperation2["Zero"] = 1] = "Zero";
  StencilOperation2[StencilOperation2["Replace"] = 2] = "Replace";
  StencilOperation2[StencilOperation2["IncrementSaturate"] = 3] = "IncrementSaturate";
  StencilOperation2[StencilOperation2["DecrementSaturate"] = 4] = "DecrementSaturate";
  StencilOperation2[StencilOperation2["Invert"] = 5] = "Invert";
  StencilOperation2[StencilOperation2["IncrementWrap"] = 6] = "IncrementWrap";
  StencilOperation2[StencilOperation2["DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOperation || (StencilOperation = {}));
var RenderQueueType;
(function(RenderQueueType2) {
  RenderQueueType2[RenderQueueType2["Opaque"] = 1e3] = "Opaque";
  RenderQueueType2[RenderQueueType2["AlphaTest"] = 2e3] = "AlphaTest";
  RenderQueueType2[RenderQueueType2["Transparent"] = 3e3] = "Transparent";
})(RenderQueueType || (RenderQueueType = {}));
var RenderQueue = function() {
  function RenderQueue2() {
    this.items = [];
  }
  var _proto = RenderQueue2.prototype;
  _proto.pushPrimitive = function pushPrimitive(element) {
    this.items.push(element);
  };
  _proto.sort = function sort(cameraPosition) {
    var _this = this;
    this.items.sort(function(a, b) {
      var aIsPrimitive = _this._isPrimitive(a);
      var bIsPrimitive = _this._isPrimitive(b);
      if (aIsPrimitive && bIsPrimitive) {
        var aElement = a;
        var bElement = b;
        var aRenderQueue = aElement.material.renderQueueType;
        var bRenderQueue = bElement.material.renderQueueType;
        if (aRenderQueue > bRenderQueue) {
          return 1;
        }
        if (aRenderQueue < bRenderQueue) {
          return -1;
        }
        if (aRenderQueue >= RenderQueueType.Transparent && bRenderQueue >= RenderQueueType.Transparent) {
          var aDistance = Vector3.distanceSquared(aElement.component.entity.transform.worldPosition, cameraPosition);
          var bDistance = Vector3.distanceSquared(bElement.component.entity.transform.worldPosition, cameraPosition);
          return bDistance - aDistance;
        }
        return aElement.material.shader.name.localeCompare(bElement.material.shader.name);
      } else if (aIsPrimitive && !bIsPrimitive) {
        return -1;
      } else if (!aIsPrimitive && bIsPrimitive) {
        return 1;
      }
    });
  };
  _proto.pushSprite = function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    var element = {
      component,
      positionQuad,
      uvRect,
      tintColor,
      texture,
      renderMode,
      camera
    };
    this.items.push(element);
  };
  _proto.render = function render(camera, replaceMaterial, mask) {
    var items = this.items;
    if (items.length === 0) {
      return;
    }
    var spriteMaterial = camera._renderPipeline._defaultSpriteMaterial;
    var engine = camera.engine, scene = camera.scene;
    var renderCount = engine._renderCount;
    var rhi = engine._hardwareRenderer;
    var sceneData = scene.shaderData;
    var cameraData = camera.shaderData;
    for (var i = 0, n = items.length; i < n; i++) {
      var item = items[i];
      var renderPassFlag = item.component.entity.layer;
      if (!(renderPassFlag & mask)) {
        continue;
      }
      if (this._isPrimitive(item)) {
        rhi.flushSprite(engine, spriteMaterial);
        var compileMacros = RenderQueue2.compileMacros;
        var element = item;
        var renderer = element.component;
        var material = replaceMaterial ? replaceMaterial : element.material;
        var rendererData = renderer.shaderData;
        var materialData = material.shaderData;
        material._preRender(element);
        ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
        compileMacros.unionCollection(element.primitive._macroCollection);
        var program = material.shader._getShaderProgram(engine, compileMacros);
        if (!program.isValid) {
          continue;
        }
        var switchProgram = program.bind();
        var switchRenderCount = renderCount !== program._uploadRenderCount;
        if (switchRenderCount) {
          program.groupingOtherUniformBlock();
          program.uploadAll(program.sceneUniformBlock, sceneData);
          program.uploadAll(program.cameraUniformBlock, cameraData);
          program.uploadAll(program.rendererUniformBlock, rendererData);
          program.uploadAll(program.materialUniformBlock, materialData);
          program._uploadCamera = camera;
          program._uploadRenderer = renderer;
          program._uploadMaterial = material;
          program._uploadRenderCount = renderCount;
        } else {
          if (program._uploadCamera !== camera) {
            program.uploadUniforms(program.cameraUniformBlock, cameraData);
            program._uploadCamera = camera;
          }
          if (program._uploadRenderer !== renderer) {
            program.uploadUniforms(program.rendererUniformBlock, rendererData);
            program._uploadRenderer = renderer;
          }
          if (program._uploadMaterial !== material) {
            program.uploadUniforms(program.materialUniformBlock, materialData);
            program._uploadMaterial = material;
          }
          if (switchProgram) {
            program.uploadTextures(program.sceneUniformBlock, sceneData);
            program.uploadTextures(program.cameraUniformBlock, cameraData);
            program.uploadTextures(program.rendererUniformBlock, rendererData);
            program.uploadTextures(program.materialUniformBlock, materialData);
          }
        }
        material.renderState._apply(camera.engine);
        rhi.drawPrimitive(element.primitive, element.subPrimitive, program);
      } else {
        var spirteElement = item;
        rhi.drawSprite(spriteMaterial, spirteElement.positionQuad, spirteElement.uvRect, spirteElement.tintColor, spirteElement.texture, spirteElement.renderMode, spirteElement.camera);
      }
    }
    rhi.flushSprite(engine, spriteMaterial);
  };
  _proto.clear = function clear() {
    this.items.length = 0;
  };
  _proto._isPrimitive = function _isPrimitive(item) {
    return !!item.primitive;
  };
  return RenderQueue2;
}();
RenderQueue.compileMacros = new ShaderMacroCollection();
var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n#include <noise_common>\n";
var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef O3_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef O3_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef O3_USE_JOINT_TEXTURE\nuniform sampler2D u_jointSampler;uniform float u_jointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/u_jointCount;float hf=0.5/u_jointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 u_jointMatrix[O3_JOINTS_NUM];\n#endif\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\nuniform mat4 u_localMat;uniform mat4 u_modelMat;uniform mat4 u_viewMat;uniform mat4 u_projMat;uniform mat4 u_MVMat;uniform mat4 u_MVPMat;uniform mat4 u_normalMat;uniform vec3 u_cameraPos;\n#ifndef OMIT_NORMAL\n#ifdef O3_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef O3_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n";
var common_frag = "#define GLSLIFY 1\nuniform O3_VERTEX_PRECISION mat4 u_localMat;uniform O3_VERTEX_PRECISION mat4 u_modelMat;uniform O3_VERTEX_PRECISION mat4 u_viewMat;uniform O3_VERTEX_PRECISION mat4 u_projMat;uniform O3_VERTEX_PRECISION mat4 u_MVMat;uniform O3_VERTEX_PRECISION mat4 u_MVPMat;uniform O3_VERTEX_PRECISION mat4 u_normalMat;uniform O3_VERTEX_PRECISION vec3 u_cameraPos;";
var color_share = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n";
var normal_share = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\nvarying mat3 v_TBN;\n#else\nvarying vec3 v_normal;\n#endif\n#endif\n";
var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;";
var worldpos_share = "#define GLSLIFY 1\n#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\nvarying vec3 v_pos;\n#endif\n";
var shadow_share = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\nuniform mat4 u_viewMatFromLight;uniform mat4 u_projMatFromLight;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];uniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n#endif\n";
var fog_share = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nvarying vec3 v_fogDepth;uniform O3_VERTEX_PRECISION vec3 u_fogColor;\n#ifdef O3_FOG_EXP2\nuniform O3_VERTEX_PRECISION float u_fogDensity;\n#else\nuniform O3_VERTEX_PRECISION float u_fogNear;uniform O3_VERTEX_PRECISION float u_fogFar;\n#endif\n#endif\n";
var begin_normal_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n";
var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);";
var morph_target_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_MORPH\nuniform float u_morphWeights[O3_MORPH_NUM];\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position0;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal0;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent0;\n#endif\n#if O3_MORPH_NUM > 1\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position1;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal1;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent1;\n#endif\n#endif\n#if O3_MORPH_NUM > 2\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position2;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal2;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent2;\n#endif\n#endif\n#if O3_MORPH_NUM > 3\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position3;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal3;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent3;\n#endif\n#endif\n#if O3_MORPH_NUM > 4\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position4;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal4;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent4;\n#endif\n#endif\n#if O3_MORPH_NUM > 5\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position5;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal5;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent5;\n#endif\n#endif\n#if O3_MORPH_NUM > 6\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position6;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal6;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent6;\n#endif\n#endif\n#if O3_MORPH_NUM > 7\n#ifdef O3_MORPH_POSITION\nattribute vec3 a_position7;\n#endif\n#ifdef O3_MORPH_NORMAL\nattribute vec3 a_normal7;\n#endif\n#ifdef O3_MORPH_TANGENT\nattribute vec3 a_tangent7;\n#endif\n#endif\n#endif\n";
var position_vert = "#define GLSLIFY 1\n#ifndef O3_GENERATE_SHADOW_MAP\ngl_Position=u_MVPMat*position;\n#endif\n";
var color_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n";
var normal_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\nvec3 normalW=normalize(mat3(u_normalMat)*normal.xyz);vec3 tangentW=normalize(mat3(u_normalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#else\nv_normal=normalize(mat3(u_normalMat)*normal);\n#endif\n#endif\n";
var skinning_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_SKIN\n#ifdef O3_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(u_jointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(u_jointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(u_jointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(u_jointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*u_jointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*u_jointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*u_jointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*u_jointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(O3_HAS_NORMAL) && !defined(OMIT_NORMAL)\nnormal=vec4(skinMatrix*vec4(normal,0.0)).xyz;\n#if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\ntangent.xyz=vec4(skinMatrix*vec4(tangent.xyz,0.0)).xyz;\n#endif\n#endif\n#endif\n";
var uv_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n";
var worldpos_vert = "#define GLSLIFY 1\n#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\nvec4 temp_pos=u_modelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n";
var shadow_vert = "#define GLSLIFY 1\n#ifdef O3_GENERATE_SHADOW_MAP\ngl_Position=u_projMatFromLight*u_viewMatFromLight*u_modelMat*position;\n#endif\n#ifdef O3_SHADOW_MAP_COUNT\nfor(int i=0;i<O3_SHADOW_MAP_COUNT;i++){v_PositionFromLight[i]=u_projMatFromLight[i]*u_viewMatFromLight[i]*u_modelMat*vec4(POSITION,1.0);}\n#endif\n";
var morph_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_MORPH\n#if defined( O3_MORPH_POSITION )\nposition.xyz+=u_morphWeights[0]*a_position0;\n#if O3_MORPH_NUM > 1\nposition.xyz+=u_morphWeights[1]*a_position1;\n#endif\n#if O3_MORPH_NUM > 2\nposition.xyz+=u_morphWeights[2]*a_position2;\n#endif\n#if O3_MORPH_NUM > 3\nposition.xyz+=u_morphWeights[3]*a_position3;\n#endif\n#if O3_MORPH_NUM > 4\nposition.xyz+=u_morphWeights[4]*a_position4;\n#endif\n#if O3_MORPH_NUM > 5\nposition.xyz+=u_morphWeights[5]*a_position5;\n#endif\n#if O3_MORPH_NUM > 6\nposition.xyz+=u_morphWeights[6]*a_position6;\n#endif\n#if O3_MORPH_NUM > 7\nposition.xyz+=u_morphWeights[7]*a_position7;\n#endif\n#endif\n#if defined( O3_HAS_NORMAL ) && defined( O3_MORPH_NORMAL )\nnormal.xyz+=u_morphWeights[0]*a_normal0;\n#if O3_MORPH_NUM > 1\nnormal.xyz+=u_morphWeights[1]*a_normal1;\n#endif\n#if O3_MORPH_NUM > 2\nnormal.xyz+=u_morphWeights[2]*a_normal2;\n#endif\n#if O3_MORPH_NUM > 3\nnormal.xyz+=u_morphWeights[3]*a_normal3;\n#endif\n#if O3_MORPH_NUM > 4\nnormal.xyz+=u_morphWeights[4]*a_normal4;\n#endif\n#if O3_MORPH_NUM > 5\nnormal.xyz+=u_morphWeights[5]*a_normal5;\n#endif\n#if O3_MORPH_NUM > 6\nnormal.xyz+=u_morphWeights[6]*a_normal6;\n#endif\n#if O3_MORPH_NUM > 7\nnormal.xyz+=u_morphWeights[7]*a_normal7;\n#endif\n#endif\n#if defined( O3_HAS_TANGENT ) && defined( O3_MORPH_TANGENT ) && defined( O3_HAS_NORMALMAP )\ntangent.xyz+=u_morphWeights[0]*a_tangent0;\n#if O3_MORPH_NUM > 1\ntangent.xyz+=u_morphWeights[1]*a_tangent1;\n#endif\n#if O3_MORPH_NUM > 2\ntangent.xyz+=u_morphWeights[2]*a_tangent2;\n#endif\n#if O3_MORPH_NUM > 3\ntangent.xyz+=u_morphWeights[3]*a_tangent3;\n#endif\n#if O3_MORPH_NUM > 4\ntangent.xyz+=u_morphWeights[4]*a_tangent4;\n#endif\n#if O3_MORPH_NUM > 5\ntangent.xyz+=u_morphWeights[5]*a_tangent5;\n#endif\n#if O3_MORPH_NUM > 6\ntangent.xyz+=u_morphWeights[6]*a_tangent6;\n#endif\n#if O3_MORPH_NUM > 7\ntangent.xyz+=u_morphWeights[7]*a_tangent7;\n#endif\n#endif\n#endif\n";
var fog_vert = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nv_fogDepth=(u_MVMat*position).xyz;\n#endif\n";
var ambient_light_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_AMBIENT_LIGHT\nuniform vec3 u_ambientLightColor;\n#endif\n";
var direct_light_frag = "#define GLSLIFY 1\n#ifdef O3_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform vec3 u_directLightColor[O3_DIRECT_LIGHT_COUNT];uniform vec3 u_directLightDirection[O3_DIRECT_LIGHT_COUNT];\n#endif\n";
var point_light_frag = "#define GLSLIFY 1\n#ifdef O3_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;float decay;};uniform vec3 u_pointLightColor[O3_POINT_LIGHT_COUNT];uniform vec3 u_pointLightPosition[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDistance[O3_POINT_LIGHT_COUNT];uniform float u_pointLightDecay[O3_POINT_LIGHT_COUNT];\n#endif\n";
var spot_light_frag = "#define GLSLIFY 1\n#ifdef O3_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float decay;float angle;float penumbra;float penumbraCos;float coneCos;};uniform vec3 u_spotLightColor[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightPosition[O3_SPOT_LIGHT_COUNT];uniform vec3 u_spotLightDirection[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDistance[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightDecay[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightAngle[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbra[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightPenumbraCos[O3_SPOT_LIGHT_COUNT];uniform float u_spotLightConeCos[O3_SPOT_LIGHT_COUNT];\n#endif\n";
var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 u_emissiveColor;uniform vec4 u_diffuseColor;uniform vec4 u_specularColor;uniform float u_shininess;\n#ifdef O3_EMISSIVE_TEXTURE\nuniform sampler2D u_emissiveTexture;\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\nuniform sampler2D u_diffuseTexture;\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nuniform sampler2D u_specularTexture;\n#endif\n";
var fog_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_FOG\nfloat fogDepth=length(v_fogDepth);\n#ifdef O3_FOG_EXP2\nfloat fogFactor=whiteCompliment(exp2(-u_fogDensity*u_fogDensity*fogDepth*fogDepth*LOG2));\n#else\nfloat fogFactor=smoothstep(u_fogNear,u_fogFar,fogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,u_fogColor,fogFactor);\n#endif\n";
var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=u_emissiveColor;vec4 diffuse=u_diffuseColor;vec4 specular=u_specularColor;\n#ifdef O3_HAS_AMBIENT_LIGHT\nambient+=vec4(u_ambientLightColor,1.0);\n#endif\n#ifdef O3_EMISSIVE_TEXTURE\nemission*=texture2D(u_emissiveTexture,v_uv);\n#endif\n#ifdef O3_DIFFUSE_TEXTURE\ndiffuse*=texture2D(u_diffuseTexture,v_uv);\n#endif\n#ifdef O3_SPECULAR_TEXTURE\nspecular*=texture2D(u_specularTexture,v_uv);\n#endif\n";
var begin_normal_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\n#if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\nvec3 N=normalize(v_TBN[2]);\n#else\nvec3 N=normalize(v_normal);\n#endif\n#endif\n";
var begin_viewdir_frag = "#define GLSLIFY 1\n#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP )\nvec3 V=normalize(u_cameraPos-v_pos);\n#endif\n";
var mobile_blinnphong_frag = "#define GLSLIFY 1\n#ifdef O3_HAS_NORMAL\nN*=float(gl_FrontFacing)*2.0-1.0;\n#else\nvec3 N=vec3(0,0,1);\n#endif\nvec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nDirectLight lgt;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){lgt.color=u_directLightColor[i];lgt.direction=u_directLightDirection[i];float d=max(dot(N,-lgt.direction),0.0);lightDiffuse+=lgt.color*d;vec3 halfDir=normalize(V-lgt.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess);lightSpecular+=lgt.color*s;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nPointLight lgt;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){lgt.color=u_pointLightColor[i];lgt.position=u_pointLightPosition[i];lgt.distance=u_pointLightDistance[i];lgt.decay=u_pointLightDecay[i];vec3 direction=v_pos-lgt.position;float dist=length(direction);direction/=dist;float decay=pow(max(0.0,1.0-dist/lgt.distance),2.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=lgt.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay;lightSpecular+=lgt.color*s;}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nSpotLight lgt;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){lgt.color=u_spotLightColor[i];lgt.position=u_spotLightPosition[i];lgt.direction=u_spotLightDirection[i];lgt.distance=u_spotLightDistance[i];lgt.decay=u_spotLightDecay[i];lgt.angle=u_spotLightAngle[i];lgt.penumbra=u_spotLightPenumbra[i];vec3 direction=v_pos-lgt.position;float angle=acos(dot(normalize(direction),normalize(lgt.direction)));float dist=length(direction);direction/=dist;float decay=pow(max(0.0,1.0-dist/lgt.distance),2.0);float hasLight=step(angle,lgt.angle);float hasPenumbra=step(lgt.angle,angle)*step(angle,lgt.angle*(1.0+lgt.penumbra));float penumbra=hasPenumbra*(1.0-(angle-lgt.angle)/(lgt.angle*lgt.penumbra));float d=max(dot(N,-direction),0.0)*decay*(penumbra+hasLight);lightDiffuse+=lgt.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),u_shininess)*decay*(penumbra+hasLight);lightSpecular+=lgt.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);";
var mobile_lambert_frag = "#define GLSLIFY 1\nvec3 totalLight=vec3(0.0,0.0,0.0);\n#ifdef O3_DIRECT_LIGHT_COUNT\nfor(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){vec3 lightColor=u_directLightColor[i];lightColor*=max(dot(N,-u_directLightDirection[i]),0.0);totalLight+=lightColor;}\n#endif\ndiffuse*=vec4(totalLight,1.0);";
var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n";
var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}";
var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}";
var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}";
var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}";
var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";
var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}";
var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}";
var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}";
var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";
var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}";
var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}";
var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}";
var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";
var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}";
var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";
var perturbation_share = "#define GLSLIFY 1\n#ifdef HAS_PERTURBATIONMAP\nuniform sampler2D u_perturbationSampler;uniform float u_perturbationUOffset;uniform float u_perturbationVOffset;\n#endif\n";
var perturbation_frag = "#define GLSLIFY 1\n#ifdef HAS_PERTURBATIONMAP\nvec2 getScreenUv(){return gl_FragCoord.xy/u_resolution;}vec4 screenColor=texture2D(u_perturbationSampler,getScreenUv()+normalize(u_viewMat*vec4(normal,1.)).xy*vec2(u_perturbationUOffset,u_perturbationVOffset));gl_FragColor=mix(screenColor,gl_FragColor,gl_FragColor.a);\n#endif\n";
var refraction_share = "#define GLSLIFY 1\n#ifdef HAS_REFRACTIONMAP\nuniform sampler2D u_refractionSampler;uniform mat4 u_PTMMatrix;uniform float u_refractionDepth;\n#endif\n";
var refraction_frag = "#define GLSLIFY 1\n#ifdef HAS_REFRACTIONMAP\nvec4 refractionColor=vec4(0.);vec3 refractDir=normalize(refract(-geometry.viewDir,geometry.normal,u_refractionRatio));vec3 newPos=v_pos+refractDir*u_refractionDepth;vec4 projectionPos=u_PTMMatrix*u_projMat*u_viewMat*vec4(newPos,1.0);vec2 projectionUv=projectionPos.xy/projectionPos.w;refractionColor=texture2D(u_refractionSampler,projectionUv);gl_FragColor=mix(refractionColor,gl_FragColor,gl_FragColor.a);\n#endif\n";
var clipPlane_vert_define = "#define GLSLIFY 1\n#ifdef O3_CLIPPLANE_NUM\nuniform vec4 u_clipPlanes[O3_CLIPPLANE_NUM];varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";
var clipPlane_vert = "#define GLSLIFY 1\n#ifdef O3_CLIPPLANE_NUM\nfor(int i=0;i<O3_CLIPPLANE_NUM;i++){v_clipDistances[i]=dot(vec4(v_pos,1.0),u_clipPlanes[i]);}\n#endif\n";
var clipPlane_frag_define = "#define GLSLIFY 1\n#ifdef O3_CLIPPLANE_NUM\nvarying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";
var clipPlane_frag = "#define GLSLIFY 1\n#ifdef O3_CLIPPLANE_NUM\nfor(int i=0;i<O3_CLIPPLANE_NUM;i++){if(v_clipDistances[i]<0.0){discard;}}\n#endif\n";
var gamma_frag = "#define GLSLIFY 1\n#ifdef GAMMA\nfloat gamma=2.2;gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(1.0/gamma));\n#endif\n";
var pbr_common_frag_define = "#define GLSLIFY 1\n#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n#ifndef RECIPROCAL_PI\n#define RECIPROCAL_PI 0.31830988618\n#endif\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n#define RE_Direct RE_Direct_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )\n";
var pbr_util_frag_define = "#define GLSLIFY 1\nvec4 SRGBtoLINEAR(vec4 srgbIn){\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\nvec3 linOut=pow(srgbIn.xyz,vec3(2.2));\n#else\nvec3 bLess=step(vec3(0.04045),srgbIn.xyz);vec3 linOut=mix(srgbIn.xyz/vec3(12.92),pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)),bLess);\n#endif\nreturn vec4(linOut,srgbIn.w);;\n#else\nreturn srgbIn;\n#endif\n}float pow2(const in float x){return x*x;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}float punctualLightIntensityToIrradianceFactor(const in float lightDistance,const in float cutoffDistance,const in float decayExponent){if(decayExponent>0.0){\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\nfloat distanceFalloff=1.0/max(pow(lightDistance,decayExponent),0.01);float maxDistanceCutoffFactor=pow2(saturate(1.0-pow4(lightDistance/cutoffDistance)));return distanceFalloff*maxDistanceCutoffFactor;\n#else\nreturn pow(saturate(-lightDistance/cutoffDistance+1.0),decayExponent);\n#endif\n}return 1.0;}vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}float GGXRoughnessToBlinnExponent(const in float ggxRoughness){return(2.0/pow2(ggxRoughness+0.0001)-2.0);}float computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}float getLuminance(vec3 color){return dot(color,vec3(0.2126,0.7152,0.0722));}";
var pbr_envmap_light_frag_define = "#define GLSLIFY 1\n#ifdef O3_HAS_ENVMAP_LIGHT\nstruct EnvMapLight{vec3 diffuse;vec3 specular;float mipMapLevel;float diffuseIntensity;float specularIntensity;mat4 transformMatrix;};uniform EnvMapLight u_envMapLight;\n#ifdef O3_USE_DIFFUSE_ENV\nuniform samplerCube u_env_diffuseSampler;\n#endif\n#ifdef O3_USE_SPECULAR_ENV\nuniform samplerCube u_env_specularSampler;\n#endif\n#endif\n";
var pbr_base_frag_define = "#define GLSLIFY 1\nuniform float u_alphaCutoff;uniform vec4 u_baseColorFactor;uniform float u_metal;uniform float u_roughness;uniform vec3 u_specularFactor;uniform float u_glossinessFactor;uniform float u_envMapIntensity;uniform float u_refractionRatio;uniform vec2 u_resolution;uniform float u_normalScale;uniform float u_occlusionStrength;";
var pbr_texture_frag_define = "#define GLSLIFY 1\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_baseColorSampler;\n#endif\n#ifdef O3_HAS_NORMALMAP\nuniform sampler2D u_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_emissiveSampler;uniform vec3 u_emissiveFactor;\n#endif\n#ifdef HAS_METALMAP\nuniform sampler2D u_metallicSampler;\n#endif\n#ifdef HAS_ROUGHNESSMAP\nuniform sampler2D u_roughnessSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_metallicRoughnessSampler;\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nuniform sampler2D u_specularGlossinessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_occlusionSampler;\n#endif\n#ifdef HAS_OPACITYMAP\nuniform sampler2D u_opacitySampler;\n#endif\n#ifdef HAS_REFLECTIONMAP\nuniform samplerCube u_reflectionSampler;\n#endif\n";
var pbr_runtime_frag_define = "#define GLSLIFY 1\nstruct IncidentLight{vec3 color;vec3 direction;bool visible;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;};struct PhysicalMaterial{vec3 diffuseColor;float specularRoughness;vec3 specularColor;};";
var pbr_normal_frag_define = "#define GLSLIFY 1\nvec3 getNormal(){\n#ifdef O3_HAS_NORMALMAP\n#ifndef O3_HAS_TANGENT\n#ifdef HAS_DERIVATIVES\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 tex_dx=dFdx(vec3(v_uv,0.0));vec3 tex_dy=dFdy(vec3(v_uv,0.0));vec3 t=(tex_dy.t*pos_dx-tex_dx.t*pos_dy)/(tex_dx.s*tex_dy.t-tex_dy.s*tex_dx.t);\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=normalize(cross(pos_dx,pos_dy));\n#endif\nt=normalize(t-ng*dot(ng,t));vec3 b=normalize(cross(ng,t));mat3 tbn=mat3(t,b,ng);\n#else\n#ifdef O3_HAS_NORMAL\nvec3 ng=normalize(v_normal);\n#else\nvec3 ng=vec3(0.0,0.0,1.0);\n#endif\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),ng);\n#endif\n#else\nmat3 tbn=v_TBN;\n#endif\nvec3 n=texture2D(u_normalSampler,v_uv).rgb;n=normalize(tbn*((2.0*n-1.0)*vec3(u_normalScale,u_normalScale,1.0)));\n#else\n#ifdef O3_HAS_NORMAL\nvec3 n=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 n=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 n=vec3(0.0,0.0,1.0);\n#endif\n#endif\nn*=float(gl_FrontFacing)*2.0-1.0;return n;}";
var pbr_brdf_cook_torrance_frag_define = "#define GLSLIFY 1\nvec3 F_Schlick(const in vec3 specularColor,const in float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight,const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentLight.direction+geometry.viewDir);float dotNL=saturate(dot(geometry.normal,incidentLight.direction));float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNH=saturate(dot(geometry.normal,halfDir));float dotLH=saturate(dot(incidentLight.direction,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}";
var pbr_direct_irradiance_frag_define = "#define GLSLIFY 1\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_Specular_GGX(directLight,geometry,material.specularColor,material.specularRoughness);reflectedLight.directDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_DIRECT_LIGHT_COUNT\nvoid getDirectionalDirectLightIrradiance(const in DirectLight directionalLight,const in GeometricContext geometry,out IncidentLight directLight){directLight.color=directionalLight.color;directLight.direction=-directionalLight.direction;directLight.visible=true;}\n#endif\n#ifdef O3_POINT_LIGHT_COUNT\nvoid getPointDirectLightIrradiance(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=pointLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);directLight.color=pointLight.color;directLight.color*=punctualLightIntensityToIrradianceFactor(lightDistance,pointLight.distance,pointLight.decay);directLight.visible=(directLight.color!=vec3(0.0));}\n#endif\n#ifdef O3_SPOT_LIGHT_COUNT\nvoid getSpotDirectLightIrradiance(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight directLight){vec3 lVector=spotLight.position-geometry.position;directLight.direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(directLight.direction,-spotLight.direction);if(angleCos>spotLight.coneCos){float spotEffect=smoothstep(spotLight.coneCos,spotLight.penumbraCos,angleCos);directLight.color=spotLight.color;directLight.color*=spotEffect*punctualLightIntensityToIrradianceFactor(lightDistance,spotLight.distance,spotLight.decay);directLight.visible=true;}else{directLight.color=vec3(0.0);directLight.visible=false;}}\n#endif\n";
var pbr_ibl_specular_frag_define = "#define GLSLIFY 1\nvec3 BRDF_Specular_GGX_Environment(const in GeometricContext geometry,const in vec3 specularColor,const in float roughness){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(const in float blinnShininessExponent,const in int maxMIPLevel){float maxMIPLevelScalar=float(maxMIPLevel);float desiredMIPLevel=maxMIPLevelScalar+0.79248-0.5*log2(pow2(blinnShininessExponent)+1.0);return clamp(desiredMIPLevel,0.0,maxMIPLevelScalar);}\n#ifdef O3_HAS_ENVMAP_LIGHT\nvec3 getLightProbeIndirectRadiance(const in GeometricContext geometry,const in float blinnShininessExponent,const in int maxMIPLevel){\n#if !defined(O3_USE_SPECULAR_ENV) && !defined(HAS_REFLECTIONMAP)\nreturn u_envMapLight.specular*u_envMapLight.specularIntensity*u_envMapIntensity;\n#else\n#ifdef ENVMAPMODE_REFRACT\nvec3 reflectVec=refract(-geometry.viewDir,geometry.normal,u_refractionRatio);\n#else\nvec3 reflectVec=reflect(-geometry.viewDir,geometry.normal);\n#endif\nreflectVec=mat3(u_envMapLight.transformMatrix)*reflectVec;float specularMIPLevel=getSpecularMIPLevel(blinnShininessExponent,maxMIPLevel);\n#ifdef HAS_TEX_LOD\n#ifdef HAS_REFLECTIONMAP\nvec4 envMapColor=textureCubeLodEXT(u_reflectionSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCubeLodEXT(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\n#else\n#ifdef HAS_REFLECTIONMAP\nvec4 envMapColor=textureCube(u_reflectionSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(u_env_specularSampler,reflectVec,specularMIPLevel);\n#endif\n#endif\nenvMapColor.rgb=SRGBtoLINEAR(envMapColor*u_envMapLight.specularIntensity*u_envMapIntensity).rgb;return envMapColor.rgb;\n#endif\n}\n#endif\nvoid RE_IndirectSpecular_Physical(const in vec3 radiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNV=saturate(dot(geometry.normal,geometry.viewDir));float dotNL=dotNV;reflectedLight.indirectSpecular+=radiance*BRDF_Specular_GGX_Environment(geometry,material.specularColor,material.specularRoughness);}";
var pbr_ibl_diffuse_frag_define = "#define GLSLIFY 1\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef O3_HAS_AMBIENT_LIGHT\nvec3 getAmbientLightIrradiance(const in vec3 ambientLightColor){vec3 irradiance=ambientLightColor;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nirradiance*=PI;\n#endif\nreturn irradiance;}\n#endif\n";
var pbr_begin_frag = "#define GLSLIFY 1\nvec3 normal=getNormal();vec4 diffuseColor=u_baseColorFactor;vec3 totalEmissiveRadiance=vec3(0.0);float metalnessFactor=u_metal;float roughnessFactor=u_roughness;vec3 specularFactor=u_specularFactor;float glossinessFactor=u_glossinessFactor;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));PhysicalMaterial material;GeometricContext geometry;IncidentLight directLight;\n#ifdef HAS_BASECOLORMAP\nvec4 baseMapColor=texture2D(u_baseColorSampler,v_uv);baseMapColor=SRGBtoLINEAR(baseMapColor);diffuseColor*=baseMapColor;\n#endif\n#ifdef O3_HAS_VERTEXCOLOR\ndiffuseColor.rgb*=v_color.rgb;\n#ifdef O3_HAS_VERTEXALPHA\ndiffuseColor.a*=v_color.a;\n#endif\n#endif\n#ifdef ALPHA_CUTOFF\nif(diffuseColor.a<u_alphaCutoff){discard;}\n#endif\n#if defined(ALPHA_BLEND) && defined(HAS_OPACITYMAP)\n#ifdef GETOPACITYFROMRGB\ndiffuseColor.a*=getLuminance(texture2D(u_opacitySampler,v_uv).rgb);\n#else\ndiffuseColor.a*=texture2D(u_opacitySampler,v_uv).a;\n#endif\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nvec4 metalRoughMapColor=texture2D(u_metallicRoughnessSampler,v_uv);metalnessFactor*=metalRoughMapColor.b;roughnessFactor*=metalRoughMapColor.g;\n#else\n#ifdef HAS_METALMAP\nvec4 metalMapColor=texture2D(u_metallicSampler,v_uv);metalnessFactor*=metalMapColor.b;\n#endif\n#ifdef HAS_ROUGHNESSMAP\nvec4 roughMapColor=texture2D(u_roughnessSampler,v_uv);roughnessFactor*=roughMapColor.g;\n#endif\n#endif\n#ifdef HAS_SPECULARGLOSSINESSMAP\nvec4 specularGlossinessColor=texture2D(u_specularGlossinessSampler,v_uv);specularFactor*=specularGlossinessColor.rgb;glossinessFactor*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);material.specularRoughness=clamp(roughnessFactor,0.04,1.0);material.specularColor=mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT),diffuseColor.rgb,metalnessFactor);\n#else\nfloat specularStrength=max(max(specularFactor.r,specularFactor.g),specularFactor.b);material.diffuseColor=diffuseColor.rgb*(1.0-specularStrength);material.specularRoughness=clamp(1.0-glossinessFactor,0.04,1.0);material.specularColor=specularFactor;\n#endif\ngeometry.position=v_pos;geometry.normal=normal;geometry.viewDir=normalize(u_cameraPos-v_pos);";
var pbr_direct_irradiance_frag = "#define GLSLIFY 1\n#if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\nDirectLight directionalLight;for(int i=0;i<O3_DIRECT_LIGHT_COUNT;i++){directionalLight.color=u_directLightColor[i];directionalLight.direction=u_directLightDirection[i];getDirectionalDirectLightIrradiance(directionalLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\nPointLight pointLight;for(int i=0;i<O3_POINT_LIGHT_COUNT;i++){pointLight.color=u_pointLightColor[i];pointLight.position=u_pointLightPosition[i];pointLight.distance=u_pointLightDistance[i];pointLight.decay=u_pointLightDecay[i];getPointDirectLightIrradiance(pointLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n#if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\nSpotLight spotLight;for(int i=0;i<O3_SPOT_LIGHT_COUNT;i++){spotLight.color=u_spotLightColor[i];spotLight.position=u_spotLightPosition[i];spotLight.direction=u_spotLightDirection[i];spotLight.distance=u_spotLightDistance[i];spotLight.decay=u_spotLightDecay[i];spotLight.angle=u_spotLightAngle[i];spotLight.penumbra=u_spotLightPenumbra[i];spotLight.penumbraCos=u_spotLightPenumbraCos[i];spotLight.coneCos=u_spotLightConeCos[i];getSpotDirectLightIrradiance(spotLight,geometry,directLight);RE_Direct(directLight,geometry,material,reflectedLight);}\n#endif\n";
var pbr_ibl_diffuse_frag = "#define GLSLIFY 1\n#if defined(RE_IndirectDiffuse)\nvec3 irradiance=vec3(0);\n#if defined(O3_HAS_AMBIENT_LIGHT)\nirradiance+=getAmbientLightIrradiance(u_ambientLightColor);\n#endif\n#if defined(O3_HAS_ENVMAP_LIGHT)\n#ifdef O3_USE_DIFFUSE_ENV\nvec3 lightMapIrradiance=textureCube(u_env_diffuseSampler,geometry.normal).rgb*u_envMapLight.diffuseIntensity;\n#else\nvec3 lightMapIrradiance=u_envMapLight.diffuse*u_envMapLight.diffuseIntensity;\n#endif\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance*=PI;\n#endif\nirradiance+=lightMapIrradiance;\n#endif\nRE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);\n#endif\n";
var pbr_ibl_specular_frag = "#define GLSLIFY 1\n#if defined( RE_IndirectSpecular )\nvec3 radiance=vec3(0.0);\n#endif\n#if defined( O3_HAS_ENVMAP_LIGHT ) && defined( RE_IndirectSpecular )\nradiance+=getLightProbeIndirectRadiance(geometry,Material_BlinnShininessExponent(material),int(u_envMapLight.mipMapLevel));\n#endif\n#if defined( RE_IndirectSpecular )\nRE_IndirectSpecular(radiance,geometry,material,reflectedLight);\n#endif\n";
var pbr_end_frag = "#define GLSLIFY 1\n#ifdef HAS_OCCLUSIONMAP\nfloat ambientOcclusion=(texture2D(u_occlusionSampler,v_uv).r-1.0)*u_occlusionStrength+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(O3_USE_SPECULAR_ENV)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.specularRoughness);\n#endif\n#endif\n#ifdef HAS_EMISSIVEMAP\nvec4 emissiveMapColor=texture2D(u_emissiveSampler,v_uv);emissiveMapColor=SRGBtoLINEAR(emissiveMapColor);totalEmissiveRadiance+=u_emissiveFactor*emissiveMapColor.rgb;\n#endif\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;gl_FragColor=vec4(outgoingLight,diffuseColor.a);";
var PBRShaderLib = {
  pbr_common_frag_define,
  pbr_util_frag_define,
  pbr_envmap_light_frag_define,
  pbr_base_frag_define,
  pbr_texture_frag_define,
  pbr_runtime_frag_define,
  pbr_normal_frag_define,
  pbr_brdf_cook_torrance_frag_define,
  pbr_direct_irradiance_frag_define,
  pbr_ibl_specular_frag_define,
  pbr_ibl_diffuse_frag_define,
  pbr_begin_frag,
  pbr_direct_irradiance_frag,
  pbr_ibl_diffuse_frag,
  pbr_ibl_specular_frag,
  pbr_end_frag
};
var oit_frag = "#define GLSLIFY 1\n#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\nif(gl_FragCoord.z>texture2D(u_depthSampler,gl_FragCoord.xy/u_resolution).r){discard;}vec4 oitColor=gl_FragColor;gl_FragData[0]=vec4(oitColor.rgb*oitColor.a,oitColor.a);gl_FragData[1]=vec4(1)/255.0;\n#endif\n";
var oit_frag_define = "#define GLSLIFY 1\n#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\nuniform sampler2D u_depthSampler;float weight(float z,float a){return a*clamp(3e3*pow(1.0-z,3.0),1e-2,3e3);}\n#endif\n";
var ShaderLib = _objectSpread2({
  common,
  common_vert,
  common_frag,
  color_share,
  normal_share,
  uv_share,
  worldpos_share,
  shadow_share,
  fog_share,
  begin_normal_vert,
  begin_position_vert,
  morph_target_vert,
  position_vert,
  color_vert,
  normal_vert,
  skinning_vert,
  uv_vert,
  worldpos_vert,
  shadow_vert,
  morph_vert,
  fog_vert,
  ambient_light_frag,
  direct_light_frag,
  point_light_frag,
  spot_light_frag,
  mobile_material_frag,
  fog_frag,
  begin_mobile_frag,
  begin_normal_frag,
  begin_viewdir_frag,
  mobile_blinnphong_frag,
  mobile_lambert_frag,
  noise_common,
  noise_cellular_2D,
  noise_cellular_2x2,
  noise_cellular_2x2x2,
  noise_cellular_3D,
  noise_cellular,
  noise_perlin_2D,
  noise_perlin_3D,
  noise_perlin_4D,
  noise_perlin,
  noise_psrd_2D,
  noise_simplex_2D,
  noise_simplex_3D_grad,
  noise_simplex_3D,
  noise_simplex_4D,
  noise_simplex,
  perturbation_share,
  perturbation_frag,
  refraction_share,
  refraction_frag,
  clipPlane_vert_define,
  clipPlane_vert,
  clipPlane_frag_define,
  clipPlane_frag,
  gamma_frag,
  oit_frag,
  oit_frag_define
}, PBRShaderLib);
function InjectShaderSlices(obj) {
  _extends(ShaderLib, obj);
}
var ShaderFactory = function() {
  function ShaderFactory2() {
  }
  ShaderFactory2.parseVersion = function parseVersion(version2) {
    if (version2 === void 0) {
      version2 = "100";
    }
    return "#version " + version2 + "\n";
  };
  ShaderFactory2.parsePrecision = function parsePrecision(vertP, fragP, compileVert) {
    var downgrade = "mediump";
    return "\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n          precision " + (compileVert ? vertP : fragP) + " float;\n          precision " + (compileVert ? vertP : fragP) + " int;\n\n          #define O3_VERTEX_PRECISION " + vertP + "\n          #define O3_FRAGMENT_PRECISION " + fragP + "\n        #else\n          precision " + downgrade + " float;\n          precision " + downgrade + " int;\n\n          #define O3_VERTEX_PRECISION " + downgrade + "\n          #define O3_FRAGMENT_PRECISION " + downgrade + "\n        #endif\n      ";
  };
  ShaderFactory2.parseShaderName = function parseShaderName(name) {
    return "#define O3_SHADER_NAME " + name + "\n";
  };
  ShaderFactory2.parseAttributeMacros = function parseAttributeMacros(macros) {
    return "#define O3_ATTRIBUTE_MACROS_START\n" + macros.map(function(m) {
      return "#define " + m + "\n";
    }).join("") + "#define O3_ATTRIBUTE_MACROS_END\n";
  };
  ShaderFactory2.parseCustomMacros = function parseCustomMacros(macros) {
    return "#define O3_CUSTOM_MACROS_START\n" + macros.map(function(m) {
      return "#define " + m + "\n";
    }).join("") + "#define O3_CUSTOM_MACROS_END\n";
  };
  ShaderFactory2.parseShader = function parseShader(src) {
    return ShaderFactory2.parseIncludes(src);
  };
  ShaderFactory2.parseIncludes = function parseIncludes(src) {
    var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
    function replace(match, slice) {
      var replace2 = ShaderLib[slice];
      if (replace2 === void 0) {
        Logger.error('Shader slice "' + match.trim() + '" not founded.');
        return "";
      }
      return ShaderFactory2.parseIncludes(replace2);
    }
    return src.replace(regex, replace);
  };
  ShaderFactory2.InjectShaderSlices = function InjectShaderSlices$1(slices) {
    InjectShaderSlices(slices);
  };
  ShaderFactory2.parseExtension = function parseExtension(extensions) {
    return "#define O3_EXTENSION_START\n" + extensions.map(function(e) {
      return "#extension " + e + " : enable\n";
    }).join("") + "#define O3_EXTENSION_END\n";
  };
  ShaderFactory2.convertTo300 = function convertTo300(shader, isFrag) {
    shader = shader.replace(/\battribute\b/g, "in");
    shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
    shader = shader.replace(/\btexture(2D|Cube)\s*\(/g, "texture(");
    shader = shader.replace(/\btexture(2D|Cube)LodEXT\s*\(/g, "textureLod(");
    if (isFrag) {
      var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
      if (isMRT) {
        shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        var result = shader.match(/\bgl_FragData\[.+?\]/g);
        shader = this.replaceMRTShader(shader, result);
      } else {
        shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
        shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
      }
    }
    return shader;
  };
  ShaderFactory2.getMaxDrawBuffers = function getMaxDrawBuffers(shader) {
    var mrtIndexSet = new Set();
    var result = shader.match(/\bgl_FragData\[.+?\]/g) || [];
    for (var i = 0; i < result.length; i++) {
      var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    return mrtIndexSet.size;
  };
  ShaderFactory2.compatible = function compatible(fragmentShader) {
    var hasFragData = /\bgl_FragData\[.+?\]/g.test(fragmentShader);
    if (hasFragData) {
      fragmentShader = fragmentShader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
    }
    return fragmentShader;
  };
  ShaderFactory2.replaceMRTShader = function replaceMRTShader(shader, result) {
    var declaration = "";
    var mrtIndexSet = new Set();
    for (var i = 0; i < result.length; i++) {
      var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    mrtIndexSet.forEach(function(index) {
      declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
    });
    declaration += "void main(";
    shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
    shader = shader.replace(/void\s+?main\s*\(/g, declaration);
    return shader;
  };
  return ShaderFactory2;
}();
var ShaderMacro = function ShaderMacro2(name, index, value) {
  this.name = void 0;
  this._index = void 0;
  this._value = void 0;
  this.name = name;
  this._index = index;
  this._value = value;
};
var ShaderDataGroup;
(function(ShaderDataGroup2) {
  ShaderDataGroup2[ShaderDataGroup2["Scene"] = 0] = "Scene";
  ShaderDataGroup2[ShaderDataGroup2["Camera"] = 1] = "Camera";
  ShaderDataGroup2[ShaderDataGroup2["Renderer"] = 2] = "Renderer";
  ShaderDataGroup2[ShaderDataGroup2["Material"] = 3] = "Material";
})(ShaderDataGroup || (ShaderDataGroup = {}));
var ShaderUniform = function() {
  function ShaderUniform2(engine) {
    this.name = void 0;
    this.propertyId = void 0;
    this.location = void 0;
    this.textureIndex = void 0;
    this.applyFunc = void 0;
    this.cacheValue = void 0;
    this._rhi = void 0;
    this._gl = void 0;
    var rhi = engine._hardwareRenderer;
    this._rhi = rhi;
    this._gl = rhi.gl;
  }
  var _proto = ShaderUniform2.prototype;
  _proto.upload1f = function upload1f(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1f(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1fv = function upload1fv(shaderUniform, value) {
    this._gl.uniform1fv(shaderUniform.location, value);
  };
  _proto.upload2f = function upload2f(shaderUniform, value) {
    var cacheVaue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheVaue.x !== value.r || cacheVaue.y !== value.g) {
        this._gl.uniform2f(shaderUniform.location, value.r, value.g);
        cacheVaue.x = value.r;
        cacheVaue.y = value.g;
      }
    } else {
      if (cacheVaue.x !== value.x || cacheVaue.y !== value.y) {
        this._gl.uniform2f(shaderUniform.location, value.x, value.y);
        cacheVaue.x = value.x;
        cacheVaue.y = value.y;
      }
    }
  };
  _proto.upload2fv = function upload2fv(shaderUniform, value) {
    this._gl.uniform2fv(shaderUniform.location, value);
  };
  _proto.upload3f = function upload3f(shaderUniform, value) {
    var cacheVaue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheVaue.x !== value.r || cacheVaue.y !== value.g || cacheVaue.z !== value.b) {
        this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
        cacheVaue.x = value.r;
        cacheVaue.y = value.g;
        cacheVaue.z = value.b;
      }
    } else {
      if (cacheVaue.x !== value.x || cacheVaue.y !== value.y || cacheVaue.z !== value.z) {
        this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
        cacheVaue.x = value.x;
        cacheVaue.y = value.y;
        cacheVaue.z = value.z;
      }
    }
  };
  _proto.upload3fv = function upload3fv(shaderUniform, value) {
    this._gl.uniform3fv(shaderUniform.location, value);
  };
  _proto.upload4f = function upload4f(shaderUniform, value) {
    var cacheVaue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheVaue.x !== value.r || cacheVaue.y !== value.g || cacheVaue.z !== value.b || cacheVaue.w !== value.a) {
        this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
        cacheVaue.x = value.r;
        cacheVaue.y = value.g;
        cacheVaue.z = value.b;
        cacheVaue.w = value.a;
      }
    } else {
      if (cacheVaue.x !== value.x || cacheVaue.y !== value.y || cacheVaue.z !== value.z || cacheVaue.w !== value.w) {
        this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheVaue.x = value.x;
        cacheVaue.y = value.y;
        cacheVaue.z = value.z;
        cacheVaue.w = value.w;
      }
    }
  };
  _proto.upload4fv = function upload4fv(shaderUniform, value) {
    this._gl.uniform4fv(shaderUniform.location, value);
  };
  _proto.upload1i = function upload1i(shaderUniform, value) {
    if (this.cacheValue !== value) {
      this._gl.uniform1i(shaderUniform.location, value);
      this.cacheValue = value;
    }
  };
  _proto.upload1iv = function upload1iv(shaderUniform, value) {
    this._gl.uniform1iv(shaderUniform.location, value);
  };
  _proto.upload2i = function upload2i(shaderUniform, value) {
    var cacheVaue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheVaue.x !== value.r || cacheVaue.y !== value.g) {
        this._gl.uniform2i(shaderUniform.location, value.r, value.g);
        cacheVaue.x = value.r;
        cacheVaue.y = value.g;
      }
    } else {
      if (cacheVaue.x !== value.x || cacheVaue.y !== value.y) {
        this._gl.uniform2i(shaderUniform.location, value.x, value.y);
        cacheVaue.x = value.x;
        cacheVaue.y = value.y;
      }
    }
  };
  _proto.upload2iv = function upload2iv(shaderUniform, value) {
    this._gl.uniform2iv(shaderUniform.location, value);
  };
  _proto.upload3i = function upload3i(shaderUniform, value) {
    var cacheVaue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheVaue.x !== value.r || cacheVaue.y !== value.g || cacheVaue.z !== value.b) {
        this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
        cacheVaue.x = value.r;
        cacheVaue.y = value.g;
        cacheVaue.z = value.b;
      }
    } else {
      if (cacheVaue.x !== value.x || cacheVaue.y !== value.y || cacheVaue.z !== value.z) {
        this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
        cacheVaue.x = value.x;
        cacheVaue.y = value.y;
        cacheVaue.z = value.z;
      }
    }
  };
  _proto.upload3iv = function upload3iv(shaderUniform, value) {
    this._gl.uniform3iv(shaderUniform.location, value);
  };
  _proto.upload4i = function upload4i(shaderUniform, value) {
    var cacheVaue = this.cacheValue;
    if (value.r !== void 0) {
      if (cacheVaue.x !== value.r || cacheVaue.y !== value.g || cacheVaue.z !== value.b || cacheVaue.w !== value.a) {
        this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
        cacheVaue.x = value.r;
        cacheVaue.y = value.g;
        cacheVaue.z = value.b;
        cacheVaue.w = value.a;
      }
    } else {
      if (cacheVaue.x !== value.x || cacheVaue.y !== value.y || cacheVaue.z !== value.z || cacheVaue.w !== value.w) {
        this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
        cacheVaue.x = value.x;
        cacheVaue.y = value.y;
        cacheVaue.z = value.z;
        cacheVaue.w = value.w;
      }
    }
  };
  _proto.upload4iv = function upload4iv(shaderUniform, value) {
    this._gl.uniform4iv(shaderUniform.location, value);
  };
  _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
  };
  _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
    this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
  };
  _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
    var rhi = this._rhi;
    rhi.activeTexture(shaderUniform.textureIndex);
    rhi.bindTexture(value._target, value._glTexture);
  };
  _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
    var rhi = this._rhi;
    var textureIndices = shaderUniform.textureIndex;
    for (var i = 0; i < value.length; i++) {
      var texture = value[i];
      rhi.activeTexture(textureIndices[i]);
      rhi.bindTexture(texture._target, texture._glTexture);
    }
  };
  return ShaderUniform2;
}();
var ShaderUniformBlock = function ShaderUniformBlock2() {
  this.constUniforms = [];
  this.textureUniforms = [];
};
var ShaderProgram = function() {
  ShaderProgram2._addLineNum = function _addLineNum(str) {
    var lines = str.split("\n");
    var limitLength = (lines.length + 1).toString().length + 6;
    var prefix;
    return lines.map(function(line, index) {
      prefix = "0:" + (index + 1);
      if (prefix.length >= limitLength)
        return prefix.substring(0, limitLength) + line;
      for (var i = 0; i < limitLength - prefix.length; i++) {
        prefix += " ";
      }
      return prefix + line;
    }).join("\n");
  };
  function ShaderProgram2(engine, vertexSource, fragmentSource) {
    this.id = void 0;
    this.sceneUniformBlock = new ShaderUniformBlock();
    this.cameraUniformBlock = new ShaderUniformBlock();
    this.rendererUniformBlock = new ShaderUniformBlock();
    this.materialUniformBlock = new ShaderUniformBlock();
    this.otherUniformBlock = new ShaderUniformBlock();
    this._uploadRenderCount = -1;
    this._uploadCamera = void 0;
    this._uploadRenderer = void 0;
    this._uploadMaterial = void 0;
    this.attributeLocation = Object.create(null);
    this._isValid = void 0;
    this._engine = void 0;
    this._gl = void 0;
    this._vertexShader = void 0;
    this._fragmentShader = void 0;
    this._glProgram = void 0;
    this._activeTextureUint = 0;
    this._engine = engine;
    this._gl = engine._hardwareRenderer.gl;
    this._glProgram = this._createProgram(vertexSource, fragmentSource);
    if (this._glProgram) {
      this._isValid = true;
      this._recordLocation();
    } else {
      this._isValid = false;
    }
    this.id = ShaderProgram2._counter++;
  }
  var _proto = ShaderProgram2.prototype;
  _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
    this.uploadUniforms(uniformBlock, shaderData);
    this.uploadTextures(uniformBlock, shaderData);
  };
  _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
    var properties = shaderData._properties;
    var constUniforms = uniformBlock.constUniforms;
    for (var i = 0, n = constUniforms.length; i < n; i++) {
      var uniform = constUniforms[i];
      var data = properties[uniform.propertyId];
      data != null && uniform.applyFunc(uniform, data);
    }
  };
  _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
    var properties = shaderData._properties;
    var textureUniforms = uniformBlock.textureUniforms;
    if (textureUniforms) {
      for (var i = 0, n = textureUniforms.length; i < n; i++) {
        var uniform = textureUniforms[i];
        uniform.applyFunc(uniform, properties[uniform.propertyId]);
      }
    }
  };
  _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
    var _this$otherUniformBlo = this.otherUniformBlock, constUniforms = _this$otherUniformBlo.constUniforms, textureUniforms = _this$otherUniformBlo.textureUniforms;
    constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
    textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
  };
  _proto.bind = function bind() {
    var rhi = this._engine._hardwareRenderer;
    if (rhi._currentBind !== this) {
      this._gl.useProgram(this._glProgram);
      rhi._currentBind = this;
      return true;
    } else {
      return false;
    }
  };
  _proto.destroy = function destroy() {
    var gl = this._gl;
    this._vertexShader && gl.deleteShader(this._vertexShader);
    this._fragmentShader && gl.deleteShader(this._fragmentShader);
    this._glProgram && gl.deleteProgram(this._glProgram);
  };
  _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(unifroms, isTexture) {
    for (var i = unifroms.length - 1; i >= 0; i--) {
      var uniform = unifroms[i];
      var group = Shader._getShaderPropertyGroup(uniform.name);
      if (group !== void 0) {
        unifroms.splice(unifroms.indexOf(uniform), 1);
        this._groupingUniform(uniform, group, isTexture);
      }
    }
  };
  _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
    switch (group) {
      case ShaderDataGroup.Scene:
        if (isTexture) {
          this.sceneUniformBlock.textureUniforms.push(uniform);
        } else {
          this.sceneUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Camera:
        if (isTexture) {
          this.cameraUniformBlock.textureUniforms.push(uniform);
        } else {
          this.cameraUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Renderer:
        if (isTexture) {
          this.rendererUniformBlock.textureUniforms.push(uniform);
        } else {
          this.rendererUniformBlock.constUniforms.push(uniform);
        }
        break;
      case ShaderDataGroup.Material:
        if (isTexture) {
          this.materialUniformBlock.textureUniforms.push(uniform);
        } else {
          this.materialUniformBlock.constUniforms.push(uniform);
        }
        break;
      default:
        if (isTexture) {
          this.otherUniformBlock.textureUniforms.push(uniform);
        } else {
          this.otherUniformBlock.constUniforms.push(uniform);
        }
    }
  };
  _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
    var gl = this._gl;
    var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
    if (!vertexShader) {
      return null;
    }
    var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (!fragmentShader) {
      return null;
    }
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.validateProgram(program);
    if (gl.isContextLost()) {
      Logger.error("Contex lost while linking program.");
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      return null;
    }
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      Logger.error("Could not link WebGL program. \n" + gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    this._vertexShader = vertexShader;
    this._fragmentShader = fragmentShader;
    return program;
  };
  _proto._createShader = function _createShader(shaderType, shaderSource) {
    var gl = this._gl;
    var shader = gl.createShader(shaderType);
    if (!shader) {
      Logger.error("Context lost while create shader.");
      return null;
    }
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);
    if (gl.isContextLost()) {
      Logger.error("Context lost while compiling shader.");
      gl.deleteShader(shader);
      return null;
    }
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      Logger.error("Could not compile WebGL shader.\n" + gl.getShaderInfoLog(shader), ShaderProgram2._addLineNum(shaderSource));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  };
  _proto._recordLocation = function _recordLocation() {
    var _this = this;
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = this._getUniformInfos();
    var attributeInfos = this._getAttributeInfos();
    uniformInfos.forEach(function(_ref) {
      var name = _ref.name, size = _ref.size, type = _ref.type;
      var shaderUniform = new ShaderUniform(_this._engine);
      var isArray = false;
      var isTexture = false;
      if (name.indexOf("[0]") > 0) {
        name = name.substr(0, name.length - 3);
        isArray = true;
      }
      var group = Shader._getShaderPropertyGroup(name);
      var location = gl.getUniformLocation(program, name);
      shaderUniform.name = name;
      shaderUniform.propertyId = Shader.getPropertyByName(name)._uniqueId;
      shaderUniform.location = location;
      switch (type) {
        case gl.FLOAT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1f;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.FLOAT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2f;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.FLOAT_VEC3:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload3fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload3f;
            shaderUniform.cacheValue = new Vector3(0, 0, 0);
          }
          break;
        case gl.FLOAT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4fv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4f;
            shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
          }
          break;
        case gl.BOOL:
        case gl.INT:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload1iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload1i;
            shaderUniform.cacheValue = 0;
          }
          break;
        case gl.BOOL_VEC2:
        case gl.INT_VEC2:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload2iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload2i;
            shaderUniform.cacheValue = new Vector2(0, 0);
          }
          break;
        case gl.BOOL_VEC3:
        case gl.INT_VEC3:
          shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
          shaderUniform.cacheValue = new Vector3(0, 0, 0);
          break;
        case gl.BOOL_VEC4:
        case gl.INT_VEC4:
          if (isArray) {
            shaderUniform.applyFunc = shaderUniform.upload4iv;
          } else {
            shaderUniform.applyFunc = shaderUniform.upload4i;
            shaderUniform.cacheValue = new Vector4(0, 0, 0);
          }
          break;
        case gl.FLOAT_MAT4:
          shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
          break;
        case gl.SAMPLER_2D:
        case gl.SAMPLER_CUBE:
          isTexture = true;
          if (isArray) {
            var textureIndices = new Int32Array(size);
            var glTextureIndices = new Array(size);
            for (var i = 0; i < size; i++) {
              textureIndices[i] = _this._activeTextureUint;
              glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
            }
            shaderUniform.textureIndex = glTextureIndices;
            shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
            _this.bind();
            gl.uniform1iv(location, textureIndices);
          } else {
            var textureIndex = gl.TEXTURE0 + _this._activeTextureUint;
            shaderUniform.textureIndex = textureIndex;
            shaderUniform.applyFunc = shaderUniform.uploadTexture;
            _this.bind();
            gl.uniform1i(location, _this._activeTextureUint++);
          }
          break;
      }
      _this._groupingUniform(shaderUniform, group, isTexture);
    });
    attributeInfos.forEach(function(_ref2) {
      var name = _ref2.name;
      _this.attributeLocation[name] = gl.getAttribLocation(program, name);
    });
  };
  _proto._getUniformInfos = function _getUniformInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var uniformInfos = [];
    var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < uniformCount; ++i) {
      var info2 = gl.getActiveUniform(program, i);
      uniformInfos[i] = info2;
    }
    return uniformInfos;
  };
  _proto._getAttributeInfos = function _getAttributeInfos() {
    var gl = this._gl;
    var program = this._glProgram;
    var attributeInfos = [];
    var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < attributeCount; ++i) {
      var info2 = gl.getActiveAttrib(program, i);
      attributeInfos[i] = info2;
    }
    return attributeInfos;
  };
  _createClass(ShaderProgram2, [{
    key: "isValid",
    get: function get4() {
      return this._isValid;
    }
  }]);
  return ShaderProgram2;
}();
ShaderProgram._counter = 0;
var ShaderProperty = function ShaderProperty2() {
  this._uniqueId = void 0;
  this._group = void 0;
  this._uniqueId = ShaderProperty2._propertyNameCounter++;
};
ShaderProperty._propertyNameCounter = 0;
var Shader = function() {
  Shader2.create = function create(name, vertexSource, fragmentSource) {
    var shaderMap = Shader2._shaderMap;
    if (shaderMap[name]) {
      throw 'Shader named "' + name + '" already exists.';
    }
    return shaderMap[name] = new Shader2(name, vertexSource, fragmentSource);
  };
  Shader2.find = function find(name) {
    return Shader2._shaderMap[name];
  };
  Shader2.getMacroByName = function getMacroByName(name) {
    var macro = Shader2._macroMap[name];
    if (!macro) {
      var maskMap = Shader2._macroMaskMap;
      var counter = Shader2._macroCounter;
      var index = Math.floor(counter / 32);
      var bit = counter % 32;
      macro = new ShaderMacro(name, index, 1 << bit);
      Shader2._macroMap[name] = macro;
      if (index == maskMap.length) {
        maskMap.length++;
        maskMap[index] = new Array(32);
      }
      maskMap[index][bit] = name;
      Shader2._macroCounter++;
    }
    return macro;
  };
  Shader2.getPropertyByName = function getPropertyByName(name) {
    var propertyNameMap = Shader2._propertyNameMap;
    if (propertyNameMap[name] != null) {
      return propertyNameMap[name];
    } else {
      var property = new ShaderProperty();
      propertyNameMap[name] = property;
      return property;
    }
  };
  Shader2._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
    var shaderProperty = Shader2._propertyNameMap[propertyName];
    return shaderProperty === null || shaderProperty === void 0 ? void 0 : shaderProperty._group;
  };
  Shader2._getNamesByMacros = function _getNamesByMacros(macros, out) {
    var maskMap = Shader2._macroMaskMap;
    var mask = macros._mask;
    out.length = 0;
    for (var i = 0, n = macros._length; i < n; i++) {
      var subMaskMap = maskMap[i];
      var subMask = mask[i];
      var _n = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1;
      for (var j = 0; j < _n; j++) {
        if (subMask & 1 << j) {
          out.push(subMaskMap[j]);
        }
      }
    }
  };
  function Shader2(name, vertexSource, fragmentSource) {
    this.name = void 0;
    this._shaderId = 0;
    this._vertexSource = void 0;
    this._fragmentSource = void 0;
    this._shaderId = Shader2._shaderCounter++;
    this.name = name;
    this._vertexSource = vertexSource;
    this._fragmentSource = fragmentSource;
  }
  var _proto = Shader2.prototype;
  _proto.compileVariant = function compileVariant(engine, macros) {
    var compileMacros = RenderQueue.compileMacros;
    compileMacros.clear();
    for (var i = 0, n = macros.length; i < n; i++) {
      compileMacros.enable(Shader2.getMacroByName(macros[i]));
    }
    this._getShaderProgram(engine, compileMacros);
  };
  _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
    var shaderProgramPool = engine._getShaderProgramPool(this);
    var shaderProgram = shaderProgramPool.get(macroCollection);
    if (shaderProgram) {
      return shaderProgram;
    }
    var isWebGL2 = engine._hardwareRenderer.isWebGL2;
    var macroNameList = [];
    Shader2._getNamesByMacros(macroCollection, macroNameList);
    var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
    var shaderNameStr = ShaderFactory.parseShaderName(this.name || "VOID");
    var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
    var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n      #define O3_VERTEX_PRECISION highp\n      #define O3_FRAGMENT_PRECISION highp\n    #else\n      precision mediump float;\n      precision mediump int;\n      #define O3_VERTEX_PRECISION mediump\n      #define O3_FRAGMENT_PRECISION mediump\n    #endif\n    ";
    var vertexSource = ShaderFactory.parseShader(" " + versionStr + "\n        " + shaderNameStr + "\n        " + precisionStr + "\n        " + macroNameStr + "\n        " + this._vertexSource);
    var fragmentSource = ShaderFactory.parseShader(" " + versionStr + "\n        " + shaderNameStr + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader2._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + this._fragmentSource);
    if (isWebGL2) {
      vertexSource = ShaderFactory.convertTo300(vertexSource);
      fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
    }
    shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
    shaderProgramPool.cache(shaderProgram);
    return shaderProgram;
  };
  return Shader2;
}();
Shader._shaderCounter = 0;
Shader._shaderMap = Object.create(null);
Shader._propertyNameMap = Object.create(null);
Shader._macroMaskMap = [];
Shader._macroCounter = 0;
Shader._macroMap = Object.create(null);
Shader._shaderExtension = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];
var Light = function(_Component) {
  _inheritsLoose(Light2, _Component);
  function Light2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this._viewMat = void 0;
    _this._inverseViewMat = void 0;
    return _this;
  }
  var _proto = Light2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(LightFeature).attachRenderLight(this);
  };
  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(LightFeature).detachRenderLight(this);
  };
  _createClass(Light2, [{
    key: "viewMatrix",
    get: function get4() {
      if (!this._viewMat)
        this._viewMat = new Matrix();
      Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
      return this._viewMat;
    }
  }, {
    key: "inverseViewMatrix",
    get: function get4() {
      if (!this._inverseViewMat)
        this._inverseViewMat = new Matrix();
      Matrix.invert(this.viewMatrix, this._inverseViewMat);
      return this._inverseViewMat;
    }
  }]);
  return Light2;
}(Component);
Light._maxLight = 10;
var AmbientLight = function(_Light) {
  _inheritsLoose(AmbientLight2, _Light);
  function AmbientLight2(entity) {
    var _this;
    _this = _Light.call(this, entity) || this;
    _this._color = new Color(1, 1, 1, 1);
    _this._intensity = 1;
    _this._lightColor = new Color(1, 1, 1, 1);
    _this.color = _this._color;
    return _this;
  }
  _createClass(AmbientLight2, [{
    key: "color",
    get: function get4() {
      return this._color;
    },
    set: function set4(value) {
      this._color = value;
      this.scene.shaderData.setColor(AmbientLight2._colorProperty, this.lightColor);
    }
  }, {
    key: "intensity",
    get: function get4() {
      return this._intensity;
    },
    set: function set4(value) {
      this._intensity = value;
      this.scene.shaderData.setColor(AmbientLight2._colorProperty, this.lightColor);
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this._color.r * this._intensity;
      this._lightColor.g = this._color.g * this._intensity;
      this._lightColor.b = this._color.b * this._intensity;
      this._lightColor.a = this._color.a * this._intensity;
      return this._lightColor;
    }
  }]);
  return AmbientLight2;
}(Light);
AmbientLight._colorProperty = Shader.getPropertyByName("u_ambientLightColor");
var DirectLight = function(_Light) {
  _inheritsLoose(DirectLight2, _Light);
  function DirectLight2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._reverseDirection = new Vector3();
    return _this;
  }
  DirectLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = DirectLight2._combinedData;
    shaderData.setFloatArray(DirectLight2._colorProperty, data.color);
    shaderData.setFloatArray(DirectLight2._directionProperty, data.direction);
  };
  var _proto = DirectLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var lightColor = this.lightColor;
    var direction = this.direction;
    var data = DirectLight2._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
  };
  _createClass(DirectLight2, [{
    key: "direction",
    get: function get4() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }, {
    key: "reverseDirection",
    get: function get4() {
      Vector3.scale(this.direction, -1, this._reverseDirection);
      return this._reverseDirection;
    }
  }]);
  return DirectLight2;
}(Light);
DirectLight._colorProperty = Shader.getPropertyByName("u_directLightColor");
DirectLight._directionProperty = Shader.getPropertyByName("u_directLightDirection");
DirectLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight)
};
var EnvironmentMapLight = function(_Light) {
  _inheritsLoose(EnvironmentMapLight2, _Light);
  EnvironmentMapLight2._updateShaderData = function _updateShaderData(shaderData, light) {
    var transformMatrix = light.entity.transform.worldMatrix;
    shaderData.setMatrix(EnvironmentMapLight2._transformMatrixProperty, transformMatrix);
  };
  function EnvironmentMapLight2(entity) {
    var _this;
    _this = _Light.call(this, entity) || this;
    _this._diffuseTexture = void 0;
    _this._specularTexture = void 0;
    _this._diffuseColor = new Color(0.3, 0.3, 0.3, 1);
    _this._specularColor = new Color(0.5, 0.5, 0.5, 1);
    _this._diffuseIntensity = 1;
    _this._specularIntensity = 1;
    _this.diffuseColor = _this._diffuseColor;
    _this.specularColor = _this._specularColor;
    _this.diffuseIntensity = _this._diffuseIntensity;
    _this.specularIntensity = _this._specularIntensity;
    return _this;
  }
  _createClass(EnvironmentMapLight2, [{
    key: "diffuseTexture",
    get: function get4() {
      return this._diffuseTexture;
    },
    set: function set4(value) {
      this._diffuseTexture = value;
      var shaderData = this.scene.shaderData;
      if (value) {
        shaderData.setTexture(EnvironmentMapLight2._diffuseTextureProperty, value);
        shaderData.enableMacro(EnvironmentMapLight2._diffuseMacro);
      } else {
        shaderData.disableMacro(EnvironmentMapLight2._diffuseMacro);
      }
    }
  }, {
    key: "specularTexture",
    get: function get4() {
      return this._specularTexture;
    },
    set: function set4(value) {
      this._specularTexture = value;
      var shaderData = this.scene.shaderData;
      if (value) {
        shaderData.setTexture(EnvironmentMapLight2._specularTextureProperty, value);
        shaderData.setFloat(EnvironmentMapLight2._mipLevelProperty, this.specularTexture.mipmapCount);
        shaderData.enableMacro(EnvironmentMapLight2._specularMacro);
      } else {
        shaderData.disableMacro(EnvironmentMapLight2._specularMacro);
      }
    }
  }, {
    key: "diffuseColor",
    get: function get4() {
      return this._diffuseColor;
    },
    set: function set4(value) {
      this._diffuseColor = value;
      this.scene.shaderData.setColor(EnvironmentMapLight2._diffuseColorProperty, value);
    }
  }, {
    key: "specularColor",
    get: function get4() {
      return this._specularColor;
    },
    set: function set4(value) {
      this._specularColor = value;
      this.scene.shaderData.setColor(EnvironmentMapLight2._specularColorProperty, value);
    }
  }, {
    key: "diffuseIntensity",
    get: function get4() {
      return this._diffuseIntensity;
    },
    set: function set4(value) {
      this._diffuseIntensity = value;
      this.scene.shaderData.setFloat(EnvironmentMapLight2._diffuseIntensityProperty, value);
    }
  }, {
    key: "specularIntensity",
    get: function get4() {
      return this._specularIntensity;
    },
    set: function set4(value) {
      this._specularIntensity = value;
      this.scene.shaderData.setFloat(EnvironmentMapLight2._specularIntensityProperty, value);
    }
  }]);
  return EnvironmentMapLight2;
}(Light);
EnvironmentMapLight._diffuseMacro = Shader.getMacroByName("O3_USE_DIFFUSE_ENV");
EnvironmentMapLight._specularMacro = Shader.getMacroByName("O3_USE_SPECULAR_ENV");
EnvironmentMapLight._diffuseTextureProperty = Shader.getPropertyByName("u_env_diffuseSampler");
EnvironmentMapLight._specularTextureProperty = Shader.getPropertyByName("u_env_specularSampler");
EnvironmentMapLight._mipLevelProperty = Shader.getPropertyByName("u_envMapLight.mipMapLevel");
EnvironmentMapLight._diffuseColorProperty = Shader.getPropertyByName("u_envMapLight.diffuse");
EnvironmentMapLight._specularColorProperty = Shader.getPropertyByName("u_envMapLight.specular");
EnvironmentMapLight._diffuseIntensityProperty = Shader.getPropertyByName("u_envMapLight.diffuseIntensity");
EnvironmentMapLight._specularIntensityProperty = Shader.getPropertyByName("u_envMapLight.specularIntensity");
EnvironmentMapLight._transformMatrixProperty = Shader.getPropertyByName("u_envMapLight.transformMatrix");
var PointLight = function(_Light) {
  _inheritsLoose(PointLight2, _Light);
  function PointLight2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.intensity = 1;
    _this.distance = 100;
    _this.decay = 0;
    _this._lightColor = new Color(1, 1, 1, 1);
    return _this;
  }
  PointLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = PointLight2._combinedData;
    shaderData.setFloatArray(PointLight2._colorProperty, data.color);
    shaderData.setFloatArray(PointLight2._positionProperty, data.position);
    shaderData.setFloatArray(PointLight2._distanceProperty, data.distance);
    shaderData.setFloatArray(PointLight2._decayProperty, data.decay);
  };
  var _proto = PointLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var decayStart = lightIndex;
    var lightColor = this.lightColor;
    var lightPosition = this.position;
    var data = PointLight2._combinedData;
    data.color[colorStart] = lightColor.r;
    data.color[colorStart + 1] = lightColor.g;
    data.color[colorStart + 2] = lightColor.b;
    data.position[positionStart] = lightPosition.x;
    data.position[positionStart + 1] = lightPosition.y;
    data.position[positionStart + 2] = lightPosition.z;
    data.distance[distanceStart] = this.distance;
    data.decay[decayStart] = this.decay;
  };
  _createClass(PointLight2, [{
    key: "position",
    get: function get4() {
      return this.entity.transform.worldPosition;
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);
  return PointLight2;
}(Light);
PointLight._colorProperty = Shader.getPropertyByName("u_pointLightColor");
PointLight._positionProperty = Shader.getPropertyByName("u_pointLightPosition");
PointLight._distanceProperty = Shader.getPropertyByName("u_pointLightDistance");
PointLight._decayProperty = Shader.getPropertyByName("u_pointLightDecay");
PointLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight),
  decay: new Float32Array(Light._maxLight)
};
var SpotLight = function(_Light) {
  _inheritsLoose(SpotLight2, _Light);
  function SpotLight2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Light.call.apply(_Light, [this].concat(args)) || this;
    _this.color = new Color(1, 1, 1, 1);
    _this.penumbra = 0.2;
    _this.distance = 100;
    _this.intensity = 1;
    _this.decay = 0;
    _this.angle = Math.PI / 6;
    _this._forward = new Vector3();
    _this._lightColor = new Color(1, 1, 1, 1);
    _this._inverseDirection = new Vector3();
    return _this;
  }
  SpotLight2._updateShaderData = function _updateShaderData(shaderData) {
    var data = SpotLight2._combinedData;
    shaderData.setFloatArray(SpotLight2._colorProperty, data.color);
    shaderData.setFloatArray(SpotLight2._positionProperty, data.position);
    shaderData.setFloatArray(SpotLight2._directionProperty, data.direction);
    shaderData.setFloatArray(SpotLight2._distanceProperty, data.distance);
    shaderData.setFloatArray(SpotLight2._decayProperty, data.decay);
    shaderData.setFloatArray(SpotLight2._angleProperty, data.angle);
    shaderData.setFloatArray(SpotLight2._penumbraProperty, data.penumbra);
    shaderData.setFloatArray(SpotLight2._penumbraCosProperty, data.penumbraCos);
    shaderData.setFloatArray(SpotLight2._coneCosProperty, data.coneCos);
  };
  var _proto = SpotLight2.prototype;
  _proto._appendData = function _appendData(lightIndex) {
    var colorStart = lightIndex * 3;
    var positionStart = lightIndex * 3;
    var directionStart = lightIndex * 3;
    var distanceStart = lightIndex;
    var decayStart = lightIndex;
    var angleStart = lightIndex;
    var penumbraStart = lightIndex;
    var penumbraCosStart = lightIndex;
    var coneCosStart = lightIndex;
    var color = this.lightColor;
    var position = this.position;
    var direction = this.direction;
    var data = SpotLight2._combinedData;
    data.color[colorStart] = color.r;
    data.color[colorStart + 1] = color.g;
    data.color[colorStart + 2] = color.b;
    data.position[positionStart] = position.x;
    data.position[positionStart + 1] = position.y;
    data.position[positionStart + 2] = position.z;
    data.direction[directionStart] = direction.x;
    data.direction[directionStart + 1] = direction.y;
    data.direction[directionStart + 2] = direction.z;
    data.distance[distanceStart] = this.distance;
    data.decay[decayStart] = this.decay;
    data.angle[angleStart] = this.angle;
    data.penumbra[penumbraStart] = this.penumbra;
    data.penumbraCos[penumbraCosStart] = Math.cos(this.angle * (1 - this.penumbra));
    data.coneCos[coneCosStart] = Math.cos(this.angle);
  };
  _createClass(SpotLight2, [{
    key: "position",
    get: function get4() {
      return this.entity.transform.worldPosition;
    }
  }, {
    key: "direction",
    get: function get4() {
      this.entity.transform.getWorldForward(this._forward);
      return this._forward;
    }
  }, {
    key: "reverseDirection",
    get: function get4() {
      Vector3.scale(this.direction, -1, this._inverseDirection);
      return this._inverseDirection;
    }
  }, {
    key: "lightColor",
    get: function get4() {
      this._lightColor.r = this.color.r * this.intensity;
      this._lightColor.g = this.color.g * this.intensity;
      this._lightColor.b = this.color.b * this.intensity;
      this._lightColor.a = this.color.a * this.intensity;
      return this._lightColor;
    }
  }]);
  return SpotLight2;
}(Light);
SpotLight._colorProperty = Shader.getPropertyByName("u_spotLightColor");
SpotLight._positionProperty = Shader.getPropertyByName("u_spotLightPosition");
SpotLight._directionProperty = Shader.getPropertyByName("u_spotLightDirection");
SpotLight._distanceProperty = Shader.getPropertyByName("u_spotLightDistance");
SpotLight._decayProperty = Shader.getPropertyByName("u_spotLightDecay");
SpotLight._angleProperty = Shader.getPropertyByName("u_spotLightAngle");
SpotLight._penumbraProperty = Shader.getPropertyByName("u_spotLightPenumbra");
SpotLight._penumbraCosProperty = Shader.getPropertyByName("u_spotLightPenumbraCos");
SpotLight._coneCosProperty = Shader.getPropertyByName("u_spotLightConeCos");
SpotLight._combinedData = {
  color: new Float32Array(3 * Light._maxLight),
  position: new Float32Array(3 * Light._maxLight),
  direction: new Float32Array(3 * Light._maxLight),
  distance: new Float32Array(Light._maxLight),
  decay: new Float32Array(Light._maxLight),
  angle: new Float32Array(Light._maxLight),
  penumbra: new Float32Array(Light._maxLight),
  penumbraCos: new Float32Array(Light._maxLight),
  coneCos: new Float32Array(Light._maxLight)
};
function hasLight() {
  return this.findFeature(LightFeature).visibleLights.length > 0;
}
var LightFeature = function(_SceneFeature) {
  _inheritsLoose(LightFeature2, _SceneFeature);
  function LightFeature2() {
    var _this;
    _this = _SceneFeature.call(this) || this;
    _this.visibleLights = void 0;
    _this.visibleLights = [];
    return _this;
  }
  var _proto = LightFeature2.prototype;
  _proto.attachRenderLight = function attachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);
    if (index == -1) {
      this.visibleLights.push(light);
    } else {
      Logger.warn("Light already attached.");
    }
  };
  _proto.detachRenderLight = function detachRenderLight(light) {
    var index = this.visibleLights.indexOf(light);
    if (index != -1) {
      this.visibleLights.splice(index, 1);
    }
  };
  _proto._updateShaderData = function _updateShaderData(shaderData) {
    var ambientLightCount = 0;
    var envMapLightCount = 0;
    var directLightCount = 0;
    var pointLightCount = 0;
    var spotLightCount = 0;
    var lights = this.visibleLights;
    for (var i = 0, len = lights.length; i < len; i++) {
      var light = lights[i];
      if (light instanceof AmbientLight) {
        ambientLightCount++;
      } else if (light instanceof EnvironmentMapLight) {
        EnvironmentMapLight._updateShaderData(shaderData, light);
        envMapLightCount++;
      } else if (light instanceof DirectLight) {
        light._appendData(directLightCount++);
      } else if (light instanceof PointLight) {
        light._appendData(pointLightCount++);
      } else if (light instanceof SpotLight) {
        light._appendData(spotLightCount++);
      }
    }
    if (ambientLightCount) {
      shaderData.enableMacro(LightFeature2._ambientMacro);
    } else {
      shaderData.disableMacro(LightFeature2._ambientMacro);
    }
    if (envMapLightCount) {
      shaderData.enableMacro(LightFeature2._envMacro);
    } else {
      shaderData.disableMacro(LightFeature2._envMacro);
    }
    if (directLightCount) {
      DirectLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_DIRECT_LIGHT_COUNT", directLightCount.toString());
    } else {
      shaderData.disableMacro("O3_DIRECT_LIGHT_COUNT");
    }
    if (pointLightCount) {
      PointLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_POINT_LIGHT_COUNT", pointLightCount.toString());
    } else {
      shaderData.disableMacro("O3_POINT_LIGHT_COUNT");
    }
    if (spotLightCount) {
      SpotLight._updateShaderData(shaderData);
      shaderData.enableMacro("O3_SPOT_LIGHT_COUNT", spotLightCount.toString());
    } else {
      shaderData.disableMacro("O3_SPOT_LIGHT_COUNT");
    }
  };
  return LightFeature2;
}(SceneFeature);
LightFeature._ambientMacro = Shader.getMacroByName("O3_HAS_AMBIENT_LIGHT");
LightFeature._envMacro = Shader.getMacroByName("O3_HAS_ENVMAP_LIGHT");
var RefObject = function(_EngineObject) {
  _inheritsLoose(RefObject2, _EngineObject);
  function RefObject2(engine) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.isGCIgnored = false;
    _this._refCount = 0;
    _this._destroyed = false;
    engine.resourceManager._addRefObject(_this.instanceId, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = RefObject2.prototype;
  _proto.destroy = function destroy(force) {
    if (force === void 0) {
      force = false;
    }
    if (this._destroyed)
      return true;
    if (!force && this._refCount !== 0)
      return false;
    var resourceManager = this._engine.resourceManager;
    if (resourceManager) {
      resourceManager._deleteAsset(this);
      resourceManager._deleteRefObject(this.instanceId);
    }
    var refCount = this._getRefCount();
    if (refCount > 0) {
      this._addRefCount(-refCount);
    }
    this._engine = null;
    this._onDestroy();
    this._destroyed = true;
    return true;
  };
  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  };
  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
  };
  _proto._addToResourceManager = function _addToResourceManager(path) {
    this._engine.resourceManager._addAsset(path, this);
  };
  _createClass(RefObject2, [{
    key: "refCount",
    get: function get4() {
      return this._refCount;
    }
  }, {
    key: "destroyed",
    get: function get4() {
      return this._destroyed;
    }
  }]);
  return RefObject2;
}(EngineObject);
var GLCompressedTextureInternalFormat;
(function(GLCompressedTextureInternalFormat2) {
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["R11_EAC"] = 37488] = "R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RG11_EAC"] = 37490] = "RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));
var RenderBufferColorFormat;
(function(RenderBufferColorFormat2) {
  RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8"] = 0] = "R8G8B8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R5G6B5"] = 4] = "R5G6B5";
  RenderBufferColorFormat2[RenderBufferColorFormat2["Alpha8"] = 5] = "Alpha8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R16G16B16A16"] = 6] = "R16G16B16A16";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R32G32B32A32"] = 7] = "R32G32B32A32";
})(RenderBufferColorFormat || (RenderBufferColorFormat = {}));
var RenderBufferDepthFormat;
(function(RenderBufferDepthFormat2) {
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));
var TextureFilterMode;
(function(TextureFilterMode2) {
  TextureFilterMode2[TextureFilterMode2["Point"] = 0] = "Point";
  TextureFilterMode2[TextureFilterMode2["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode2[TextureFilterMode2["Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));
var TextureFormat;
(function(TextureFormat2) {
  TextureFormat2[TextureFormat2["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat2[TextureFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat2[TextureFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat2[TextureFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat2[TextureFormat2["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat2[TextureFormat2["Alpha8"] = 5] = "Alpha8";
  TextureFormat2[TextureFormat2["R32G32B32A32"] = 6] = "R32G32B32A32";
  TextureFormat2[TextureFormat2["DXT1"] = 7] = "DXT1";
  TextureFormat2[TextureFormat2["DXT5"] = 8] = "DXT5";
  TextureFormat2[TextureFormat2["ETC1_RGB"] = 9] = "ETC1_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGB"] = 10] = "ETC2_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGBA5"] = 11] = "ETC2_RGBA5";
  TextureFormat2[TextureFormat2["ETC2_RGBA8"] = 12] = "ETC2_RGBA8";
  TextureFormat2[TextureFormat2["PVRTC_RGB2"] = 13] = "PVRTC_RGB2";
  TextureFormat2[TextureFormat2["PVRTC_RGBA2"] = 14] = "PVRTC_RGBA2";
  TextureFormat2[TextureFormat2["PVRTC_RGB4"] = 15] = "PVRTC_RGB4";
  TextureFormat2[TextureFormat2["PVRTC_RGBA4"] = 16] = "PVRTC_RGBA4";
  TextureFormat2[TextureFormat2["ASTC_4x4"] = 17] = "ASTC_4x4";
  TextureFormat2[TextureFormat2["ASTC_5x5"] = 18] = "ASTC_5x5";
  TextureFormat2[TextureFormat2["ASTC_6x6"] = 19] = "ASTC_6x6";
  TextureFormat2[TextureFormat2["ASTC_8x8"] = 20] = "ASTC_8x8";
  TextureFormat2[TextureFormat2["ASTC_10x10"] = 21] = "ASTC_10x10";
  TextureFormat2[TextureFormat2["ASTC_12x12"] = 22] = "ASTC_12x12";
})(TextureFormat || (TextureFormat = {}));
var TextureWrapMode;
(function(TextureWrapMode2) {
  TextureWrapMode2[TextureWrapMode2["Clamp"] = 0] = "Clamp";
  TextureWrapMode2[TextureWrapMode2["Repeat"] = 1] = "Repeat";
  TextureWrapMode2[TextureWrapMode2["Mirror"] = 2] = "Mirror";
})(TextureWrapMode || (TextureWrapMode = {}));
var Texture = function(_RefObject) {
  _inheritsLoose(Texture2, _RefObject);
  function Texture2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RefObject.call.apply(_RefObject, [this].concat(args)) || this;
    _this.name = void 0;
    _this._glTexture = void 0;
    _this._target = void 0;
    _this._formatDetail = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._rhi = void 0;
    _this._mipmap = void 0;
    _this._mipmapCount = void 0;
    _this._wrapModeU = void 0;
    _this._wrapModeV = void 0;
    _this._filterMode = void 0;
    _this._anisoLevel = 1;
    return _this;
  }
  Texture2._isPowerOf2 = function _isPowerOf2(v) {
    return (v & v - 1) === 0;
  };
  Texture2._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case TextureFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case TextureFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case TextureFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case TextureFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      case TextureFormat.DXT1:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          isCompressed: true
        };
      case TextureFormat.DXT5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
          isCompressed: true
        };
      case TextureFormat.ETC1_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.ASTC_4x4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_5x5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_6x6:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_8x8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_10x10:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_12x12:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          isCompressed: true
        };
      default:
        throw new Error("this TextureFormat is not supported in Oasis Engine: " + format);
    }
  };
  Texture2._getRenderBufferColorFormatDetail = function _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferColorFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case RenderBufferColorFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case RenderBufferColorFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case RenderBufferColorFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R16G16B16A16:
        return {
          internalFormat: gl.RGBA16F,
          baseFormat: gl.RGBA,
          dataType: gl.HALF_FLOAT,
          isCompressed: false
        };
      case RenderBufferColorFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      default:
        throw new Error("this RenderBufferColorFormat is not supported in Oasis Engine: " + format);
    }
  };
  Texture2._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferDepthFormat.Depth:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.DepthStencil:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Stencil:
        return {
          internalFormat: gl.STENCIL_INDEX8,
          baseFormat: gl.STENCIL_ATTACHMENT,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false,
          attachment: gl.STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth16:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24:
        return {
          internalFormat: gl.DEPTH_COMPONENT24,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32:
        return {
          internalFormat: gl.DEPTH_COMPONENT32F,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.FLOAT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24Stencil8:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32Stencil8:
        return {
          internalFormat: gl.DEPTH32F_STENCIL8,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      default:
        throw new Error("this RenderBufferDepthFormat is not supported in Oasis Engine: " + format);
    }
  };
  Texture2._supportTextureFormat = function _supportTextureFormat(format, rhi) {
    var isSupported = true;
    switch (format) {
      case TextureFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  Texture2._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
    var isSupported = true;
    switch (format) {
      case RenderBufferColorFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
      case RenderBufferColorFormat.R16G16B16A16:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  Texture2._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
    var isWebGL2 = rhi.isWebGL2;
    var isSupported = true;
    if (isTexture && !rhi.canIUse(GLCapabilityType.depthTexture)) {
      return false;
    }
    switch (format) {
      case RenderBufferDepthFormat.Stencil:
        {
          isSupported = false;
        }
        break;
      case RenderBufferDepthFormat.Depth24:
      case RenderBufferDepthFormat.Depth32:
      case RenderBufferDepthFormat.Depth32Stencil8:
        {
          if (!isWebGL2) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  };
  var _proto = Texture2.prototype;
  _proto.generateMipmaps = function generateMipmaps() {
    if (!this._mipmap)
      return;
    var gl = this._rhi.gl;
    this._bind();
    gl.generateMipmap(this._target);
    this._unbind();
  };
  _proto._onDestroy = function _onDestroy() {
    var gl = this._rhi.gl;
    gl.deleteTexture(this._glTexture);
    this._glTexture = null;
    this._formatDetail = null;
    this._rhi = null;
  };
  _proto._bind = function _bind() {
    this._rhi.bindTexture(this._target, this._glTexture);
  };
  _proto._unbind = function _unbind() {
    this._rhi.bindTexture(this._target, null);
  };
  _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, out) {
    var gl = this._rhi.gl;
    var _this$_formatDetail = this._formatDetail, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType;
    if (!Texture2._readFrameBuffer) {
      Texture2._readFrameBuffer = gl.createFramebuffer();
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, Texture2._readFrameBuffer);
    if (face != null) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
    } else {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
    }
    gl.readPixels(x, y, width, height, baseFormat, dataType, out);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  _proto._initMipmap = function _initMipmap(isCube) {
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    var _this$_formatDetail2 = this._formatDetail, internalFormat = _this$_formatDetail2.internalFormat, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
    this._bind();
    if (isWebGL2) {
      gl.texStorage2D(this._target, this._mipmapCount, internalFormat, this._width, this._height);
    } else {
      if (baseFormat !== internalFormat) {
        internalFormat = baseFormat;
      }
      if (!isCube) {
        for (var i = 0; i < this._mipmapCount; i++) {
          var width = Math.max(1, this._width >> i);
          var height = Math.max(1, this._height >> i);
          gl.texImage2D(this._target, i, internalFormat, width, height, 0, baseFormat, dataType, null);
        }
      } else {
        for (var _i = 0; _i < this._mipmapCount; _i++) {
          var size = Math.max(1, this._width >> _i);
          for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i, internalFormat, size, size, 0, baseFormat, dataType, null);
          }
        }
      }
    }
    this._unbind();
  };
  _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
    return Math.floor(Math.log2(size));
  };
  _proto._getMipmapCount = function _getMipmapCount() {
    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
  };
  _proto._setWrapMode = function _setWrapMode(value, pname) {
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    if (!isWebGL2 && value !== TextureWrapMode.Clamp && (!Texture2._isPowerOf2(this._width) || !Texture2._isPowerOf2(this._height))) {
      Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
      value = TextureWrapMode.Clamp;
    }
    switch (value) {
      case TextureWrapMode.Clamp:
        gl.texParameteri(this._target, pname, gl.CLAMP_TO_EDGE);
        break;
      case TextureWrapMode.Repeat:
        gl.texParameteri(this._target, pname, gl.REPEAT);
        break;
      case TextureWrapMode.Mirror:
        gl.texParameteri(this._target, pname, gl.MIRRORED_REPEAT);
        break;
    }
  };
  _createClass(Texture2, [{
    key: "width",
    get: function get4() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get4() {
      return this._height;
    }
  }, {
    key: "wrapModeU",
    get: function get4() {
      return this._wrapModeU;
    },
    set: function set4(value) {
      if (value === this._wrapModeU)
        return;
      var gl = this._rhi.gl;
      this._wrapModeU = value;
      this._bind();
      this._setWrapMode(value, gl.TEXTURE_WRAP_S);
      this._unbind();
    }
  }, {
    key: "wrapModeV",
    get: function get4() {
      return this._wrapModeV;
    },
    set: function set4(value) {
      if (value === this._wrapModeV)
        return;
      var gl = this._rhi.gl;
      this._wrapModeV = value;
      this._bind();
      this._setWrapMode(value, gl.TEXTURE_WRAP_T);
      this._unbind();
    }
  }, {
    key: "mipmapCount",
    get: function get4() {
      return this._mipmapCount;
    }
  }, {
    key: "filterMode",
    get: function get4() {
      return this._filterMode;
    },
    set: function set4(value) {
      if (value === this._filterMode)
        return;
      var gl = this._rhi.gl;
      this._filterMode = value;
      this._bind();
      switch (value) {
        case TextureFilterMode.Point:
          gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
          break;
        case TextureFilterMode.Bilinear:
          gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
          break;
        case TextureFilterMode.Trilinear:
          gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
          break;
      }
      this._unbind();
    }
  }, {
    key: "anisoLevel",
    get: function get4() {
      return this._anisoLevel;
    },
    set: function set4(value) {
      var max = this._rhi.capability.maxAnisoLevel;
      if (value > max) {
        Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
        value = max;
      }
      if (value < 1) {
        Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
        value = 1;
      }
      if (value === this._anisoLevel)
        return;
      var gl = this._rhi.gl;
      this._anisoLevel = value;
      this._bind();
      gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
      this._unbind();
    }
  }]);
  return Texture2;
}(RefObject);
Texture._readFrameBuffer = null;
var ShaderData = function() {
  function ShaderData2(group) {
    this._group = void 0;
    this._properties = Object.create(null);
    this._macroCollection = new ShaderMacroCollection();
    this._variableMacros = Object.create(null);
    this._refCount = 0;
    this._group = group;
  }
  var _proto = ShaderData2.prototype;
  _proto.getFloat = function getFloat(property) {
    return this._getData(property);
  };
  _proto.setFloat = function setFloat(property, value) {
    this._setData(property, value);
  };
  _proto.getInt = function getInt(property) {
    return this._getData(property);
  };
  _proto.setInt = function setInt(property, value) {
    this._setData(property, value);
  };
  _proto.getFloatArray = function getFloatArray(property) {
    return this._getData(property);
  };
  _proto.setFloatArray = function setFloatArray(property, value) {
    this._setData(property, value);
  };
  _proto.getIntArray = function getIntArray(property) {
    return this._getData(property);
  };
  _proto.setIntArray = function setIntArray(property, value) {
    this._setData(property, value);
  };
  _proto.getVector2 = function getVector2(property) {
    return this._getData(property);
  };
  _proto.setVector2 = function setVector2(property, value) {
    this._setData(property, value);
  };
  _proto.getVector3 = function getVector3(property) {
    return this._getData(property);
  };
  _proto.setVector3 = function setVector3(property, value) {
    this._setData(property, value);
  };
  _proto.getVector4 = function getVector4(property) {
    return this._getData(property);
  };
  _proto.setVector4 = function setVector4(property, value) {
    this._setData(property, value);
  };
  _proto.getMatrix = function getMatrix(property) {
    return this._getData(property);
  };
  _proto.setMatrix = function setMatrix(property, value) {
    this._setData(property, value);
  };
  _proto.getColor = function getColor(property) {
    return this._getData(property);
  };
  _proto.setColor = function setColor(property, value) {
    this._setData(property, value);
  };
  _proto.getTexture = function getTexture(property) {
    return this._getData(property);
  };
  _proto.setTexture = function setTexture(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this._getData(property);
      lastValue && lastValue._addRefCount(-1);
      value && value._addRefCount(1);
    }
    this._setData(property, value);
  };
  _proto.getTextureArray = function getTextureArray(property) {
    return this._getData(property);
  };
  _proto.setTextureArray = function setTextureArray(property, value) {
    if (this._getRefCount() > 0) {
      var lastValue = this._getData(property);
      if (lastValue) {
        for (var i = 0, n = lastValue.length; i < n; i++) {
          lastValue[i]._addRefCount(-1);
        }
      }
      if (value) {
        for (var _i = 0, _n = value.length; _i < _n; _i++) {
          value[_i]._addRefCount(1);
        }
      }
    }
    this._setData(property, value);
  };
  _proto.enableMacro = function enableMacro(macro, value) {
    if (value === void 0) {
      value = null;
    }
    if (value) {
      this._enableVariableMacro(macro, value);
    } else {
      if (typeof macro === "string") {
        macro = Shader.getMacroByName(macro);
      }
      this._macroCollection.enable(macro);
    }
  };
  _proto.disableMacro = function disableMacro(macro) {
    if (typeof macro === "string") {
      var variableValue = this._variableMacros[macro];
      if (variableValue) {
        this._disableVariableMacro(macro, variableValue);
      } else {
        macro = Shader.getMacroByName(macro);
        this._macroCollection.disable(macro);
      }
    } else {
      this._macroCollection.disable(macro);
    }
  };
  _proto.clone = function clone2() {
    var shaderData = new ShaderData2(this._group);
    this.cloneTo(shaderData);
    return shaderData;
  };
  _proto.cloneTo = function cloneTo(target) {
    CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);
    _extends(target._variableMacros, this._variableMacros);
    var properties = this._properties;
    var targetProperties = target._properties;
    var keys = Object.keys(properties);
    for (var i = 0, n = keys.length; i < n; i++) {
      var k = keys[i];
      var _property = properties[k];
      if (_property != null) {
        if (typeof _property === "number") {
          targetProperties[k] = _property;
        } else if (_property instanceof Texture) {
          targetProperties[k] = _property;
        } else if (_property instanceof Array || _property instanceof Float32Array || _property instanceof Int32Array) {
          targetProperties[k] = _property.slice();
        } else {
          targetProperties[k] = _property.clone();
        }
      } else {
        targetProperties[k] = _property;
      }
    }
  };
  _proto._getData = function _getData(property) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }
    return this._properties[property._uniqueId];
  };
  _proto._setData = function _setData(property, value) {
    if (typeof property === "string") {
      property = Shader.getPropertyByName(property);
    }
    if (property._group !== this._group) {
      if (property._group === void 0) {
        property._group = this._group;
      } else {
        throw "This property has been used as " + ShaderDataGroup[property._group] + " property.";
      }
    }
    this._properties[property._uniqueId] = value;
  };
  _proto._getRefCount = function _getRefCount() {
    return this._refCount;
  };
  _proto._addRefCount = function _addRefCount(value) {
    this._refCount += value;
    var properties = this._properties;
    for (var k in properties) {
      var _property2 = properties[k];
      if (_property2 && _property2 instanceof Texture) {
        _property2._addRefCount(value);
      }
    }
  };
  _proto._enableVariableMacro = function _enableVariableMacro(name, value) {
    var variableMacro = this._variableMacros;
    var variableValue = variableMacro[name];
    if (variableValue !== value) {
      variableValue && this._disableVariableMacro(name, variableValue);
      var _macro = Shader.getMacroByName(name + " " + value);
      this._macroCollection.enable(_macro);
      variableMacro[name] = value;
    }
  };
  _proto._disableVariableMacro = function _disableVariableMacro(name, value) {
    var oldMacro = Shader.getMacroByName(name + " " + value);
    this._macroCollection.disable(oldMacro);
    delete this._variableMacros[name];
  };
  return ShaderData2;
}();
var Scene = function(_EngineObject) {
  _inheritsLoose(Scene2, _EngineObject);
  function Scene2(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.shaderData = new ShaderData(ShaderDataGroup.Scene);
    _this.name = void 0;
    _this.clipPlanes = [];
    _this._activeCameras = [];
    _this._isActiveInEngine = false;
    _this._destroyed = false;
    _this._rootEntities = [];
    _this._resolution = new Vector2();
    _this.features = [];
    _this.name = name || "";
    var shaderData = _this.shaderData;
    Scene2.sceneFeatureManager.addObject(_assertThisInitialized(_this));
    shaderData._addRefCount(1);
    if (_this._engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
      shaderData.enableMacro("HAS_TEX_LOD");
    }
    if (_this._engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
      shaderData.enableMacro("HAS_DERIVATIVES");
    }
    return _this;
  }
  var _proto = Scene2.prototype;
  _proto.createRootEntity = function createRootEntity(name) {
    var entity = new Entity(this._engine, name);
    this.addRootEntity(entity);
    return entity;
  };
  _proto.addRootEntity = function addRootEntity(entity) {
    var isRoot = entity._isRoot;
    if (!isRoot) {
      entity._isRoot = true;
      entity._removeFromParent();
    }
    var oldScene = entity._scene;
    if (oldScene !== this) {
      if (oldScene && isRoot) {
        oldScene._removeEntity(entity);
      }
      this._rootEntities.push(entity);
      Entity._traverseSetOwnerScene(entity, this);
    } else if (!isRoot) {
      this._rootEntities.push(entity);
    }
    if (this._isActiveInEngine) {
      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
    } else {
      entity._isActiveInHierarchy && entity._processInActive();
    }
  };
  _proto.removeRootEntity = function removeRootEntity(entity) {
    if (entity._isRoot && entity._scene == this) {
      this._removeEntity(entity);
      this._isActiveInEngine && entity._processInActive();
      Entity._traverseSetOwnerScene(entity, null);
    }
  };
  _proto.getRootEntity = function getRootEntity(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._rootEntities[index];
  };
  _proto.findEntityByName = function findEntityByName(name) {
    var children = this._rootEntities;
    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    for (var _i = children.length - 1; _i >= 0; _i--) {
      var _child = children[_i];
      var entity = _child.findByName(name);
      if (entity) {
        return entity;
      }
    }
    return null;
  };
  _proto.findEntityByPath = function findEntityByPath(path) {
    var splits = path.split("/").filter(Boolean);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      var findEntity = this.getRootEntity(i);
      if (findEntity.name != splits[0])
        continue;
      for (var j = 1, m = splits.length; j < m; ++j) {
        findEntity = Entity._findChildByName(findEntity, splits[j]);
        if (!findEntity)
          break;
      }
      return findEntity;
    }
    return null;
  };
  _proto.destroy = function destroy() {
    if (this._destroyed) {
      return;
    }
    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
    Scene2.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);
    for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
      this._rootEntities[i].destroy();
    }
    this._rootEntities.length = 0;
    this._activeCameras.length = 0;
    Scene2.sceneFeatureManager._objects = [];
    this.shaderData._addRefCount(-1);
    this._destroyed = true;
  };
  _proto.attachRenderCamera = function attachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index === -1) {
      this._activeCameras.push(camera);
    } else {
      Logger.warn("Camera already attached.");
    }
  };
  _proto.detachRenderCamera = function detachRenderCamera(camera) {
    var index = this._activeCameras.indexOf(camera);
    if (index !== -1) {
      this._activeCameras.splice(index, 1);
    }
  };
  _proto._processActive = function _processActive(active) {
    this._isActiveInEngine = active;
    var rootEntities = this._rootEntities;
    for (var i = rootEntities.length - 1; i >= 0; i--) {
      var entity = rootEntities[i];
      if (entity._isActive) {
        active ? entity._processActive() : entity._processInActive();
      }
    }
  };
  _proto._updateShaderData = function _updateShaderData() {
    var lightMgr = this.findFeature(LightFeature);
    var shaderData = this.shaderData;
    var canvas = this.engine.canvas;
    var resolution = this._resolution;
    lightMgr._updateShaderData(shaderData);
    resolution.setValue(canvas.width, canvas.height);
    shaderData.setVector2(Scene2._resolutionProperty, resolution);
  };
  _proto._removeEntity = function _removeEntity(entity) {
    var oldRootEntities = this._rootEntities;
    oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);
  };
  Scene2.registerFeature = function registerFeature(Feature) {
    Scene2.sceneFeatureManager.registerFeature(Feature);
  };
  _proto.findFeature = function findFeature(Feature) {
    return Scene2.sceneFeatureManager.findFeature(this, Feature);
  };
  _proto.raycast = function raycast(ray, outPos, tag) {
  };
  _createClass(Scene2, [{
    key: "engine",
    get: function get4() {
      return this._engine;
    }
  }, {
    key: "rootEntitiesCount",
    get: function get4() {
      return this._rootEntities.length;
    }
  }, {
    key: "rootEntities",
    get: function get4() {
      return this._rootEntities;
    }
  }, {
    key: "destroyed",
    get: function get4() {
      return this._destroyed;
    }
  }]);
  return Scene2;
}(EngineObject);
Scene._resolutionProperty = Shader.getPropertyByName("u_resolution");
Scene.sceneFeatureManager = new FeatureManager();
var SceneManager = function() {
  function SceneManager2(engine) {
    this.engine = engine;
    this._activeScene = void 0;
  }
  var _proto = SceneManager2.prototype;
  _proto.loadScene = function loadScene(url, destroyOldScene) {
    var _this = this;
    if (destroyOldScene === void 0) {
      destroyOldScene = true;
    }
    var scenePromise = this.engine.resourceManager.load(url);
    scenePromise.then(function(scene) {
      var oldScene = _this._activeScene;
      _this.activeScene = scene;
      if (oldScene && destroyOldScene) {
        oldScene.destroy();
      }
    });
    return scenePromise;
  };
  _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
    var oldRootEntities = sourceScene.rootEntities;
    for (var i = 0, n = oldRootEntities.length; i < n; i++) {
      destScene.addRootEntity(oldRootEntities[i]);
    }
  };
  _createClass(SceneManager2, [{
    key: "activeScene",
    get: function get4() {
      return this._activeScene;
    },
    set: function set4(scene) {
      var oldScene = this._activeScene;
      if (oldScene !== scene) {
        oldScene && oldScene._processActive(false);
        scene && scene._processActive(true);
        this._activeScene = scene;
      }
    }
  }]);
  return SceneManager2;
}();
var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n#include <fog_share>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_normal_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;gl_FragColor.a=diffuse.a;\n#include <fog_frag>\n}";
var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <morph_target_vert>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <morph_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}";
var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform bool u_active;uniform mat4 u_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 u_viewInvMat;uniform mat4 u_projMat;uniform mat4 u_viewMat;uniform mat4 u_modelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y+a_lifeAndSize.x;float deltaTime=max(mod(u_time,life)-a_lifeAndSize.x,0.0);bool isDying=false;if(u_once||!u_active){isDying=true;}if((isDying&&u_time>life)){deltaTime=life;}if(deltaTime==0.0){deltaTime=life;}v_lifeLeft=1.0-deltaTime/a_lifeAndSize.y;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=u_viewInvMat[0].xyz;vec3 basisZ=u_viewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=u_projMat*u_viewMat*vec4(localPosition+u_modelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=u_MVPMat*rotatedPoint;\n#endif\n}";
var pbrFs = "#define GLSLIFY 1\n#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n#include <fog_share>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <refraction_share>\n#include <perturbation_share>\n#include <clipPlane_frag_define>\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n#include <pbr_runtime_frag_define>\n#include <pbr_normal_frag_define>\n#include <pbr_brdf_cook_torrance_frag_define>\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\n#include <oit_frag_define>\nvoid main(){\n#include <clipPlane_frag>\n#include <pbr_begin_frag>\n#include <pbr_direct_irradiance_frag>\n#include <pbr_ibl_diffuse_frag>\n#include <pbr_ibl_specular_frag>\n#include <pbr_end_frag>\n#include <gamma_frag>\n#include <refraction_frag>\n#include <perturbation_frag>\n#include <fog_frag>\n#include <oit_frag>\n}";
var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <clipPlane_vert_define>\n#include <morph_target_vert>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <morph_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <shadow_vert>\n#include <clipPlane_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
var shadowMapFs = "#define GLSLIFY 1\n/***Decompose and save depth value.*/vec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}void main(){gl_FragColor=pack(gl_FragCoord.z);}";
var shadowMapVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <normal_share>\n#include <shadow_share>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <skinning_vert>\n#include <shadow_vert>\n#include <position_vert>\n}";
var shadowFs = "#define GLSLIFY 1\n#ifdef O3_SHADOW_MAP_COUNT\nuniform float u_shadowBias[O3_SHADOW_MAP_COUNT];uniform float u_shadowIntensity[O3_SHADOW_MAP_COUNT];uniform float u_shadowRadius[O3_SHADOW_MAP_COUNT];uniform vec2 u_shadowMapSize[O3_SHADOW_MAP_COUNT];uniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];varying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];const vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));/***Unpack depth value.*/float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}/***Degree of shadow.*/float getVisibility(vec4 positionFromLight,const in sampler2D shadowMap,vec2 mapSize,float intensity,float bias,float radius){vec3 shadowCoord=(positionFromLight.xyz/positionFromLight.w)/2.0+0.5;float filterX=step(0.0,shadowCoord.x)*(1.0-step(1.0,shadowCoord.x));float filterY=step(0.0,shadowCoord.y)*(1.0-step(1.0,shadowCoord.y));shadowCoord.z-=bias;vec2 texelSize=vec2(1.0)/mapSize;float visibility=0.0;for(float y=-1.0;y<=1.0;y+=1.0){for(float x=-1.0;x<=1.0;x+=1.0){vec2 uv=shadowCoord.xy+texelSize*vec2(x,y)*radius;vec4 rgbaDepth=texture2D(shadowMap,uv);float depth=unpack(rgbaDepth);visibility+=step(depth,shadowCoord.z)*intensity;}}visibility*=(1.0/9.0);return visibility*filterX*filterY;}\n#endif\nvoid main(){vec4 shadowColor=vec4(1.0,1.0,1.0,1.0);\n#ifdef O3_SHADOW_MAP_COUNT\nfloat visibility=1.0;\n#if (O3_SHADOW_MAP_COUNT == 1)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);\n#elif (O3_SHADOW_MAP_COUNT == 2)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);\n#elif (O3_SHADOW_MAP_COUNT == 3)\nvisibility-=getVisibility(v_PositionFromLight[0],u_shadowMaps[0],u_shadowMapSize[0],u_shadowIntensity[0],u_shadowBias[0],u_shadowRadius[0]);visibility-=getVisibility(v_PositionFromLight[1],u_shadowMaps[1],u_shadowMapSize[1],u_shadowIntensity[1],u_shadowBias[1],u_shadowRadius[1]);visibility-=getVisibility(v_PositionFromLight[2],u_shadowMaps[2],u_shadowMapSize[2],u_shadowIntensity[2],u_shadowBias[2],u_shadowRadius[2]);\n#endif\nvisibility=clamp(visibility,0.0,1.0);shadowColor=vec4(visibility,visibility,visibility,1.0);\n#endif\ngl_FragColor=shadowColor;}";
var skyboxFs = "#define GLSLIFY 1\nuniform samplerCube u_cube;varying vec3 v_cubeUV;void main(){gl_FragColor=textureCube(u_cube,v_cubeUV);}";
var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 u_mvpNoscale;varying vec3 v_cubeUV;void main(){v_cubeUV=POSITION.xyz;gl_Position=u_mvpNoscale*vec4(POSITION,1.0);gl_Position.z=gl_Position.w;}";
var unlitFs = "#define GLSLIFY 1\n#include <uv_share>\n#include <fog_share>\nuniform vec4 u_baseColor;\n#ifdef O3_BASECOLOR_TEXTURE\nuniform sampler2D u_baseColorTexture;\n#endif\nvoid main(){vec4 baseColor=u_baseColor;\n#ifdef O3_BASECOLOR_TEXTURE\nbaseColor*=texture2D(u_baseColorTexture,v_uv);\n#endif\ngl_FragColor=baseColor;\n#include <fog_frag>\n}";
var unlitVs = "#define GLSLIFY 1\n#include <common_vert>\n#include <uv_share>\n#include <fog_share>\nvoid main(){\n#include <begin_position_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <fog_vert>\n}";
var ShaderPool = function() {
  function ShaderPool2() {
  }
  ShaderPool2.init = function init2() {
    Shader.create("blinn-phong", blinnPhongVs, blinnPhongFs);
    Shader.create("pbr", pbrVs, pbrFs);
    Shader.create("unlit", unlitVs, unlitFs);
    Shader.create("shadow-map", shadowMapVs, shadowMapFs);
    Shader.create("shadow", shadowMapVs, shadowFs);
    Shader.create("skybox", skyboxVs, skyboxFs);
    Shader.create("particle-shader", particleVs, particleFs);
  };
  return ShaderPool2;
}();
var ShaderProgramPool = function() {
  function ShaderProgramPool2() {
    this._cacheHierarchy = 1;
    this._cacheMap = Object.create(null);
    this._lastQueryMap = void 0;
    this._lastQueryKey = void 0;
  }
  var _proto = ShaderProgramPool2.prototype;
  _proto.get = function get4(macros) {
    var cacheMap = this._cacheMap;
    var maskLength = macros._length;
    if (maskLength > this._cacheHierarchy) {
      this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
    }
    var mask = macros._mask;
    var endIndex = macros._length - 1;
    var maxEndIndex = this._cacheHierarchy - 1;
    for (var i = 0; i < maxEndIndex; i++) {
      var subMask = endIndex < i ? 0 : mask[i];
      var subCacheShaders = cacheMap[subMask];
      subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));
      cacheMap = subCacheShaders;
    }
    var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
    var shader = cacheMap[cacheKey];
    if (!shader) {
      this._lastQueryKey = cacheKey;
      this._lastQueryMap = cacheMap;
    }
    return shader;
  };
  _proto.cache = function cache(shaderProgram) {
    this._lastQueryMap[this._lastQueryKey] = shaderProgram;
  };
  _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
    var end = this._cacheHierarchy - 1;
    if (hierarchy == end) {
      for (var k in cacheMap) {
        var shader = cacheMap[k];
        for (var i = 0, n = resizeLength - end; i < n; i++) {
          if (i == n - 1) {
            cacheMap[0] = shader;
          } else {
            cacheMap = cacheMap[i == 0 ? k : 0] = Object.create(null);
          }
        }
      }
      this._cacheHierarchy = resizeLength;
    } else {
      for (var _k in cacheMap) {
        this._resizeCacheMapHierarchy(cacheMap[_k], ++hierarchy, resizeLength);
      }
    }
  };
  return ShaderProgramPool2;
}();
var RenderTargetBlendState = function RenderTargetBlendState2() {
  this.colorBlendOperation = BlendOperation.Add;
  this.alphaBlendOperation = BlendOperation.Add;
  this.sourceColorBlendFactor = BlendFactor.One;
  this.sourceAlphaBlendFactor = BlendFactor.One;
  this.destinationColorBlendFactor = BlendFactor.Zero;
  this.destinationAlphaBlendFactor = BlendFactor.Zero;
  this.colorWriteMask = ColorWriteMask.All;
  this._blendEnable = false;
};
var BlendState = function() {
  function BlendState2() {
    this.targetBlendState = new RenderTargetBlendState();
    this.blendColor = new Color(0, 0, 0, 0);
    this.alphaToCoverage = false;
  }
  BlendState2._getGLBlendFactor = function _getGLBlendFactor(blendFactor) {
    switch (blendFactor) {
      case BlendFactor.Zero:
        return WebGLRenderingContext.ZERO;
      case BlendFactor.One:
        return WebGLRenderingContext.ONE;
      case BlendFactor.SourceColor:
        return WebGLRenderingContext.SRC_COLOR;
      case BlendFactor.OneMinusSourceColor:
        return WebGLRenderingContext.ONE_MINUS_SRC_COLOR;
      case BlendFactor.DestinationColor:
        return WebGLRenderingContext.DST_COLOR;
      case BlendFactor.OneMinusDestinationColor:
        return WebGLRenderingContext.ONE_MINUS_DST_COLOR;
      case BlendFactor.SourceAlpha:
        return WebGLRenderingContext.SRC_ALPHA;
      case BlendFactor.OneMinusSourceAlpha:
        return WebGLRenderingContext.ONE_MINUS_SRC_ALPHA;
      case BlendFactor.DestinationAlpha:
        return WebGLRenderingContext.DST_ALPHA;
      case BlendFactor.OneMinusDestinationAlpha:
        return WebGLRenderingContext.ONE_MINUS_DST_ALPHA;
      case BlendFactor.SourceAlphaSaturate:
        return WebGLRenderingContext.SRC_ALPHA_SATURATE;
      case BlendFactor.BlendColor:
        return WebGLRenderingContext.CONSTANT_COLOR;
      case BlendFactor.OneMinusBlendColor:
        return WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR;
    }
  };
  BlendState2._getGLBlendOperation = function _getGLBlendOperation(blendOperation) {
    switch (blendOperation) {
      case BlendOperation.Add:
        return WebGLRenderingContext.FUNC_ADD;
      case BlendOperation.Subtract:
        return WebGLRenderingContext.FUNC_SUBTRACT;
      case BlendOperation.ReverseSubtract:
        return WebGLRenderingContext.FUNC_REVERSE_SUBTRACT;
      case BlendOperation.Min:
        return WebGL2RenderingContext.MIN;
      case BlendOperation.Max:
        return WebGL2RenderingContext.MAX;
    }
  };
  var _proto = BlendState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.blendState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var lastTargetBlendState = lastState.targetBlendState;
    var _this$targetBlendStat = this.targetBlendState, colorBlendOperation = _this$targetBlendStat.colorBlendOperation, alphaBlendOperation = _this$targetBlendStat.alphaBlendOperation, sourceColorBlendFactor = _this$targetBlendStat.sourceColorBlendFactor, destinationColorBlendFactor = _this$targetBlendStat.destinationColorBlendFactor, sourceAlphaBlendFactor = _this$targetBlendStat.sourceAlphaBlendFactor, destinationAlphaBlendFactor = _this$targetBlendStat.destinationAlphaBlendFactor, colorWriteMask = _this$targetBlendStat.colorWriteMask;
    var blendEnable = !(sourceColorBlendFactor === BlendFactor.One && destinationColorBlendFactor === BlendFactor.Zero && sourceAlphaBlendFactor === BlendFactor.One && destinationAlphaBlendFactor === BlendFactor.Zero && (colorBlendOperation === BlendOperation.Add || colorBlendOperation === BlendOperation.Subtract) && (alphaBlendOperation === BlendOperation.Add || alphaBlendOperation === BlendOperation.Subtract));
    if (blendEnable !== lastTargetBlendState._blendEnable) {
      if (blendEnable) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      lastTargetBlendState._blendEnable = blendEnable;
    }
    if (blendEnable) {
      if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
        gl.blendFuncSeparate(BlendState2._getGLBlendFactor(sourceColorBlendFactor), BlendState2._getGLBlendFactor(destinationColorBlendFactor), BlendState2._getGLBlendFactor(sourceAlphaBlendFactor), BlendState2._getGLBlendFactor(destinationAlphaBlendFactor));
        lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
        lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
        lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
        lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
      }
      if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
        gl.blendEquationSeparate(BlendState2._getGLBlendOperation(colorBlendOperation), BlendState2._getGLBlendOperation(alphaBlendOperation));
        lastTargetBlendState.colorBlendOperation = colorBlendOperation;
        lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
      }
      var blendColor = this.blendColor;
      if (!Color.equals(lastState.blendColor, blendColor)) {
        gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
        blendColor.cloneTo(lastState.blendColor);
      }
    }
    if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
      gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
      lastTargetBlendState.colorWriteMask = colorWriteMask;
    }
    var alphaToCoverage = this.alphaToCoverage;
    if (alphaToCoverage !== lastState.alphaToCoverage) {
      if (alphaToCoverage) {
        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      } else {
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      }
      lastState.alphaToCoverage = alphaToCoverage;
    }
  };
  return BlendState2;
}();
var DepthState = function() {
  function DepthState2() {
    this.enabled = true;
    this.writeEnabled = true;
    this.compareFunction = CompareFunction.Less;
  }
  DepthState2._getGLCompareFunction = function _getGLCompareFunction(compareFunction) {
    switch (compareFunction) {
      case CompareFunction.Never:
        return WebGLRenderingContext.NEVER;
      case CompareFunction.Less:
        return WebGLRenderingContext.LESS;
      case CompareFunction.Equal:
        return WebGLRenderingContext.EQUAL;
      case CompareFunction.LessEqual:
        return WebGL2RenderingContext.LEQUAL;
      case CompareFunction.Greater:
        return WebGL2RenderingContext.GREATER;
      case CompareFunction.NotEqual:
        return WebGL2RenderingContext.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return WebGL2RenderingContext.GEQUAL;
      case CompareFunction.Always:
        return WebGL2RenderingContext.ALWAYS;
    }
  };
  var _proto = DepthState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.depthState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled, compareFunction = this.compareFunction, writeEnabled = this.writeEnabled;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      if (compareFunction != lastState.compareFunction) {
        gl.depthFunc(DepthState2._getGLCompareFunction(compareFunction));
        lastState.compareFunction = compareFunction;
      }
      if (writeEnabled != lastState.writeEnabled) {
        gl.depthMask(writeEnabled);
        lastState.writeEnabled = writeEnabled;
      }
    }
  };
  return DepthState2;
}();
var RasterState = function() {
  function RasterState2() {
    this.cullMode = CullMode.Back;
    this.depthBias = 0;
    this.slopeScaledDepthBias = 0;
    this._cullFaceEnable = true;
  }
  var _proto = RasterState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.rasterState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var cullMode = this.cullMode, depthBias = this.depthBias, slopeScaledDepthBias = this.slopeScaledDepthBias;
    var cullFaceEnable = cullMode !== CullMode.Off;
    if (cullFaceEnable !== lastState._cullFaceEnable) {
      if (cullFaceEnable) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      lastState._cullFaceEnable = cullFaceEnable;
    }
    if (cullFaceEnable) {
      if (cullMode !== lastState.cullMode) {
        if (cullMode == CullMode.Back) {
          gl.cullFace(gl.BACK);
        } else {
          gl.cullFace(gl.FRONT);
        }
        lastState.cullMode = cullMode;
      }
    }
    if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
      if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(slopeScaledDepthBias, depthBias);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      lastState.depthBias = depthBias;
      lastState.slopeScaledDepthBias = slopeScaledDepthBias;
    }
  };
  return RasterState2;
}();
var StencilState = function() {
  function StencilState2() {
    this.enabled = false;
    this.referenceValue = 0;
    this.mask = 255;
    this.writeMask = 255;
    this.compareFunctionFront = CompareFunction.Always;
    this.compareFunctionBack = CompareFunction.Always;
    this.passOperationFront = StencilOperation.Keep;
    this.passOperationBack = StencilOperation.Keep;
    this.failOperationFront = StencilOperation.Keep;
    this.failOperationBack = StencilOperation.Keep;
    this.zFailOperationFront = StencilOperation.Keep;
    this.zFailOperationBack = StencilOperation.Keep;
  }
  StencilState2._getGLCompareFunction = function _getGLCompareFunction(compareFunction) {
    switch (compareFunction) {
      case CompareFunction.Never:
        return WebGLRenderingContext.NEVER;
      case CompareFunction.Less:
        return WebGLRenderingContext.LESS;
      case CompareFunction.Equal:
        return WebGLRenderingContext.EQUAL;
      case CompareFunction.LessEqual:
        return WebGLRenderingContext.LEQUAL;
      case CompareFunction.Greater:
        return WebGLRenderingContext.GREATER;
      case CompareFunction.NotEqual:
        return WebGLRenderingContext.NOTEQUAL;
      case CompareFunction.GreaterEqual:
        return WebGLRenderingContext.GEQUAL;
      case CompareFunction.Always:
        return WebGLRenderingContext.ALWAYS;
    }
  };
  StencilState2._getGLStencilOperation = function _getGLStencilOperation(compareFunction) {
    switch (compareFunction) {
      case StencilOperation.Keep:
        return WebGLRenderingContext.KEEP;
      case StencilOperation.Zero:
        return WebGLRenderingContext.ZERO;
      case StencilOperation.Replace:
        return WebGLRenderingContext.REPLACE;
      case StencilOperation.IncrementSaturate:
        return WebGLRenderingContext.INCR;
      case StencilOperation.DecrementSaturate:
        return WebGLRenderingContext.DECR;
      case StencilOperation.Invert:
        return WebGLRenderingContext.INVERT;
      case StencilOperation.IncrementWrap:
        return WebGLRenderingContext.INCR_WRAP;
      case StencilOperation.DecrementWrap:
        return WebGLRenderingContext.DECR_WRAP;
    }
  };
  var _proto = StencilState2.prototype;
  _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
    this._platformApply(hardwareRenderer, lastRenderState.stencilState);
  };
  _proto._platformApply = function _platformApply(rhi, lastState) {
    var gl = rhi.gl;
    var enabled = this.enabled, referenceValue = this.referenceValue, mask = this.mask, compareFunctionFront = this.compareFunctionFront, compareFunctionBack = this.compareFunctionBack, failOperationFront = this.failOperationFront, zFailOperationFront = this.zFailOperationFront, passOperationFront = this.passOperationFront, failOperationBack = this.failOperationBack, zFailOperationBack = this.zFailOperationBack, passOperationBack = this.passOperationBack, writeMask = this.writeMask;
    if (enabled != lastState.enabled) {
      if (enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(WebGLRenderingContext.STENCIL_TEST);
      }
      lastState.enabled = enabled;
    }
    if (enabled) {
      var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
      if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
        gl.stencilFuncSeparate(gl.FRONT, StencilState2._getGLCompareFunction(compareFunctionFront), referenceValue, mask);
        lastState.compareFunctionFront = compareFunctionFront;
      }
      if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
        gl.stencilFuncSeparate(gl.BACK, StencilState2._getGLCompareFunction(compareFunctionBack), referenceValue, mask);
        lastState.compareFunctionBack = this.compareFunctionBack;
      }
      if (referenceOrMaskChange) {
        lastState.referenceValue = this.referenceValue;
        lastState.mask = this.mask;
      }
      if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
        gl.stencilOpSeparate(gl.FRONT, StencilState2._getGLStencilOperation(failOperationFront), StencilState2._getGLStencilOperation(zFailOperationFront), StencilState2._getGLStencilOperation(passOperationFront));
        lastState.failOperationFront = failOperationFront;
        lastState.zFailOperationFront = zFailOperationFront;
        lastState.passOperationFront = passOperationFront;
      }
      if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
        gl.stencilOpSeparate(gl.BACK, StencilState2._getGLStencilOperation(failOperationBack), StencilState2._getGLStencilOperation(zFailOperationBack), StencilState2._getGLStencilOperation(passOperationBack));
        lastState.failOperationBack = failOperationBack;
        lastState.zFailOperationBack = zFailOperationBack;
        lastState.passOperationBack = passOperationBack;
      }
      if (writeMask !== lastState.writeMask) {
        gl.stencilMask(writeMask);
        lastState.writeMask = writeMask;
      }
    }
  };
  return StencilState2;
}();
var RenderState$1 = function() {
  function RenderState2() {
    this.blendState = new BlendState();
    this.depthState = new DepthState();
    this.stencilState = new StencilState();
    this.rasterState = new RasterState();
  }
  var _proto = RenderState2.prototype;
  _proto._apply = function _apply(engine) {
    var hardwareRenderer = engine._hardwareRenderer;
    var lastRenderState = engine._lastRenderState;
    this.blendState._apply(hardwareRenderer, lastRenderState);
    this.depthState._apply(hardwareRenderer, lastRenderState);
    this.stencilState._apply(hardwareRenderer, lastRenderState);
    this.rasterState._apply(hardwareRenderer, lastRenderState);
  };
  return RenderState2;
}();
var engineFeatureManager = new FeatureManager();
ShaderPool.init();
var Engine = function(_EventDispatcher) {
  _inheritsLoose(Engine2, _EventDispatcher);
  function Engine2(canvas, hardwareRenderer) {
    var _this;
    _this = _EventDispatcher.call(this, null) || this;
    _this._componentsManager = new ComponentsManager();
    _this._hardwareRenderer = void 0;
    _this._lastRenderState = new RenderState$1();
    _this._renderCount = 0;
    _this._shaderProgramPools = [];
    _this._canvas = void 0;
    _this._resourceManager = new ResourceManager(_assertThisInitialized(_this));
    _this._sceneManager = new SceneManager(_assertThisInitialized(_this));
    _this._vSyncCount = 1;
    _this._targetFrameRate = 60;
    _this._time = new Time();
    _this._isPaused = true;
    _this._requestId = void 0;
    _this._timeoutId = void 0;
    _this._vSyncCounter = 1;
    _this._targetFrameInterval = 1e3 / 60;
    _this._animate = function() {
      if (_this._vSyncCount) {
        _this._requestId = requestAnimationFrame(_this._animate);
        if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
          _this.update();
          _this._vSyncCounter = 1;
        }
      } else {
        _this._timeoutId = window.setTimeout(_this._animate, _this._targetFrameInterval);
        _this.update();
      }
    };
    _this.features = [];
    _this._hardwareRenderer = hardwareRenderer;
    _this._hardwareRenderer.init(canvas);
    _this._canvas = canvas;
    engineFeatureManager.addObject(_assertThisInitialized(_this));
    _this._sceneManager.activeScene = new Scene(_assertThisInitialized(_this), "DefaultScene");
    return _this;
  }
  var _proto = Engine2.prototype;
  _proto.createEntity = function createEntity(name) {
    return new Entity(this, name);
  };
  _proto.pause = function pause() {
    this._isPaused = true;
    cancelAnimationFrame(this._requestId);
    clearTimeout(this._timeoutId);
  };
  _proto.resume = function resume() {
    if (!this._isPaused)
      return;
    this._isPaused = false;
    this.time.reset();
    requestAnimationFrame(this._animate);
  };
  _proto.update = function update() {
    var time = this._time;
    var deltaTime = time.deltaTime;
    time.tick();
    RenderElement._restPool();
    engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);
    var scene = this._sceneManager._activeScene;
    var componentsManager = this._componentsManager;
    if (scene) {
      componentsManager.callScriptOnStart();
      componentsManager.callScriptOnUpdate(deltaTime);
      componentsManager.callAnimationUpdate(deltaTime);
      componentsManager.callScriptOnLateUpdate(deltaTime);
      this._render(scene);
    }
    this._componentsManager.callComponentDestory();
    engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
  };
  _proto.run = function run() {
    engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
    this.resume();
    this.trigger(new Event("run", this));
  };
  _proto.destroy = function destroy() {
    if (this._sceneManager) {
      this.trigger(new Event("shutdown", this));
      engineFeatureManager.callFeatureMethod(this, "shutdown", [this]);
      this.pause();
      this._animate = null;
      this._sceneManager._activeScene.destroy();
      this._sceneManager = null;
      this._resourceManager.gc();
      this._resourceManager = null;
      this._canvas = null;
      this.features = [];
      this._time = null;
      engineFeatureManager._objects = [];
    }
  };
  _proto._getShaderProgramPool = function _getShaderProgramPool(shader) {
    var index = shader._shaderId;
    var shaderProgramPools = this._shaderProgramPools;
    var pool = shaderProgramPools[index];
    if (!pool) {
      var length = index + 1;
      if (length < shaderProgramPools.length) {
        shaderProgramPools.length = length;
      }
      shaderProgramPools[index] = pool = new ShaderProgramPool();
    }
    return pool;
  };
  _proto._render = function _render(scene) {
    var cameras = scene._activeCameras;
    var componentsManager = this._componentsManager;
    var deltaTime = this.time.deltaTime;
    componentsManager.callRendererOnUpdate(deltaTime);
    scene._updateShaderData();
    if (cameras.length > 0) {
      cameras.sort(function(camera1, camera2) {
        return camera1.priority - camera2.priority;
      });
      for (var i = 0, l = cameras.length; i < l; i++) {
        var camera = cameras[i];
        var cameraEntity = camera.entity;
        if (camera.enabled && cameraEntity.isActiveInHierarchy) {
          componentsManager.callCameraOnBeginRender(camera);
          Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [scene, camera]);
          camera.render();
          Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [scene, camera]);
          componentsManager.callCameraOnEndRender(camera);
        }
      }
    } else {
      Logger.debug("NO active camera.");
    }
  };
  _proto.findFeature = function findFeature(Feature) {
    return engineFeatureManager.findFeature(this, Feature);
  };
  Engine2.registerFeature = function registerFeature(Feature) {
    engineFeatureManager.registerFeature(Feature);
  };
  _createClass(Engine2, [{
    key: "canvas",
    get: function get4() {
      return this._canvas;
    }
  }, {
    key: "resourceManager",
    get: function get4() {
      return this._resourceManager;
    }
  }, {
    key: "sceneManager",
    get: function get4() {
      return this._sceneManager;
    }
  }, {
    key: "time",
    get: function get4() {
      return this._time;
    }
  }, {
    key: "isPaused",
    get: function get4() {
      return this._isPaused;
    }
  }, {
    key: "vSyncCount",
    get: function get4() {
      return this._vSyncCount;
    },
    set: function set4(value) {
      this._vSyncCount = Math.max(0, Math.floor(value));
    }
  }, {
    key: "targetFrameRate",
    get: function get4() {
      return this._targetFrameRate;
    },
    set: function set4(value) {
      value = Math.max(1e-6, value);
      this._targetFrameRate = value;
      this._targetFrameInterval = 1e3 / value;
    }
  }, {
    key: "renderhardware",
    get: function get4() {
      return this._hardwareRenderer;
    }
  }]);
  return Engine2;
}(EventDispatcher);
var SystemInfo = function() {
  function SystemInfo2() {
  }
  _createClass(SystemInfo2, null, [{
    key: "devicePixelRatio",
    get: function get4() {
      return window.devicePixelRatio;
    }
  }]);
  return SystemInfo2;
}();
var EngineFeature = function() {
  function EngineFeature2() {
  }
  var _proto = EngineFeature2.prototype;
  _proto.preLoad = function preLoad(engine) {
  };
  _proto.preTick = function preTick(engine, currentScene) {
  };
  _proto.postTick = function postTick(engine, currentScene) {
  };
  _proto.shutdown = function shutdown(engine) {
  };
  return EngineFeature2;
}();
var _class$4;
var _descriptor$4;
var _descriptor2$3;
var _descriptor3$2;
var _descriptor4$2;
var _descriptor5$1;
var _descriptor6$1;
var _temp$4;
var Script = (_class$4 = (_temp$4 = function(_Component) {
  _inheritsLoose(Script2, _Component);
  function Script2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _initializerDefineProperty(_this, "_started", _descriptor$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onStartIndex", _descriptor2$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onLateUpdateIndex", _descriptor4$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPreRenderIndex", _descriptor5$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onPostRenderIndex", _descriptor6$1, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = Script2.prototype;
  _proto.onAwake = function onAwake() {
  };
  _proto.onEnable = function onEnable() {
  };
  _proto.onStart = function onStart() {
  };
  _proto.onUpdate = function onUpdate(deltaTime) {
  };
  _proto.onLateUpdate = function onLateUpdate(deltaTime) {
  };
  _proto.onBeginRender = function onBeginRender(camera) {
  };
  _proto.onEndRender = function onEndRender(camera) {
  };
  _proto.onDisable = function onDisable() {
  };
  _proto.onDestroy = function onDestroy() {
  };
  _proto._onAwake = function _onAwake() {
    this.onAwake();
  };
  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    var prototype = Script2.prototype;
    if (!this._started) {
      componentsManager.addOnStartScript(this);
    }
    if (this.onUpdate !== prototype.onUpdate) {
      componentsManager.addOnUpdateScript(this);
    }
    if (this.onLateUpdate !== prototype.onLateUpdate) {
      componentsManager.addOnLateUpdateScript(this);
    }
    this.onEnable();
  };
  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;
    if (this._onStartIndex !== -1) {
      componentsManager.removeOnStartScript(this);
    }
    if (this._onUpdateIndex !== -1) {
      componentsManager.removeOnUpdateScript(this);
    }
    if (this._onLateUpdateIndex !== -1) {
      componentsManager.removeOnLateUpdateScript(this);
    }
    this.onDisable();
  };
  _proto._onDestroy = function _onDestroy() {
    this.engine._componentsManager.addDestoryComponent(this);
  };
  return Script2;
}(Component), _temp$4), _descriptor$4 = _applyDecoratedDescriptor(_class$4.prototype, "_started", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer19() {
    return false;
  }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class$4.prototype, "_onStartIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer20() {
    return -1;
  }
}), _descriptor3$2 = _applyDecoratedDescriptor(_class$4.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer21() {
    return -1;
  }
}), _descriptor4$2 = _applyDecoratedDescriptor(_class$4.prototype, "_onLateUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer22() {
    return -1;
  }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class$4.prototype, "_onPreRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer23() {
    return -1;
  }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class$4.prototype, "_onPostRenderIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer24() {
    return -1;
  }
}), _class$4);
var _class$5;
var _descriptor$5;
var _descriptor2$4;
var _descriptor3$3;
var _descriptor4$3;
var _descriptor5$2;
var _descriptor6$2;
var _descriptor7$1;
var _descriptor8$1;
var _descriptor9$1;
var _descriptor10$1;
var _descriptor11$1;
var _descriptor12$1;
var _class2$2;
var _temp$5;
var Renderer = (_class$5 = (_temp$5 = _class2$2 = function(_Component) {
  _inheritsLoose(Renderer2, _Component);
  function Renderer2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _initializerDefineProperty(_this, "shaderData", _descriptor$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "isCulled", _descriptor2$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor3$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_rendererIndex", _descriptor4$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_globalShaderMacro", _descriptor5$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_overrideUpdate", _descriptor6$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_transformChangeFlag", _descriptor7$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_bounds", _descriptor8$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvMatrix", _descriptor9$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvpMatrix", _descriptor10$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mvInvMatrix", _descriptor11$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_normalMatrix", _descriptor12$1, _assertThisInitialized(_this));
    var prototype = Renderer2.prototype;
    _this._overrideUpdate = _this.update !== prototype.update;
    _this._transformChangeFlag = _this.entity.transform.registerWorldChangeFlag();
    _this.shaderData._addRefCount(1);
    return _this;
  }
  var _proto = Renderer2.prototype;
  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    var worldMatrix = this.entity.transform.worldMatrix;
    var mvMatrix = this._mvMatrix;
    var mvpMatrix = this._mvpMatrix;
    var mvInvMatrix = this._mvInvMatrix;
    var normalMatrix = this._normalMatrix;
    Matrix.multiply(context._camera.viewMatrix, worldMatrix, mvMatrix);
    Matrix.multiply(context._viewProjectMatrix, worldMatrix, mvpMatrix);
    Matrix.invert(mvMatrix, mvInvMatrix);
    Matrix.invert(worldMatrix, normalMatrix);
    normalMatrix.transpose();
    shaderData.setMatrix(Renderer2._localMatrixProperty, this.entity.transform.localMatrix);
    shaderData.setMatrix(Renderer2._worldMatrixProperty, worldMatrix);
    shaderData.setMatrix(Renderer2._mvMatrixProperty, mvMatrix);
    shaderData.setMatrix(Renderer2._mvpMatrixProperty, mvpMatrix);
    shaderData.setMatrix(Renderer2._mvInvMatrixProperty, mvInvMatrix);
    shaderData.setMatrix(Renderer2._normalMatrixProperty, normalMatrix);
  };
  _proto._onDestroy = function _onDestroy() {
    var flag = this._transformChangeFlag;
    if (flag) {
      flag.destroy();
      this._transformChangeFlag = null;
    }
    this.shaderData._addRefCount(-1);
  };
  _proto.update = function update(deltaTime) {
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
  };
  _proto._onEnable = function _onEnable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.addOnUpdateRenderers(this);
    }
    componentsManager.addRenderer(this);
  };
  _proto._onDisable = function _onDisable() {
    var componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.removeOnUpdateRenderers(this);
    }
    componentsManager.removeRenderer(this);
  };
  _proto._render = function _render(camera) {
    this.render(camera);
  };
  _createClass(Renderer2, [{
    key: "bounds",
    get: function get4() {
      var changeFlag = this._transformChangeFlag;
      if (changeFlag.flag) {
        this._updateBounds(this._bounds);
        changeFlag.flag = false;
      }
      return this._bounds;
    }
  }]);
  return Renderer2;
}(Component), _class2$2._localMatrixProperty = Shader.getPropertyByName("u_localMat"), _class2$2._worldMatrixProperty = Shader.getPropertyByName("u_modelMat"), _class2$2._mvMatrixProperty = Shader.getPropertyByName("u_MVMat"), _class2$2._mvpMatrixProperty = Shader.getPropertyByName("u_MVPMat"), _class2$2._mvInvMatrixProperty = Shader.getPropertyByName("u_MVInvMat"), _class2$2._normalMatrixProperty = Shader.getPropertyByName("u_normalMat"), _temp$5), _descriptor$5 = _applyDecoratedDescriptor(_class$5.prototype, "shaderData", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer25() {
    return new ShaderData(ShaderDataGroup.Renderer);
  }
}), _descriptor2$4 = _applyDecoratedDescriptor(_class$5.prototype, "isCulled", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer26() {
    return false;
  }
}), _descriptor3$3 = _applyDecoratedDescriptor(_class$5.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer27() {
    return -1;
  }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class$5.prototype, "_rendererIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer28() {
    return -1;
  }
}), _descriptor5$2 = _applyDecoratedDescriptor(_class$5.prototype, "_globalShaderMacro", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer29() {
    return new ShaderMacroCollection();
  }
}), _descriptor6$2 = _applyDecoratedDescriptor(_class$5.prototype, "_overrideUpdate", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer30() {
    return false;
  }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class$5.prototype, "_transformChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor8$1 = _applyDecoratedDescriptor(_class$5.prototype, "_bounds", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer31() {
    return new BoundingBox(new Vector3(), new Vector3());
  }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class$5.prototype, "_mvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer32() {
    return new Matrix();
  }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class$5.prototype, "_mvpMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer33() {
    return new Matrix();
  }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class$5.prototype, "_mvInvMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer34() {
    return new Matrix();
  }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class$5.prototype, "_normalMatrix", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer35() {
    return new Matrix();
  }
}), _class$5);
var AlphaMode;
(function(AlphaMode2) {
  AlphaMode2[AlphaMode2["Opaque"] = 0] = "Opaque";
  AlphaMode2[AlphaMode2["Blend"] = 1] = "Blend";
  AlphaMode2[AlphaMode2["CutOff"] = 2] = "CutOff";
})(AlphaMode || (AlphaMode = {}));
var Material = function(_RefObject) {
  _inheritsLoose(Material2, _RefObject);
  function Material2(engine, shader) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this.shader = void 0;
    _this.renderQueueType = RenderQueueType.Opaque;
    _this.shaderData = new ShaderData(ShaderDataGroup.Material);
    _this.renderState = new RenderState$1();
    _this.shader = shader;
    return _this;
  }
  var _proto = Material2.prototype;
  _proto.clone = function clone2() {
    var dest = new Material2(this._engine, this.shader);
    this.cloneTo(dest);
    return dest;
  };
  _proto.cloneTo = function cloneTo(target) {
    target.shader = this.shader;
    target.renderQueueType = this.renderQueueType;
    this.shaderData.cloneTo(target.shaderData);
    CloneManager.deepCloneObject(this.renderState, target.renderState);
  };
  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);
    this.shaderData._addRefCount(value);
  };
  _proto._preRender = function _preRender(renderElement) {
  };
  _proto._onDestroy = function _onDestroy() {
  };
  return Material2;
}(RefObject);
var BlinnPhongMaterial = function(_Material) {
  _inheritsLoose(BlinnPhongMaterial2, _Material);
  function BlinnPhongMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("blinn-phong")) || this;
    _this._emissiveColor = new Color(0, 0, 0, 1);
    _this._diffuseColor = new Color(1, 1, 1, 1);
    _this._specularColor = new Color(1, 1, 1, 1);
    _this._emissiveTexture = void 0;
    _this._diffuseTexture = void 0;
    _this._specularTexture = void 0;
    _this._shininess = 16;
    _this._alphaMode = AlphaMode.Opaque;
    _this._doubleSided = false;
    _this.shaderData.enableMacro("O3_NEED_WORLDPOS");
    _this.emissiveColor = _this._emissiveColor;
    _this.diffuseColor = _this._diffuseColor;
    _this.specularColor = _this._specularColor;
    _this.shininess = _this._shininess;
    return _this;
  }
  var _proto = BlinnPhongMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new BlinnPhongMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(BlinnPhongMaterial2, [{
    key: "emissiveColor",
    get: function get4() {
      return this._emissiveColor;
    },
    set: function set4(value) {
      this._emissiveColor = value;
      this.shaderData.setColor("u_emissiveColor", value);
    }
  }, {
    key: "emissiveTexture",
    get: function get4() {
      return this._emissiveTexture;
    },
    set: function set4(value) {
      this._emissiveTexture = value;
      if (value) {
        this.shaderData.enableMacro("O3_EMISSIVE_TEXTURE");
        this.shaderData.setTexture("u_emissiveTexture", value);
      } else {
        this.shaderData.disableMacro("O3_EMISSIVE_TEXTURE");
      }
    }
  }, {
    key: "diffuseColor",
    get: function get4() {
      return this._diffuseColor;
    },
    set: function set4(value) {
      this._diffuseColor = value;
      this.shaderData.setColor("u_diffuseColor", value);
    }
  }, {
    key: "diffuseTexture",
    get: function get4() {
      return this._diffuseTexture;
    },
    set: function set4(value) {
      this._diffuseTexture = value;
      if (value) {
        this.shaderData.enableMacro("O3_DIFFUSE_TEXTURE");
        this.shaderData.setTexture("u_diffuseTexture", value);
      } else {
        this.shaderData.disableMacro("O3_DIFFUSE_TEXTURE");
      }
    }
  }, {
    key: "specularColor",
    get: function get4() {
      return this._specularColor;
    },
    set: function set4(value) {
      this._specularColor = value;
      this.shaderData.setColor("u_specularColor", value);
    }
  }, {
    key: "specularTexture",
    get: function get4() {
      return this._specularTexture;
    },
    set: function set4(value) {
      this._specularTexture = value;
      if (value) {
        this.shaderData.enableMacro("O3_SPECULAR_TEXTURE");
        this.shaderData.setTexture("u_specularTexture", value);
      } else {
        this.shaderData.disableMacro("O3_SPECULAR_TEXTURE");
      }
    }
  }, {
    key: "shininess",
    get: function get4() {
      return this._shininess;
    },
    set: function set4(value) {
      this._shininess = value;
      this.shaderData.setFloat("u_shininess", value);
    }
  }, {
    key: "alphaMode",
    get: function get4() {
      return this._alphaMode;
    },
    set: function set4(v) {
      var target = this.renderState.blendState.targetBlendState;
      var depthState = this.renderState.depthState;
      switch (v) {
        case AlphaMode.Opaque:
        case AlphaMode.CutOff:
          {
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.One;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.Zero;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = true;
            this.renderQueueType = RenderQueueType.Opaque;
          }
          break;
        case AlphaMode.Blend:
          {
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = false;
            this.renderQueueType = RenderQueueType.Transparent;
          }
          break;
      }
    }
  }, {
    key: "doubleSided",
    get: function get4() {
      return this._doubleSided;
    },
    set: function set4(v) {
      if (v) {
        this.renderState.rasterState.cullMode = CullMode.Off;
      } else {
        this.renderState.rasterState.cullMode = CullMode.Back;
      }
    }
  }]);
  return BlinnPhongMaterial2;
}(Material);
var PBRBaseMaterial = function(_Material) {
  _inheritsLoose(PBRBaseMaterial2, _Material);
  function PBRBaseMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("pbr")) || this;
    _this._baseColor = new Color(1, 1, 1, 1);
    _this._normalScale = 1;
    _this._emissiveColor = new Color(0, 0, 0, 1);
    _this._occlusionStrength = 1;
    _this._alphaCutoff = 0.5;
    _this._envMapIntensity = 1;
    _this._refractionRatio = 1 / 1.33;
    _this._refractionDepth = 1;
    _this._perturbationUOffset = 0;
    _this._perturbationVOffset = 0;
    _this._PTMMatrix = new Matrix(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
    _this._baseColorTexture = void 0;
    _this._opacityTexture = void 0;
    _this._normalTexture = void 0;
    _this._emissiveTexture = void 0;
    _this._occlusionTexture = void 0;
    _this._reflectionTexture = void 0;
    _this._refractionTexture = void 0;
    _this._perturbationTexture = void 0;
    _this._srgb = false;
    _this._srgbFast = false;
    _this._gamma = false;
    _this._getOpacityFromRGB = false;
    _this._envMapModeRefract = false;
    _this._alphaMode = AlphaMode.Opaque;
    _this._doubleSided = false;
    _this.shaderData.enableMacro("O3_NEED_WORLDPOS");
    _this.baseColor = _this._baseColor;
    _this.normalScale = _this._normalScale;
    _this.emissiveColor = _this._emissiveColor;
    _this.occlusionStrength = _this._occlusionStrength;
    _this.alphaCutoff = _this._alphaCutoff;
    _this.envMapIntensity = _this._envMapIntensity;
    _this.refractionRatio = _this._refractionRatio;
    _this.refractionDepth = _this._refractionDepth;
    _this.perturbationUOffset = _this._perturbationUOffset;
    _this.perturbationVOffset = _this._perturbationVOffset;
    _this.srgb = _this._srgb;
    _this.srgbFast = _this._srgbFast;
    _this.gamma = _this._gamma;
    _this.getOpacityFromRGB = _this._getOpacityFromRGB;
    _this.envMapModeRefract = _this._envMapModeRefract;
    _this.alphaMode = _this._alphaMode;
    return _this;
  }
  _createClass(PBRBaseMaterial2, [{
    key: "baseColor",
    get: function get4() {
      return this._baseColor;
    },
    set: function set4(v) {
      this._baseColor = v;
      this.shaderData.setColor("u_baseColorFactor", v);
    }
  }, {
    key: "baseColorTexture",
    get: function get4() {
      return this._baseColorTexture;
    },
    set: function set4(v) {
      this._baseColorTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_BASECOLORMAP");
        this.shaderData.setTexture("u_baseColorSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_BASECOLORMAP");
      }
    }
  }, {
    key: "opacity",
    get: function get4() {
      return this.baseColor.a;
    },
    set: function set4(val) {
      this.baseColor.a = val;
    }
  }, {
    key: "opacityTexture",
    get: function get4() {
      return this._opacityTexture;
    },
    set: function set4(v) {
      this._opacityTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_OPACITYMAP");
        this.shaderData.setTexture("u_opacitySampler", v);
      } else {
        this.shaderData.disableMacro("HAS_OPACITYMAP");
      }
    }
  }, {
    key: "normalTexture",
    get: function get4() {
      return this._normalTexture;
    },
    set: function set4(v) {
      this._normalTexture = v;
      if (v) {
        this.shaderData.enableMacro("O3_HAS_NORMALMAP");
        this.shaderData.setTexture("u_normalSampler", v);
      } else {
        this.shaderData.disableMacro("O3_HAS_NORMALMAP");
      }
    }
  }, {
    key: "normalScale",
    get: function get4() {
      return this._normalScale;
    },
    set: function set4(v) {
      this._normalScale = v;
      this.shaderData.setFloat("u_normalScale", v);
    }
  }, {
    key: "emissiveTexture",
    get: function get4() {
      return this._emissiveTexture;
    },
    set: function set4(v) {
      this._emissiveTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_EMISSIVEMAP");
        this.shaderData.setTexture("u_emissiveSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_EMISSIVEMAP");
      }
    }
  }, {
    key: "emissiveColor",
    get: function get4() {
      return this._emissiveColor;
    },
    set: function set4(v) {
      this._emissiveColor = v;
      this.shaderData.setColor("u_emissiveFactor", v);
    }
  }, {
    key: "occlusionTexture",
    get: function get4() {
      return this._occlusionTexture;
    },
    set: function set4(v) {
      this._occlusionTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_OCCLUSIONMAP");
        this.shaderData.setTexture("u_occlusionSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_OCCLUSIONMAP");
      }
    }
  }, {
    key: "occlusionStrength",
    get: function get4() {
      return this._occlusionStrength;
    },
    set: function set4(v) {
      this._occlusionStrength = v;
      this.shaderData.setFloat("u_occlusionStrength", v);
    }
  }, {
    key: "alphaCutoff",
    get: function get4() {
      return this._alphaCutoff;
    },
    set: function set4(v) {
      this._alphaCutoff = v;
      this.shaderData.setFloat("u_alphaCutoff", v);
    }
  }, {
    key: "reflectionTexture",
    get: function get4() {
      return this._reflectionTexture;
    },
    set: function set4(v) {
      this._reflectionTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_REFLECTIONMAP");
        this.shaderData.setTexture("u_reflectionSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_REFLECTIONMAP");
      }
    }
  }, {
    key: "envMapIntensity",
    get: function get4() {
      return this._envMapIntensity;
    },
    set: function set4(v) {
      this._envMapIntensity = v;
      this.shaderData.setFloat("u_envMapIntensity", v);
    }
  }, {
    key: "refractionRatio",
    get: function get4() {
      return this._refractionRatio;
    },
    set: function set4(v) {
      this._refractionRatio = v;
      this.shaderData.setFloat("u_refractionRatio", v);
    }
  }, {
    key: "refractionDepth",
    get: function get4() {
      return this._refractionDepth;
    },
    set: function set4(v) {
      this._refractionDepth = v;
      this.shaderData.setFloat("u_refractionDepth", v);
    }
  }, {
    key: "refractionTexture",
    get: function get4() {
      return this._refractionTexture;
    },
    set: function set4(v) {
      this._refractionTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_REFRACTIONMAP");
        this.shaderData.setTexture("u_refractionSampler", v);
        this.shaderData.setMatrix("u_PTMMatrix", this._PTMMatrix);
      } else {
        this.shaderData.disableMacro("HAS_REFRACTIONMAP");
      }
    }
  }, {
    key: "perturbationTexture",
    get: function get4() {
      return this._perturbationTexture;
    },
    set: function set4(v) {
      this._perturbationTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_PERTURBATIONMAP");
        this.shaderData.setTexture("u_perturbationSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_PERTURBATIONMAP");
      }
    }
  }, {
    key: "perturbationUOffset",
    get: function get4() {
      return this._perturbationUOffset;
    },
    set: function set4(v) {
      this._perturbationUOffset = v;
      this.shaderData.setFloat("u_perturbationUOffset", v);
    }
  }, {
    key: "perturbationVOffset",
    get: function get4() {
      return this._perturbationVOffset;
    },
    set: function set4(v) {
      this._perturbationVOffset = v;
      this.shaderData.setFloat("u_perturbationVOffset", v);
    }
  }, {
    key: "srgb",
    get: function get4() {
      return this._srgb;
    },
    set: function set4(v) {
      this._srgb = v;
      if (v) {
        this.shaderData.enableMacro("MANUAL_SRGB");
      } else {
        this.shaderData.disableMacro("MANUAL_SRGB");
      }
    }
  }, {
    key: "srgbFast",
    get: function get4() {
      return this._srgbFast;
    },
    set: function set4(v) {
      this._srgbFast = v;
      if (v) {
        this.shaderData.enableMacro("SRGB_FAST_APPROXIMATION");
      } else {
        this.shaderData.disableMacro("SRGB_FAST_APPROXIMATION");
      }
    }
  }, {
    key: "gamma",
    get: function get4() {
      return this._gamma;
    },
    set: function set4(v) {
      this._gamma = v;
      if (v) {
        this.shaderData.enableMacro("GAMMA");
      } else {
        this.shaderData.disableMacro("GAMMA");
      }
    }
  }, {
    key: "getOpacityFromRGB",
    get: function get4() {
      return this._getOpacityFromRGB;
    },
    set: function set4(v) {
      this._getOpacityFromRGB = v;
      if (v) {
        this.shaderData.enableMacro("GETOPACITYFROMRGB");
      } else {
        this.shaderData.disableMacro("GETOPACITYFROMRGB");
      }
    }
  }, {
    key: "envMapModeRefract",
    get: function get4() {
      return this._envMapModeRefract;
    },
    set: function set4(v) {
      this._envMapModeRefract = v;
      if (v) {
        this.shaderData.enableMacro("ENVMAPMODE_REFRACT");
      } else {
        this.shaderData.disableMacro("ENVMAPMODE_REFRACT");
      }
    }
  }, {
    key: "alphaMode",
    get: function get4() {
      return this._alphaMode;
    },
    set: function set4(v) {
      var target = this.renderState.blendState.targetBlendState;
      var depthState = this.renderState.depthState;
      this.shaderData.disableMacro("ALPHA_CUTOFF");
      this.shaderData.disableMacro("ALPHA_BLEND");
      switch (v) {
        case AlphaMode.Opaque:
          {
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.One;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.Zero;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = true;
            this.renderQueueType = RenderQueueType.Opaque;
          }
          break;
        case AlphaMode.Blend:
          {
            this.shaderData.enableMacro("ALPHA_BLEND");
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = false;
            this.renderQueueType = RenderQueueType.Transparent;
          }
          break;
        case AlphaMode.CutOff:
          {
            this.shaderData.enableMacro("ALPHA_CUTOFF");
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.One;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.Zero;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = true;
            this.renderQueueType = RenderQueueType.AlphaTest;
          }
          break;
      }
    }
  }, {
    key: "doubleSided",
    get: function get4() {
      return this._doubleSided;
    },
    set: function set4(v) {
      if (v) {
        this.renderState.rasterState.cullMode = CullMode.Off;
      } else {
        this.renderState.rasterState.cullMode = CullMode.Back;
      }
    }
  }]);
  return PBRBaseMaterial2;
}(Material);
var PBRMaterial = function(_PBRBaseMaterial) {
  _inheritsLoose(PBRMaterial2, _PBRBaseMaterial);
  function PBRMaterial2(engine) {
    var _this;
    _this = _PBRBaseMaterial.call(this, engine) || this;
    _this._metallicFactor = 1;
    _this._roughnessFactor = 1;
    _this._metallicTexture = void 0;
    _this._roughnessTexture = void 0;
    _this._metallicRoughnessTexture = void 0;
    _this.shaderData.enableMacro("IS_METALLIC_WORKFLOW");
    _this.metallicFactor = _this._metallicFactor;
    _this.roughnessFactor = _this._roughnessFactor;
    return _this;
  }
  var _proto = PBRMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new PBRMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(PBRMaterial2, [{
    key: "metallicFactor",
    get: function get4() {
      return this._metallicFactor;
    },
    set: function set4(v) {
      this._metallicFactor = v;
      this.shaderData.setFloat("u_metal", v);
    }
  }, {
    key: "roughnessFactor",
    get: function get4() {
      return this._roughnessFactor;
    },
    set: function set4(v) {
      this._roughnessFactor = v;
      this.shaderData.setFloat("u_roughness", v);
    }
  }, {
    key: "metallicTexture",
    get: function get4() {
      return this._metallicTexture;
    },
    set: function set4(v) {
      this._metallicTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_METALMAP");
        this.shaderData.setTexture("u_metallicSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_METALMAP");
      }
    }
  }, {
    key: "roughnessTexture",
    get: function get4() {
      return this._roughnessTexture;
    },
    set: function set4(v) {
      this._roughnessTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_ROUGHNESSMAP");
        this.shaderData.setTexture("u_roughnessSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_ROUGHNESSMAP");
      }
    }
  }, {
    key: "metallicRoughnessTexture",
    get: function get4() {
      return this._metallicRoughnessTexture;
    },
    set: function set4(v) {
      this._metallicRoughnessTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_METALROUGHNESSMAP");
        this.shaderData.setTexture("u_metallicRoughnessSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_METALROUGHNESSMAP");
      }
    }
  }]);
  return PBRMaterial2;
}(PBRBaseMaterial);
var PBRSpecularMaterial = function(_PBRBaseMaterial) {
  _inheritsLoose(PBRSpecularMaterial2, _PBRBaseMaterial);
  function PBRSpecularMaterial2(engine) {
    var _this;
    _this = _PBRBaseMaterial.call(this, engine) || this;
    _this._specularColor = new Color(1, 1, 1, 1);
    _this._glossinessFactor = 1;
    _this._specularGlossinessTexture = void 0;
    _this.specularColor = _this._specularColor;
    _this.glossinessFactor = _this._glossinessFactor;
    return _this;
  }
  var _proto = PBRSpecularMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new PBRSpecularMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(PBRSpecularMaterial2, [{
    key: "specularColor",
    get: function get4() {
      return this._specularColor;
    },
    set: function set4(v) {
      this._specularColor = v;
      this.shaderData.setColor("u_specularFactor", v);
    }
  }, {
    key: "glossinessFactor",
    get: function get4() {
      return this._glossinessFactor;
    },
    set: function set4(v) {
      this._glossinessFactor = v;
      this.shaderData.setFloat("u_glossinessFactor", v);
    }
  }, {
    key: "specularGlossinessTexture",
    get: function get4() {
      return this._specularGlossinessTexture;
    },
    set: function set4(v) {
      this._specularGlossinessTexture = v;
      if (v) {
        this.shaderData.enableMacro("HAS_SPECULARGLOSSINESSMAP");
        this.shaderData.setTexture("u_specularGlossinessSampler", v);
      } else {
        this.shaderData.disableMacro("HAS_SPECULARGLOSSINESSMAP");
      }
    }
  }]);
  return PBRSpecularMaterial2;
}(PBRBaseMaterial);
var UnlitMaterial = function(_Material) {
  _inheritsLoose(UnlitMaterial2, _Material);
  function UnlitMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("unlit")) || this;
    _this._baseColor = new Color(1, 1, 1, 1);
    _this._baseColorTexture = void 0;
    _this._alphaMode = AlphaMode.Opaque;
    _this._doubleSided = false;
    _this.shaderData.enableMacro("OMIT_NORMAL");
    _this.baseColor = _this._baseColor;
    return _this;
  }
  var _proto = UnlitMaterial2.prototype;
  _proto.clone = function clone2() {
    var dest = new UnlitMaterial2(this._engine);
    this.cloneTo(dest);
    return dest;
  };
  _createClass(UnlitMaterial2, [{
    key: "baseColor",
    get: function get4() {
      return this._baseColor;
    },
    set: function set4(value) {
      this._baseColor = value;
      this.shaderData.setColor("u_baseColor", value);
    }
  }, {
    key: "baseColorTexture",
    get: function get4() {
      return this._baseColorTexture;
    },
    set: function set4(value) {
      this._baseColorTexture = value;
      if (value) {
        this.shaderData.enableMacro("O3_BASECOLOR_TEXTURE");
        this.shaderData.setTexture("u_baseColorTexture", value);
      } else {
        this.shaderData.disableMacro("O3_BASECOLOR_TEXTURE");
      }
    }
  }, {
    key: "alphaMode",
    get: function get4() {
      return this._alphaMode;
    },
    set: function set4(v) {
      var target = this.renderState.blendState.targetBlendState;
      var depthState = this.renderState.depthState;
      switch (v) {
        case AlphaMode.Opaque:
        case AlphaMode.CutOff:
          {
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.One;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.Zero;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = true;
            this.renderQueueType = RenderQueueType.Opaque;
          }
          break;
        case AlphaMode.Blend:
          {
            target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
            target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
            target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
            depthState.writeEnabled = false;
            this.renderQueueType = RenderQueueType.Transparent;
          }
          break;
      }
    }
  }, {
    key: "doubleSided",
    get: function get4() {
      return this._doubleSided;
    },
    set: function set4(v) {
      if (v) {
        this.renderState.rasterState.cullMode = CullMode.Off;
      } else {
        this.renderState.rasterState.cullMode = CullMode.Back;
      }
    }
  }]);
  return UnlitMaterial2;
}(Material);
var passNum = 0;
var RenderPass = function() {
  function RenderPass2(name, priority, renderTarget, replaceMaterial, mask, clearParam) {
    if (name === void 0) {
      name = "RENDER_PASS" + passNum++;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }
    if (mask === void 0) {
      mask = null;
    }
    if (clearParam === void 0) {
      clearParam = new Vector4(0, 0, 0, 0);
    }
    this.name = void 0;
    this.enabled = void 0;
    this.priority = void 0;
    this.renderTarget = void 0;
    this.replaceMaterial = void 0;
    this.mask = void 0;
    this.renderOverride = void 0;
    this.clearMode = void 0;
    this._clearParam = void 0;
    this.name = name;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || Layer.Everything;
    this.renderOverride = false;
    this.clearMode = ClearMode.SOLID_COLOR;
    this._clearParam = clearParam;
  }
  var _proto = RenderPass2.prototype;
  _proto.render = function render(camera, queue) {
  };
  _proto.preRender = function preRender(camera, queue) {
  };
  _proto.postRender = function postRender(camera, queue) {
  };
  _createClass(RenderPass2, [{
    key: "clearParam",
    get: function get4() {
      return this._clearParam;
    },
    set: function set4(v) {
      this._clearParam = v;
    }
  }]);
  return RenderPass2;
}();
var SeparateSpritePass = function(_RenderPass) {
  _inheritsLoose(SeparateSpritePass2, _RenderPass);
  function SeparateSpritePass2(name, priority) {
    var _this;
    if (name === void 0) {
      name = "SeparateSprite";
    }
    if (priority === void 0) {
      priority = 10;
    }
    _this = _RenderPass.call(this, name, priority) || this;
    _this._spriteItems = void 0;
    _this.clearMode = ClearMode.DONT_CLEAR;
    _this.renderOverride = true;
    _this._spriteItems = [];
    return _this;
  }
  var _proto = SeparateSpritePass2.prototype;
  _proto.preRender = function preRender() {
    this.enabled = this.isUsed;
  };
  _proto.render = function render(camera) {
    var rhi = camera.renderHardware;
    this._sortByDistance(camera.eyePos);
    var items = this._spriteItems;
    var material = camera._renderPipeline._defaultSpriteMaterial;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      rhi.drawSprite(material, item.positionQuad, item.uvRect, item.tintColor, item.texture, item.renderMode, item.camera);
    }
    items.length = 0;
  };
  _proto.postRender = function postRender(camera) {
    if (this.enabled) {
      camera.renderHardware.flushSprite(camera.engine, camera._hardwareRenderer._defaultSpriteMaterial);
    }
  };
  _proto._sortByDistance = function _sortByDistance(eyePos) {
    if (this._spriteItems.length > 1) {
      this._spriteItems = this._spriteItems.sort(function(item1, item2) {
        if (item1.component.renderPriority === item2.component.renderPriority) {
          var pos1 = item1.component.node.worldPosition;
          var pos2 = item2.component.node.worldPosition;
          var dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);
          return dis;
        } else {
          return item1.component.renderPriority - item2.component.renderPriority;
        }
      });
    }
  };
  _proto.pushSprite = function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    this._spriteItems.push({
      component,
      positionQuad,
      uvRect,
      tintColor,
      texture,
      renderMode,
      camera
    });
  };
  _createClass(SeparateSpritePass2, [{
    key: "isUsed",
    get: function get4() {
      return this._spriteItems.length > 0;
    }
  }]);
  return SeparateSpritePass2;
}(RenderPass);
var BasicRenderPipeline = function() {
  function BasicRenderPipeline2(camera) {
    this._defaultSpriteMaterial = void 0;
    this._camera = void 0;
    this._queue = void 0;
    this._defaultPass = void 0;
    this._renderPassArray = void 0;
    this._canvasDepthPass = void 0;
    this._separateSpritePass = void 0;
    this._camera = camera;
    this._queue = new RenderQueue();
    this._renderPassArray = [];
    this._defaultPass = new RenderPass("default", 0, null, null, 0);
    this.addRenderPass(this._defaultPass);
    var material = this._defaultSpriteMaterial = new Material(camera.engine, Shader.find("Sprite"));
    var target = material.renderState.blendState.targetBlendState;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
    material.renderState.depthState.writeEnabled = false;
    material.renderQueueType = RenderQueueType.Transparent;
    material.renderState.rasterState.cullMode = CullMode.Off;
  }
  var _proto = BasicRenderPipeline2.prototype;
  _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask, clearParam) {
    if (priority === void 0) {
      priority = null;
    }
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    if (replaceMaterial === void 0) {
      replaceMaterial = null;
    }
    if (mask === void 0) {
      mask = null;
    }
    if (clearParam === void 0) {
      clearParam = new Vector4(0, 0, 0, 0);
    }
    if (typeof nameOrPass === "string") {
      var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask, clearParam);
      this._renderPassArray.push(renderPass);
    } else if (nameOrPass instanceof RenderPass) {
      this._renderPassArray.push(nameOrPass);
    }
    this._renderPassArray.sort(function(p1, p2) {
      return p1.priority - p2.priority;
    });
  };
  _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
    var pass;
    if (typeof nameOrPass === "string")
      pass = this.getRenderPass(nameOrPass);
    else if (nameOrPass instanceof RenderPass)
      pass = nameOrPass;
    if (pass) {
      var idx = this._renderPassArray.indexOf(pass);
      this._renderPassArray.splice(idx, 1);
    }
  };
  _proto.getRenderPass = function getRenderPass(name) {
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      var pass = this._renderPassArray[i];
      if (pass.name === name)
        return pass;
    }
    return null;
  };
  _proto.destroy = function destroy() {
  };
  _proto.render = function render(context, cubeFace) {
    var camera = this._camera;
    var queue = this._queue;
    queue.clear();
    camera.engine._componentsManager.callRender(context);
    queue.sort(camera.entity.transform.worldPosition);
    if (this._canvasDepthPass)
      this._canvasDepthPass.enabled = false;
    if (this._separateSpritePass && this._separateSpritePass.isUsed) {
      if (this._defaultPass.renderTarget) {
        if (!this._canvasDepthPass) {
          this._canvasDepthPass = new RenderPass("CanvasDepthRenderPass", 0, null, null, 0);
          this._canvasDepthPass.clearMode = ClearMode.DONT_CLEAR;
          this.addRenderPass(this._canvasDepthPass);
        }
        this._canvasDepthPass.enabled = true;
      }
    }
    for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
      this._drawRenderPass(this._renderPassArray[i], camera, cubeFace);
    }
  };
  _proto._drawRenderPass = function _drawRenderPass(pass, camera, cubeFace) {
    pass.preRender(camera, this.queue);
    if (pass.enabled) {
      var rhi = camera.scene.engine._hardwareRenderer;
      var renderTarget = camera.renderTarget || pass.renderTarget;
      rhi.activeRenderTarget(renderTarget, camera);
      rhi.setRenderTargetFace(renderTarget, cubeFace);
      rhi.clearRenderTarget(camera.engine, pass.clearMode, pass.clearParam);
      if (pass.renderOverride) {
        pass.render(camera, this.queue);
      } else {
        this.queue.render(camera, pass.replaceMaterial, pass.mask);
      }
      rhi.blitRenderTarget(renderTarget);
    }
    pass.postRender(camera, this.queue);
  };
  _proto.pushPrimitive = function pushPrimitive(element) {
    this._queue.pushPrimitive(element);
  };
  _proto.pushSprite = function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    if (component.separateDraw) {
      if (!this._separateSpritePass) {
        this._separateSpritePass = new SeparateSpritePass();
        this.addRenderPass(this._separateSpritePass);
      }
      this._separateSpritePass.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);
      return;
    }
    this.queue.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);
  };
  _createClass(BasicRenderPipeline2, [{
    key: "defaultRenderPass",
    get: function get4() {
      return this._defaultPass;
    }
  }, {
    key: "queue",
    get: function get4() {
      return this._queue;
    }
  }]);
  return BasicRenderPipeline2;
}();
var RenderContext = function() {
  function RenderContext2() {
    this._camera = void 0;
    this._viewProjectMatrix = new Matrix();
  }
  RenderContext2._getRenderContext = function _getRenderContext(camera) {
    var context = RenderContext2._renderContext;
    context._camera = camera;
    Matrix.multiply(camera.projectionMatrix, camera.viewMatrix, context._viewProjectMatrix);
    return context;
  };
  return RenderContext2;
}();
RenderContext._renderContext = new RenderContext();
var _dec;
var _class$6;
var _class2$3;
var _descriptor$6;
var _descriptor2$5;
var _descriptor3$4;
var _descriptor4$4;
var _descriptor5$3;
var _descriptor6$3;
var _descriptor7$2;
var _descriptor8$2;
var _descriptor9$2;
var _descriptor10$2;
var _descriptor11$2;
var _descriptor12$2;
var _descriptor13$1;
var _descriptor14;
var _class3;
var _temp$6;
var MathTemp = function MathTemp2() {
};
MathTemp.tempMat4 = new Matrix();
MathTemp.tempVec4 = new Vector4();
MathTemp.tempVec3 = new Vector3();
var ClearFlags;
(function(ClearFlags2) {
  ClearFlags2[ClearFlags2["DepthSky"] = 0] = "DepthSky";
  ClearFlags2[ClearFlags2["DepthColor"] = 1] = "DepthColor";
  ClearFlags2[ClearFlags2["Depth"] = 2] = "Depth";
  ClearFlags2[ClearFlags2["None"] = 3] = "None";
})(ClearFlags || (ClearFlags = {}));
var Camera = (_dec = dependencies(Transform), _dec(_class$6 = (_class2$3 = (_temp$6 = _class3 = function(_Component) {
  _inheritsLoose(Camera2, _Component);
  function Camera2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this.priority = 0;
    _this.enableFrustumCulling = true;
    _this.cullingMask = Layer.Everything;
    _this.shaderData = new ShaderData(ShaderDataGroup.Camera);
    _this._globalShaderMacro = new ShaderMacroCollection();
    _initializerDefineProperty(_this, "_frustum", _descriptor$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_renderPipeline", _descriptor2$5, _assertThisInitialized(_this));
    _this._isOrthographic = false;
    _this._isProjMatSetting = false;
    _this._clearMode = ClearMode.SOLID_COLOR;
    _this._nearClipPlane = 0.1;
    _this._farClipPlane = 100;
    _this._fieldOfView = 45;
    _this._orthographicSize = 10;
    _this._isProjectionDirty = true;
    _this._isInvProjMatDirty = true;
    _this._isFrustumProjectDirty = true;
    _this._customAspectRatio = void 0;
    _this._renderTarget = null;
    _initializerDefineProperty(_this, "_frustumViewChangeFlag", _descriptor3$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_transform", _descriptor4$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isViewMatrixDirty", _descriptor5$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_isInvViewProjDirty", _descriptor6$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_projectionMatrix", _descriptor7$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_viewMatrix", _descriptor8$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_backgroundColor", _descriptor9$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_viewport", _descriptor10$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_inverseProjectionMatrix", _descriptor11$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_inverseViewMatrix", _descriptor12$2, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_lastAspectSize", _descriptor13$1, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_invViewProjMat", _descriptor14, _assertThisInitialized(_this));
    var transform = _this.entity.transform;
    _this._transform = transform;
    _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
    _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
    _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
    _this._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this));
    _this.shaderData._addRefCount(1);
    _this.setClearMode();
    return _this;
  }
  var _proto = Camera2.prototype;
  _proto.resetProjectionMatrix = function resetProjectionMatrix() {
    this._isProjMatSetting = false;
    this._projMatChange();
  };
  _proto.resetAspectRatio = function resetAspectRatio() {
    this._customAspectRatio = void 0;
    this._projMatChange();
  };
  _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
    Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);
    MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1);
    Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);
    var w = MathTemp.tempVec4.w;
    var nx = MathTemp.tempVec4.x / w;
    var ny = MathTemp.tempVec4.y / w;
    var nz = MathTemp.tempVec4.z / w;
    out.x = (nx + 1) * 0.5;
    out.y = (1 - ny) * 0.5;
    out.z = nz;
    out.w = w;
    return out;
  };
  _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
    var invViewProjMat = this.invViewProjMat;
    return this._innerViewportToWorldPoint(point, invViewProjMat, out);
  };
  _proto.viewportPointToRay = function viewportPointToRay(point, out) {
    var clipPoint = MathTemp.tempVec3;
    clipPoint.setValue(point.x, point.y, 0);
    var origin = this.viewportToWorldPoint(clipPoint, out.origin);
    clipPoint.z = 1;
    var farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);
    Vector3.subtract(farPoint, origin, out.direction);
    out.direction.normalize();
    return out;
  };
  _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (point.x / canvas.width - viewport.x) / viewport.z;
    out.y = (point.y / canvas.height - viewport.y) / viewport.w;
    return out;
  };
  _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
    var canvas = this.engine.canvas;
    var viewport = this.viewport;
    out.x = (viewport.x + point.x * viewport.z) * canvas.width;
    out.y = (viewport.y + point.y * viewport.w) * canvas.height;
    return out;
  };
  _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
    this.worldToViewportPoint(point, out);
    return this.viewportToScreenPoint(out, out);
  };
  _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
    this.screenToViewportPoint(point, out);
    return this.viewportToWorldPoint(out, out);
  };
  _proto.render = function render(cubeFace) {
    var context = RenderContext._getRenderContext(this);
    if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
      this._frustum.calculateFromMatrix(context._viewProjectMatrix);
      this._frustumViewChangeFlag.flag = false;
      this._isFrustumProjectDirty = false;
    }
    this._updateShaderData(context);
    ShaderMacroCollection.unionCollection(this.scene.shaderData._macroCollection, this.shaderData._macroCollection, this._globalShaderMacro);
    this._renderPipeline.render(context, cubeFace);
    this._engine._renderCount++;
  };
  _proto._onActive = function _onActive() {
    this.entity.scene.attachRenderCamera(this);
  };
  _proto._onInActive = function _onInActive() {
    this.entity.scene.detachRenderCamera(this);
  };
  _proto._onDestroy = function _onDestroy() {
    var _this$_renderPipeline;
    (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();
    this._isInvViewProjDirty.destroy();
    this._isViewMatrixDirty.destroy();
    this.shaderData._addRefCount(-1);
  };
  _proto._projMatChange = function _projMatChange() {
    this._isFrustumProjectDirty = true;
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._isInvViewProjDirty.flag = true;
  };
  _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(point, invViewProjMat, out) {
    var depth = point.z * 2 - 1;
    var clipPoint = MathTemp.tempVec4;
    clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);
    Vector4.transform(clipPoint, invViewProjMat, clipPoint);
    var invW = 1 / clipPoint.w;
    out.x = clipPoint.x * invW;
    out.y = clipPoint.y * invW;
    out.z = clipPoint.z * invW;
    return out;
  };
  _proto._updateShaderData = function _updateShaderData(context) {
    var shaderData = this.shaderData;
    shaderData.setMatrix(Camera2._viewMatrixProperty, this.viewMatrix);
    shaderData.setMatrix(Camera2._projectionMatrixProperty, this.projectionMatrix);
    shaderData.setMatrix(Camera2._vpMatrixProperty, context._viewProjectMatrix);
    shaderData.setMatrix(Camera2._inverseViewMatrixProperty, this.inverseViewMatrix);
    shaderData.setMatrix(Camera2._inverseProjectionMatrixProperty, this.inverseProjectionMatrix);
    shaderData.setVector3(Camera2._cameraPositionProperty, this._transform.worldPosition);
  };
  _proto.setClearMode = function setClearMode(clearMode, backgroundColor) {
    if (clearMode === void 0) {
      clearMode = ClearMode.SOLID_COLOR;
    }
    if (backgroundColor === void 0) {
      backgroundColor = new Vector4(0.25, 0.25, 0.25, 1);
    }
    this._clearMode = clearMode;
    this._backgroundColor = backgroundColor;
    this._renderPipeline.defaultRenderPass.clearParam = backgroundColor;
    this._renderPipeline.defaultRenderPass.clearMode = clearMode;
  };
  _createClass(Camera2, [{
    key: "nearClipPlane",
    get: function get4() {
      return this._nearClipPlane;
    },
    set: function set4(value) {
      this._nearClipPlane = value;
      this._projMatChange();
    }
  }, {
    key: "farClipPlane",
    get: function get4() {
      return this._farClipPlane;
    },
    set: function set4(value) {
      this._farClipPlane = value;
      this._projMatChange();
    }
  }, {
    key: "fieldOfView",
    get: function get4() {
      return this._fieldOfView;
    },
    set: function set4(value) {
      this._fieldOfView = value;
      this._projMatChange();
    }
  }, {
    key: "aspectRatio",
    get: function get4() {
      var _this$_customAspectRa;
      var canvas = this._entity.engine.canvas;
      return (_this$_customAspectRa = this._customAspectRatio) != null ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
    },
    set: function set4(value) {
      this._customAspectRatio = value;
      this._projMatChange();
    }
  }, {
    key: "viewport",
    get: function get4() {
      return this._viewport;
    },
    set: function set4(value) {
      if (value !== this._viewport) {
        value.cloneTo(this._viewport);
      }
      this._projMatChange();
    }
  }, {
    key: "isOrthographic",
    get: function get4() {
      return this._isOrthographic;
    },
    set: function set4(value) {
      this._isOrthographic = value;
      this._projMatChange();
    }
  }, {
    key: "orthographicSize",
    get: function get4() {
      return this._orthographicSize;
    },
    set: function set4(value) {
      this._orthographicSize = value;
      this._projMatChange();
    }
  }, {
    key: "clearFlags",
    get: function get4() {
      throw "not implemented";
    },
    set: function set4(value) {
      throw "not implemented";
    }
  }, {
    key: "backgroundColor",
    get: function get4() {
      return this._backgroundColor;
    },
    set: function set4(value) {
      this.setClearMode(this._clearMode, value);
    }
  }, {
    key: "backgroundSky",
    get: function get4() {
      throw new Error("not implemented");
    }
  }, {
    key: "viewMatrix",
    get: function get4() {
      if (this._isViewMatrixDirty.flag) {
        this._isViewMatrixDirty.flag = false;
        Matrix.invert(this._transform.worldMatrix, this._viewMatrix);
      }
      return this._viewMatrix;
    }
  }, {
    key: "projectionMatrix",
    get: function get4() {
      var canvas = this._entity.engine.canvas;
      if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
        return this._projectionMatrix;
      }
      this._isProjectionDirty = false;
      this._lastAspectSize.x = canvas.width;
      this._lastAspectSize.y = canvas.height;
      var aspectRatio = this.aspectRatio;
      if (!this._isOrthographic) {
        Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      } else {
        var width = this._orthographicSize * aspectRatio;
        var height = this._orthographicSize;
        Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
      }
      return this._projectionMatrix;
    },
    set: function set4(value) {
      this._projectionMatrix = value;
      this._isProjMatSetting = true;
      this._projMatChange();
    }
  }, {
    key: "enableHDR",
    get: function get4() {
      console.log("not implemention");
      return false;
    },
    set: function set4(value) {
      console.log("not implemention");
    }
  }, {
    key: "renderTarget",
    get: function get4() {
      return this._renderTarget;
    },
    set: function set4(value) {
      this._renderTarget = value;
    }
  }, {
    key: "invViewProjMat",
    get: function get4() {
      if (this._isInvViewProjDirty.flag) {
        this._isInvViewProjDirty.flag = false;
        Matrix.multiply(this.inverseViewMatrix, this.inverseProjectionMatrix, this._invViewProjMat);
      }
      return this._invViewProjMat;
    }
  }, {
    key: "inverseProjectionMatrix",
    get: function get4() {
      if (this._isInvProjMatDirty) {
        this._isInvProjMatDirty = false;
        Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
      }
      return this._inverseProjectionMatrix;
    }
  }, {
    key: "inverseViewMatrix",
    get: function get4() {
      this._transform.worldMatrix.cloneTo(this._inverseViewMatrix);
      return this._inverseViewMatrix;
    }
  }]);
  return Camera2;
}(Component), _class3._viewMatrixProperty = Shader.getPropertyByName("u_viewMat"), _class3._projectionMatrixProperty = Shader.getPropertyByName("u_projMat"), _class3._vpMatrixProperty = Shader.getPropertyByName("u_VPMat"), _class3._inverseViewMatrixProperty = Shader.getPropertyByName("u_viewInvMat"), _class3._inverseProjectionMatrixProperty = Shader.getPropertyByName("u_projInvMat"), _class3._cameraPositionProperty = Shader.getPropertyByName("u_cameraPos"), _temp$6), _descriptor$6 = _applyDecoratedDescriptor(_class2$3.prototype, "_frustum", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer36() {
    return new BoundingFrustum();
  }
}), _descriptor2$5 = _applyDecoratedDescriptor(_class2$3.prototype, "_renderPipeline", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$4 = _applyDecoratedDescriptor(_class2$3.prototype, "_frustumViewChangeFlag", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$4 = _applyDecoratedDescriptor(_class2$3.prototype, "_transform", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_isViewMatrixDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_isInvViewProjDirty", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_projectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer37() {
    return new Matrix();
  }
}), _descriptor8$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_viewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer38() {
    return new Matrix();
  }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_backgroundColor", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer39() {
    return new Vector4();
  }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_viewport", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer40() {
    return new Vector4(0, 0, 1, 1);
  }
}), _descriptor11$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_inverseProjectionMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer41() {
    return new Matrix();
  }
}), _descriptor12$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_inverseViewMatrix", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer42() {
    return new Matrix();
  }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_lastAspectSize", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer43() {
    return new Vector2(0, 0);
  }
}), _descriptor14 = _applyDecoratedDescriptor(_class2$3.prototype, "_invViewProjMat", [deepClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer44() {
    return new Matrix();
  }
}), _class2$3)) || _class$6);
var mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
var defaultRetryCount = 4;
var defaultTimeout = 15e3;
var defaultInterval = 500;
function request(url, config) {
  if (config === void 0) {
    config = {};
  }
  return new AssetPromise(function(resolve, reject, setProgress) {
    var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;
    var retryCount = (_config$retryCount = config.retryCount) != null ? _config$retryCount : defaultRetryCount;
    var retryInterval = (_config$retryInterval = config.retryInterval) != null ? _config$retryInterval : defaultInterval;
    config.timeout = (_config$timeout = config.timeout) != null ? _config$timeout : defaultTimeout;
    config.type = (_config$type = config.type) != null ? _config$type : getMimeTypeFromUrl(url);
    var realRequest = config.type === "image" ? requestImage : requestRes;
    var lastError;
    var executor = new MultiExecutor(function() {
      return realRequest(url, config).onProgress(setProgress).then(function(res) {
        resolve(res);
        executor.stop();
      }).catch(function(err) {
        return lastError = err;
      });
    }, retryCount, retryInterval);
    executor.start(function() {
      reject(lastError);
    });
  });
}
function requestImage(url, config) {
  return new AssetPromise(function(resolve, reject) {
    var timeout = config.timeout;
    var img = new Image();
    var onerror = function onerror2() {
      reject(new Error("request " + url + " fail"));
    };
    img.onerror = onerror;
    img.onabort = onerror;
    var timeoutId = setTimeout(function() {
      reject(new Error("request " + url + " timeout"));
    }, timeout);
    img.onload = function(timeoutId2) {
      return function() {
        requestAnimationFrame(function() {
          resolve(img);
        });
        clearTimeout(timeoutId2);
      };
    }(timeoutId);
    img.crossOrigin = "anonymous";
    img.src = url;
  });
}
function requestRes(url, config) {
  return new AssetPromise(function(resolve, reject, setProgress) {
    var _config$method;
    var xhr = new XMLHttpRequest();
    xhr.timeout = config.timeout;
    config.method = (_config$method = config.method) != null ? _config$method : "get";
    xhr.onload = function() {
      var _xhr$response;
      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error("request failed from: " + url));
        return;
      }
      var result = (_xhr$response = xhr.response) != null ? _xhr$response : xhr.responseText;
      resolve(result);
    };
    xhr.onerror = function() {
      reject(new Error("request failed from: " + url));
    };
    xhr.ontimeout = function() {
      reject(new Error("request timeout from: " + url));
    };
    xhr.onprogress = function(e) {
      setProgress(e.loaded / e.total);
    };
    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include";
    xhr.responseType = config.type;
    var headers = config.headers;
    if (headers) {
      Object.keys(headers).forEach(function(name) {
        xhr.setRequestHeader(name, headers[name]);
      });
    }
    xhr.send(config.body);
  });
}
function getMimeTypeFromUrl(url) {
  var extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}
var MultiExecutor = function() {
  function MultiExecutor2(execFunc, totalCount, interval) {
    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.done = void 0;
    this.exec = this.exec.bind(this);
  }
  var _proto = MultiExecutor2.prototype;
  _proto.start = function start(done) {
    this.done = done;
    this.exec();
  };
  _proto.stop = function stop() {
    clearTimeout(this._timeoutId);
  };
  _proto.exec = function exec() {
    var _this = this;
    if (this._currentCount >= this.totalCount) {
      this.done && this.done();
      return;
    }
    this._currentCount++;
    this.execFunc(this._currentCount).then(function() {
      _this._timeoutId = setTimeout(_this.exec, _this.interval);
    });
  };
  return MultiExecutor2;
}();
var Loader = function Loader2(useCache) {
  this.useCache = useCache;
  this.request = request;
};
var AssetType;
(function(AssetType2) {
  AssetType2[AssetType2["Text"] = 0] = "Text";
  AssetType2[AssetType2["JSON"] = 1] = "JSON";
  AssetType2[AssetType2["Buffer"] = 2] = "Buffer";
  AssetType2[AssetType2["Texture2D"] = 3] = "Texture2D";
  AssetType2[AssetType2["TextureCube"] = 4] = "TextureCube";
  AssetType2[AssetType2["Material"] = 5] = "Material";
  AssetType2[AssetType2["Mesh"] = 6] = "Mesh";
  AssetType2[AssetType2["AnimationClip"] = 7] = "AnimationClip";
  AssetType2[AssetType2["Perfab"] = 8] = "Perfab";
  AssetType2[AssetType2["KTX"] = 9] = "KTX";
  AssetType2[AssetType2["KTXCube"] = 10] = "KTXCube";
})(AssetType || (AssetType = {}));
var ColliderFeature = function(_SceneFeature) {
  _inheritsLoose(ColliderFeature2, _SceneFeature);
  function ColliderFeature2() {
    var _this;
    _this = _SceneFeature.call(this) || this;
    _this.colliders = void 0;
    _this.colliders = [];
    return _this;
  }
  var _proto = ColliderFeature2.prototype;
  _proto.attachCollider = function attachCollider(collider) {
    this.colliders.push(collider);
  };
  _proto.detachCollider = function detachCollider(collider) {
    var index = this.colliders.indexOf(collider);
    if (index != -1) {
      this.colliders.splice(index, 1);
    }
  };
  return ColliderFeature2;
}(SceneFeature);
var Collider = function(_Component) {
  _inheritsLoose(Collider2, _Component);
  function Collider2(entity) {
    return _Component.call(this, entity) || this;
  }
  var _proto = Collider2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.findFeature(ColliderFeature).attachCollider(this);
  };
  _proto._onDisable = function _onDisable() {
    this.scene.findFeature(ColliderFeature).detachCollider(this);
  };
  return Collider2;
}(Component);
var ABoxCollider = function(_Collider) {
  _inheritsLoose(ABoxCollider2, _Collider);
  function ABoxCollider2(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this.boxMin = void 0;
    _this.boxMax = void 0;
    _this._corners = [];
    _this._cornerFlag = false;
    _this.boxMin = new Vector3(-0.5, -0.5, -0.5);
    _this.boxMax = new Vector3(0.5, 0.5, 0.5);
    return _this;
  }
  var _proto = ABoxCollider2.prototype;
  _proto.setBoxMinMax = function setBoxMinMax(min, max) {
    this.boxMin = min;
    this.boxMax = max;
    this._cornerFlag = true;
  };
  _proto.setBoxCenterSize = function setBoxCenterSize(center, size) {
    var halfSize = ABoxCollider2._tempVec3;
    Vector3.scale(size, 0.5, halfSize);
    Vector3.add(center, halfSize, this.boxMax);
    Vector3.subtract(center, halfSize, this.boxMin);
    this._cornerFlag = true;
  };
  _proto.getCorners = function getCorners() {
    if (this._cornerFlag) {
      var minX = this.boxMin.x;
      var minY = this.boxMin.y;
      var minZ = this.boxMin.z;
      var w = this.boxMax.x - minX;
      var h = this.boxMax.y - minY;
      var d = this.boxMax.z - minZ;
      if (this._corners.length === 0) {
        for (var i = 0; i < 8; ++i) {
          this._corners.push(new Vector3());
        }
      }
      this._corners[0].setValue(minX + w, minY + h, minZ + d);
      this._corners[1].setValue(minX, minY + h, minZ + d);
      this._corners[2].setValue(minX, minY, minZ + d);
      this._corners[3].setValue(minX + w, minY, minZ + d);
      this._corners[4].setValue(minX + w, minY + h, minZ);
      this._corners[5].setValue(minX, minY + h, minZ);
      this._corners[6].setValue(minX, minY, minZ);
      this._corners[7].setValue(minX + w, minY, minZ);
      this._cornerFlag = false;
    }
    return this._corners;
  };
  return ABoxCollider2;
}(Collider);
ABoxCollider._tempVec3 = new Vector3();
var ASphereCollider = function(_Collider) {
  _inheritsLoose(ASphereCollider2, _Collider);
  function ASphereCollider2(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this.center = void 0;
    _this.radius = void 0;
    _this.center = new Vector3();
    _this.radius = 1;
    return _this;
  }
  var _proto = ASphereCollider2.prototype;
  _proto.setSphere = function setSphere(center, radius) {
    this.center = center;
    this.radius = radius;
  };
  return ASphereCollider2;
}(Collider);
var PlaneCollider = function(_Collider) {
  _inheritsLoose(PlaneCollider2, _Collider);
  function PlaneCollider2(entity) {
    var _this;
    _this = _Collider.call(this, entity) || this;
    _this.planePoint = void 0;
    _this.normal = void 0;
    _this.planePoint = new Vector3();
    _this.normal = new Vector3(0, 1, 0);
    return _this;
  }
  var _proto = PlaneCollider2.prototype;
  _proto.setPlane = function setPlane(point, normal) {
    this.planePoint = point;
    this.normal = normal;
  };
  return PlaneCollider2;
}(Collider);
var RaycastHit = function RaycastHit2() {
  this.distance = void 0;
  this.collider = void 0;
  this.point = void 0;
  this.distance = Number.MAX_VALUE;
  this.collider = null;
  this.point = null;
};
var _tempVec3 = new Vector3();
var _tempPlane = new Plane();
var _tepmBox = new BoundingBox();
var _tempShpere = new BoundingSphere();
Scene.prototype.raycast = function(ray, _outPos, tag) {
  if (tag === void 0) {
    tag = Layer.Everything;
  }
  var cf = this.findFeature(ColliderFeature);
  var colliders = cf.colliders;
  var nearestHit = new RaycastHit();
  for (var i = 0, len = colliders.length; i < len; i++) {
    var collider = colliders[i];
    if (!collider.entity.isActiveInHierarchy) {
      continue;
    }
    if (!(collider.entity.layer & tag)) {
      continue;
    }
    var hit = new RaycastHit();
    if (collider.raycast(ray, hit)) {
      if (hit.distance < nearestHit.distance) {
        nearestHit = hit;
      }
    }
  }
  if (_outPos && nearestHit.collider) {
    nearestHit.point.cloneTo(_outPos);
  }
  return nearestHit.collider;
};
ABoxCollider.prototype.raycast = function(ray, hit) {
  var localRay = _getLocalRay(this, ray);
  this.boxMin.cloneTo(_tepmBox.min);
  this.boxMax.cloneTo(_tepmBox.max);
  var intersect = localRay.intersectBox(_tepmBox);
  if (intersect !== -1) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);
    return true;
  } else {
    return false;
  }
};
ASphereCollider.prototype.raycast = function(ray, hit) {
  var localRay = _getLocalRay(this, ray);
  this.center.cloneTo(_tempShpere.center);
  _tempShpere.radius = this.radio;
  var intersect = localRay.intersectSphere(_tempShpere);
  if (intersect !== -1) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);
    return true;
  } else {
    return false;
  }
};
PlaneCollider.prototype.raycast = function(ray, hit) {
  var localRay = _getLocalRay(this, ray);
  this.normal.cloneTo(_tempPlane.normal);
  _tempPlane.distance = -Vector3.dot(this.planePoint, _tempPlane.normal);
  var intersect = localRay.intersectPlane(_tempPlane);
  if (intersect !== -1) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);
    return true;
  } else {
    return false;
  }
};
function _updateHitResult(collider, ray, distance, outHit, origin) {
  var hitPos = _tempVec3;
  ray.getPoint(distance, hitPos);
  Vector3.transformCoordinate(hitPos, collider.entity.transform.worldMatrix, hitPos);
  outHit.distance = Vector3.distance(origin, hitPos);
  outHit.collider = collider;
  outHit.point = hitPos;
}
function _getLocalRay(collider, ray) {
  var worldToLocal = collider.entity.getInvModelMatrix();
  var o = new Vector3();
  Vector3.transformCoordinate(ray.origin, worldToLocal, o);
  var d = new Vector3();
  _transformDirection(d, ray.direction, worldToLocal);
  return new Ray(o, d);
}
function _transformDirection(out, a, m) {
  var x = a.x;
  var y = a.y;
  var z = a.z;
  var e = m.elements;
  out.x = x * e[0] + y * e[4] + z * e[8];
  out.y = x * e[1] + y * e[5] + z * e[9];
  out.z = x * e[2] + y * e[6] + z * e[10];
  return out;
}
var Mesh = function(_EngineObject) {
  _inheritsLoose(Mesh2, _EngineObject);
  function Mesh2(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this.primitives = [];
    _this.groups = [];
    _this.weights = void 0;
    _this.bounds = new BoundingBox(new Vector3(), new Vector3());
    _this.name = name;
    return _this;
  }
  var _proto = Mesh2.prototype;
  _proto.updatePrimitiveWeightsIndices = function updatePrimitiveWeightsIndices(weightsIndices) {
  };
  _proto.destroy = function destroy() {
    this.primitives = null;
  };
  return Mesh2;
}(EngineObject);
var Skin = function(_EngineObject) {
  _inheritsLoose(Skin2, _EngineObject);
  function Skin2(name) {
    var _this;
    _this = _EngineObject.call(this, null) || this;
    _this.inverseBindMatrices = void 0;
    _this.joints = void 0;
    _this.skeleton = void 0;
    _this.inverseBindMatrices = [];
    _this.joints = [];
    _this.skeleton = "none";
    return _this;
  }
  return Skin2;
}(EngineObject);
var _class$7;
var _descriptor$7;
var _descriptor2$6;
var _temp$7;
function addPrimitivesRefCount(mesh, refCount) {
  var primitives = mesh.primitives;
  for (var i = 0, l = primitives.length; i < l; i++) {
    primitives[i]._addRefCount(refCount);
  }
}
var MeshRenderer = (_class$7 = (_temp$7 = function(_Renderer) {
  _inheritsLoose(MeshRenderer2, _Renderer);
  function MeshRenderer2(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _this._mesh = void 0;
    _initializerDefineProperty(_this, "_instanceMaterials", _descriptor$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_sharedMaterials", _descriptor2$6, _assertThisInitialized(_this));
    _this._mesh = null;
    return _this;
  }
  var _proto = MeshRenderer2.prototype;
  _proto.setSharedMaterial = function setSharedMaterial(primitiveIndex, material) {
    if (this._sharedMaterials[primitiveIndex]) {
      this._sharedMaterials[primitiveIndex]._addRefCount(-1);
    }
    material._addRefCount(1);
    this._sharedMaterials[primitiveIndex] = material;
  };
  _proto.setMaterial = function setMaterial(primitiveIndex, material) {
    if (this._instanceMaterials[primitiveIndex]) {
      this._instanceMaterials[primitiveIndex]._addRefCount(-1);
    }
    material._addRefCount(1);
    this._instanceMaterials[primitiveIndex] = material;
  };
  _proto.getInstanceMaterial = function getInstanceMaterial(primitiveIndex) {
    return this._instanceMaterials[primitiveIndex];
  };
  _proto.getSharedMaterial = function getSharedMaterial(primitiveIndex) {
    return this._sharedMaterials[primitiveIndex];
  };
  _proto.render = function render(camera) {
    var mesh = this._mesh;
    if (!mesh) {
      return;
    }
    var renderPipeline = camera._renderPipeline;
    var primitives = mesh.primitives, groups = mesh.groups;
    for (var i = 0, len = primitives.length; i < len; i++) {
      var primitive = primitives[i];
      var material = this._instanceMaterials[i] || this._sharedMaterials[i];
      if (material) {
        var element = RenderElement.getFromPool();
        element.setValue(this, primitive, groups[i], material);
        renderPipeline.pushPrimitive(element);
      } else {
        Logger.error("Primitive has no material: " + primitive.name);
      }
    }
  };
  _proto.destroy = function destroy() {
    _Renderer.prototype.destroy.call(this);
    this._mesh = null;
    this._instanceMaterials = [];
    this._sharedMaterials = [];
    for (var i = 0; i < this._instanceMaterials.length; i++) {
      this._instanceMaterials[i]._addRefCount(-1);
    }
    for (var _i = 0; _i < this._sharedMaterials.length; _i++) {
      this._sharedMaterials[_i]._addRefCount(-1);
    }
    if (this._mesh) {
      addPrimitivesRefCount(this._mesh, -1);
    }
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    var localBounds = this.mesh.bounds;
    var worldMatrix = this._entity.transform.worldMatrix;
    BoundingBox.transform(localBounds, worldMatrix, worldBounds);
  };
  _createClass(MeshRenderer2, [{
    key: "mesh",
    get: function get4() {
      return this._mesh;
    },
    set: function set4(mesh) {
      if (this._mesh) {
        addPrimitivesRefCount(this._mesh, -1);
      }
      addPrimitivesRefCount(mesh, 1);
      this._mesh = mesh;
      this._sharedMaterials = [];
      this._instanceMaterials = [];
    }
  }]);
  return MeshRenderer2;
}(Renderer), _temp$7), _descriptor$7 = _applyDecoratedDescriptor(_class$7.prototype, "_instanceMaterials", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer45() {
    return [];
  }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class$7.prototype, "_sharedMaterials", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer46() {
    return [];
  }
}), _class$7);
var Texture2D = function(_Texture) {
  _inheritsLoose(Texture2D2, _Texture);
  function Texture2D2(engine, width, height, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._format = void 0;
    _this._compressedMipFilled = 0;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    var formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);
    _this._glTexture = gl.createTexture();
    _this._formatDetail = formatDetail;
    _this._rhi = rhi;
    _this._target = gl.TEXTURE_2D;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(false);
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Repeat;
    return _this;
  }
  var _proto = Texture2D2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
    var mipWidth = Math.max(1, this._width >> mipLevel);
    var mipHeight = Math.max(1, this._height >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipWidth - x;
    height = height || mipHeight - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      var mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedMipFilled & mipBit) {
        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedMipFilled |= mipBit;
      }
    } else {
      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
    this._unbind();
  };
  _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    var gl = this._rhi.gl;
    var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    this._unbind();
  };
  _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    _Texture.prototype._getPixelBuffer.call(this, null, x, y, width, height, out);
  };
  _createClass(Texture2D2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }]);
  return Texture2D2;
}(Texture);
var _class$8;
var _descriptor$8;
var _descriptor2$7;
var _descriptor3$5;
var _descriptor4$5;
var _descriptor5$4;
var _descriptor6$4;
var _descriptor7$3;
var _descriptor8$3;
var _class2$4;
var _temp$8;
var SkinnedMeshRenderer = (_class$8 = (_temp$8 = _class2$4 = function(_MeshRenderer) {
  _inheritsLoose(SkinnedMeshRenderer2, _MeshRenderer);
  function SkinnedMeshRenderer2(entity) {
    var _this;
    _this = _MeshRenderer.call(this, entity) || this;
    _initializerDefineProperty(_this, "matrixPalette", _descriptor$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "jointNodes", _descriptor2$7, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "jointTexture", _descriptor3$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_hasInitJoints", _descriptor4$5, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_mat", _descriptor5$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_weights", _descriptor6$4, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "weightsIndices", _descriptor7$3, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_useJointTexture", _descriptor8$3, _assertThisInitialized(_this));
    _this._skin = void 0;
    _this._mat = new Matrix();
    _this._weights = null;
    _this._skin = null;
    return _this;
  }
  var _proto = SkinnedMeshRenderer2.prototype;
  _proto._updateShaderData = function _updateShaderData(context) {
    _MeshRenderer.prototype._updateShaderData.call(this, context);
    if (!this._useJointTexture && this.matrixPalette) {
      this.shaderData.setFloatArray(SkinnedMeshRenderer2._jointMatrixProperty, this.matrixPalette);
    }
  };
  _proto.setWeights = function setWeights(weights) {
    this._weights = weights;
    if (!weights) {
      return;
    }
    var len = weights.length;
    for (var i = 0; i < len; i++) {
      this.weightsIndices[i] = i;
    }
    var weightsIndices = this.weightsIndices;
    for (var _i = 0; _i < len - 1; _i++) {
      for (var j = _i + 1; j < len; j++) {
        if (weights[j] > weights[_i]) {
          var t = weights[_i];
          weights[_i] = weights[j];
          weights[j] = t;
          t = weightsIndices[_i];
          weightsIndices[_i] = weightsIndices[j];
          weightsIndices[j] = t;
        }
      }
    }
    this.mesh.updatePrimitiveWeightsIndices(weightsIndices);
  };
  _proto._initJoints = function _initJoints() {
    var _this$jointNodes;
    if (!this._skin)
      return;
    var skin = this._skin;
    var joints = skin.joints;
    var jointNodes = [];
    for (var i = joints.length - 1; i >= 0; i--) {
      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
    }
    this.matrixPalette = new Float32Array(jointNodes.length * 16);
    this.jointNodes = jointNodes;
    var rhi = this.entity.engine._hardwareRenderer;
    if (!rhi)
      return;
    var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
    var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
    var shaderData = this.shaderData;
    var jointCount = (_this$jointNodes = this.jointNodes) === null || _this$jointNodes === void 0 ? void 0 : _this$jointNodes.length;
    if (jointCount) {
      shaderData.enableMacro("O3_HAS_SKIN");
      shaderData.setInt(SkinnedMeshRenderer2._jointCountProperty, jointCount);
      if (joints.length > maxJoints) {
        if (rhi.canIUseMoreJoints) {
          this._useJointTexture = true;
          shaderData.enableMacro("O3_USE_JOINT_TEXTURE");
          shaderData.setTexture(SkinnedMeshRenderer2._jointSamplerProperty, this.jointTexture);
        } else {
          Logger.error("component's joints count(" + joints + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + maxAttribUniformVec4 + ", and don't support jointTexture in this device. suggest joint count less than " + maxJoints + ".", this);
        }
      } else {
        var _maxJoints = Math.max(SkinnedMeshRenderer2._maxJoints, joints.length);
        SkinnedMeshRenderer2._maxJoints = _maxJoints;
        shaderData.disableMacro("O3_USE_JOINT_TEXTURE");
        shaderData.enableMacro("O3_JOINTS_NUM", _maxJoints.toString());
      }
    } else {
      shaderData.disableMacro("O3_HAS_SKIN");
    }
  };
  _proto.findByNodeName = function findByNodeName(entity, nodeName) {
    if (!entity)
      return null;
    var n = entity.findByName(nodeName);
    if (n)
      return n;
    return this.findByNodeName(entity.parent, nodeName);
  };
  _proto._findParent = function _findParent(entity, nodeName) {
    if (entity) {
      var parent = entity.parent;
      if (!parent)
        return null;
      if (parent.name === nodeName)
        return parent;
      var brother = parent.findByName(nodeName);
      if (brother)
        return brother;
      return this._findParent(parent, nodeName);
    }
    return null;
  };
  _proto.update = function update() {
    if (!this._hasInitJoints) {
      this._initJoints();
      this._hasInitJoints = true;
    }
    if (this._skin) {
      var joints = this.jointNodes;
      var ibms = this._skin.inverseBindMatrices;
      var matrixPalette = this.matrixPalette;
      var worldToLocal = this.entity.getInvModelMatrix();
      var mat = this._mat;
      for (var i = joints.length - 1; i >= 0; i--) {
        mat.identity();
        if (joints[i]) {
          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
        } else {
          ibms[i].cloneTo(mat);
        }
        Matrix.multiply(worldToLocal, mat, mat);
        matrixPalette.set(mat.elements, i * 16);
      }
      if (this._useJointTexture) {
        this.createJointTexture();
      }
    }
  };
  _proto.createJointTexture = function createJointTexture() {
    if (!this.jointTexture) {
      var engine = this.engine;
      var rhi = engine._hardwareRenderer;
      if (!rhi)
        return;
      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);
      this.jointTexture.filterMode = TextureFilterMode.Point;
    }
    this.jointTexture.setPixelBuffer(this.matrixPalette);
  };
  _createClass(SkinnedMeshRenderer2, [{
    key: "skin",
    get: function get4() {
      return this._skin;
    },
    set: function set4(skin) {
      this._skin = skin;
    }
  }, {
    key: "weights",
    get: function get4() {
      return this._weights;
    }
  }]);
  return SkinnedMeshRenderer2;
}(MeshRenderer), _class2$4._jointCountProperty = Shader.getPropertyByName("u_jointCount"), _class2$4._jointSamplerProperty = Shader.getPropertyByName("u_jointSampler"), _class2$4._jointMatrixProperty = Shader.getPropertyByName("u_jointMatrix"), _class2$4._maxJoints = 0, _temp$8), _descriptor$8 = _applyDecoratedDescriptor(_class$8.prototype, "matrixPalette", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2$7 = _applyDecoratedDescriptor(_class$8.prototype, "jointNodes", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3$5 = _applyDecoratedDescriptor(_class$8.prototype, "jointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4$5 = _applyDecoratedDescriptor(_class$8.prototype, "_hasInitJoints", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer47() {
    return false;
  }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class$8.prototype, "_mat", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor6$4 = _applyDecoratedDescriptor(_class$8.prototype, "_weights", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor7$3 = _applyDecoratedDescriptor(_class$8.prototype, "weightsIndices", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer48() {
    return [];
  }
}), _descriptor8$3 = _applyDecoratedDescriptor(_class$8.prototype, "_useJointTexture", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer49() {
    return false;
  }
}), _class$8);
var LODGroup = function(_Renderer) {
  _inheritsLoose(LODGroup2, _Renderer);
  function LODGroup2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Renderer.call.apply(_Renderer, [this].concat(args)) || this;
    _this._lods = [];
    return _this;
  }
  var _proto = LODGroup2.prototype;
  _proto.addLod = function addLod(distance, renderer) {
    renderer.enabled = false;
    this._lods.push({
      distance,
      rendererAbility: renderer
    });
    this._lods.sort(function(a, b) {
      return b.distance - a.distance;
    });
  };
  _proto.render = function render(camera) {
    if (this._lods.length <= 0)
      return;
    var dist = Vector3.distance(camera.entity.transform.worldPosition, this.entity.transform.worldPosition);
    var lods = this._lods;
    var activeLevel = 0;
    for (var i = lods.length - 1; i >= 0; i--) {
      var _lod = lods[i];
      if (dist < _lod.distance) {
        activeLevel = i;
        break;
      }
    }
    var lod = lods[activeLevel];
    lod.rendererAbility.render(camera);
  };
  return LODGroup2;
}(Renderer);
var TextureCubeFace;
(function(TextureCubeFace2) {
  TextureCubeFace2[TextureCubeFace2["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace2[TextureCubeFace2["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace2[TextureCubeFace2["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace2[TextureCubeFace2["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace2[TextureCubeFace2["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace2[TextureCubeFace2["NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));
var TextureCubeMap = function(_Texture) {
  _inheritsLoose(TextureCubeMap2, _Texture);
  function TextureCubeMap2(engine, size, format, mipmap) {
    var _this;
    if (format === void 0) {
      format = TextureFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = true;
    }
    _this = _Texture.call(this, engine) || this;
    _this._format = void 0;
    _this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportTextureFormat(format, rhi)) {
      throw new Error("Texture format is not supported:" + TextureFormat[format]);
    }
    if (mipmap && !isWebGL2 && !Texture._isPowerOf2(size)) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    var formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);
    _this._glTexture = gl.createTexture();
    _this._formatDetail = formatDetail;
    _this._rhi = rhi;
    _this._target = gl.TEXTURE_CUBE_MAP;
    _this._mipmap = mipmap;
    _this._width = size;
    _this._height = size;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    formatDetail.isCompressed && !isWebGL2 || _this._initMipmap(true);
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  var _proto = TextureCubeMap2.prototype;
  _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    var _this$_formatDetail = this._formatDetail, internalFormat = _this$_formatDetail.internalFormat, baseFormat = _this$_formatDetail.baseFormat, dataType = _this$_formatDetail.dataType, isCompressed = _this$_formatDetail.isCompressed;
    var mipSize = Math.max(1, this._width >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipSize - x;
    height = height || mipSize - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      var mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedFaceFilled[face] |= mipBit;
      }
    } else {
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
    this._unbind();
  };
  _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    if (flipY === void 0) {
      flipY = false;
    }
    if (premultiplyAlpha === void 0) {
      premultiplyAlpha = false;
    }
    var gl = this._rhi.gl;
    var _this$_formatDetail2 = this._formatDetail, baseFormat = _this$_formatDetail2.baseFormat, dataType = _this$_formatDetail2.dataType;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    this._unbind();
  };
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    _Texture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
  };
  _createClass(TextureCubeMap2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }]);
  return TextureCubeMap2;
}(Texture);
var RenderDepthTexture = function(_Texture) {
  _inheritsLoose(RenderDepthTexture2, _Texture);
  function RenderDepthTexture2(engine, width, height, format, mipmap, isCube) {
    var _this;
    if (format === void 0) {
      format = RenderBufferDepthFormat.Depth;
    }
    if (mipmap === void 0) {
      mipmap = false;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    _this = _Texture.call(this, engine) || this;
    _this._isCube = false;
    _this._format = void 0;
    _this._autoMipmap = false;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportRenderBufferDepthFormat(format, rhi, true)) {
      throw new Error("RenderBufferDepthFormat is not supported:" + RenderBufferDepthFormat[format]);
    }
    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }
    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    _this._glTexture = gl.createTexture();
    _this._formatDetail = Texture._getRenderBufferDepthFormatDetail(format, gl, isWebGL2);
    _this._isCube = isCube;
    _this._rhi = rhi;
    _this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._initMipmap(isCube);
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  _createClass(RenderDepthTexture2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }, {
    key: "autoGenerateMipmaps",
    get: function get4() {
      return this._autoMipmap;
    },
    set: function set4(value) {
      this._autoMipmap = value;
    }
  }]);
  return RenderDepthTexture2;
}(Texture);
var RenderTarget = function(_EngineObject) {
  _inheritsLoose(RenderTarget2, _EngineObject);
  function RenderTarget2(engine, width, height, renderTexture, depth, antiAliasing) {
    var _this;
    if (depth === void 0) {
      depth = RenderBufferDepthFormat.Depth;
    }
    if (antiAliasing === void 0) {
      antiAliasing = 1;
    }
    _this = _EngineObject.call(this, engine) || this;
    _this._frameBuffer = void 0;
    _this._MSAAFrameBuffer = void 0;
    _this._rhi = void 0;
    _this._width = void 0;
    _this._height = void 0;
    _this._antiAliasing = void 0;
    _this._colorTextures = void 0;
    _this._depthTexture = void 0;
    _this._depthRenderBuffer = void 0;
    _this._MSAAColorRenderBuffers = [];
    _this._MSAADepthRenderBuffer = void 0;
    _this._oriDrawBuffers = void 0;
    _this._blitDrawBuffers = void 0;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    if (!(depth instanceof RenderDepthTexture) && !Texture._supportRenderBufferDepthFormat(depth, rhi, false)) {
      throw new Error("RenderBufferDepthFormat is not supported:" + RenderBufferDepthFormat[depth]);
    }
    if ((renderTexture === null || renderTexture === void 0 ? void 0 : renderTexture.length) > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
      throw new Error("MRT is not supported");
    }
    if (renderTexture) {
      _this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
    } else {
      _this._colorTextures = [];
    }
    if (_this._colorTextures.some(function(v) {
      return v.width !== width || v.height !== height;
    })) {
      throw new Error("RenderColorTexture's size must as same as RenderTarget");
    }
    if (depth instanceof RenderDepthTexture && (depth.width !== width || depth.height !== height)) {
      throw new Error("RenderDepthTexture's size must as same as RenderTarget");
    }
    if (_this._colorTextures.length > 1 && _this._colorTextures.some(function(v) {
      return v._isCube;
    })) {
      throw new Error("MRT+Cube+[,MSAA] is not supported");
    }
    var maxAntiAliasing = rhi.capability.maxAntiAliasing;
    if (antiAliasing > maxAntiAliasing) {
      Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
      antiAliasing = maxAntiAliasing;
    }
    _this._rhi = rhi;
    _this._width = width;
    _this._height = height;
    _this._frameBuffer = gl.createFramebuffer();
    _this._antiAliasing = antiAliasing;
    if (depth instanceof RenderDepthTexture) {
      _this._depthTexture = depth;
    }
    _this._bindMainFBO(depth);
    if (antiAliasing > 1) {
      _this._MSAAFrameBuffer = gl.createFramebuffer();
      _this._bindMSAAFBO(depth);
    }
    return _this;
  }
  var _proto = RenderTarget2.prototype;
  _proto.getColorTexture = function getColorTexture(index) {
    if (index === void 0) {
      index = 0;
    }
    return this._colorTextures[index];
  };
  _proto.destroy = function destroy() {
    var gl = this._rhi.gl;
    gl.deleteFramebuffer(this._frameBuffer);
    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
    for (var i = 0; i < this._colorTextures.length; i++) {
      this._colorTextures[i].destroy();
    }
    for (var _i = 0; _i < this._MSAAColorRenderBuffers.length; _i++) {
      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[_i]);
    }
    this._depthTexture && this._depthTexture.destroy();
    this._frameBuffer = null;
    this._colorTextures.length = 0;
    this._depthTexture = null;
    this._depthRenderBuffer = null;
    this._MSAAFrameBuffer = null;
    this._MSAAColorRenderBuffers.length = 0;
    this._MSAADepthRenderBuffer = null;
  };
  _proto._activeRenderTarget = function _activeRenderTarget() {
    var gl = this._rhi.gl;
    if (this._MSAAFrameBuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    }
  };
  _proto._setRenderTargetFace = function _setRenderTargetFace(faceIndex) {
    if (faceIndex === void 0) {
      faceIndex = TextureCubeFace.PositiveX;
    }
    var gl = this._rhi.gl;
    var colorTexture = this._colorTextures[0];
    var depthTexture = this._depthTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    if (colorTexture !== null && colorTexture !== void 0 && colorTexture._isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, colorTexture._glTexture, 0);
    }
    if (depthTexture !== null && depthTexture !== void 0 && depthTexture._isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthTexture._glTexture, 0);
    }
    this._activeRenderTarget();
  };
  _proto._blitRenderTarget = function _blitRenderTarget() {
    var gl = this._rhi.gl;
    var mask = gl.COLOR_BUFFER_BIT | (this._depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
    var colorTextureLength = this._colorTextures.length;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
    for (var textureIndex = 0; textureIndex < colorTextureLength; textureIndex++) {
      var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
      this._blitDrawBuffers[textureIndex] = attachment;
      gl.readBuffer(attachment);
      gl.drawBuffers(this._blitDrawBuffers);
      gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, mask, gl.NEAREST);
      this._blitDrawBuffers[textureIndex] = gl.NONE;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };
  _proto._bindMainFBO = function _bindMainFBO(renderDepth) {
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    var colorTextureLength = this._colorTextures.length;
    var drawBuffers = new Array(colorTextureLength);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    for (var i = 0; i < colorTextureLength; i++) {
      var _colorTexture = this._colorTextures[i];
      var attachment = gl.COLOR_ATTACHMENT0 + i;
      drawBuffers[i] = attachment;
      if (!_colorTexture._isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, _colorTexture._glTexture, 0);
      }
    }
    if (colorTextureLength > 1) {
      gl.drawBuffers(drawBuffers);
    }
    this._oriDrawBuffers = drawBuffers;
    if (renderDepth !== null) {
      if (renderDepth instanceof RenderDepthTexture) {
        if (!renderDepth._isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, renderDepth._formatDetail.attachment, gl.TEXTURE_2D, renderDepth._glTexture, 0);
        }
      } else if (this._antiAliasing <= 1) {
        var _Texture$_getRenderBu = Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2), internalFormat = _Texture$_getRenderBu.internalFormat, _attachment = _Texture$_getRenderBu.attachment;
        var depthRenderBuffer = gl.createRenderbuffer();
        this._depthRenderBuffer = depthRenderBuffer;
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
      }
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };
  _proto._bindMSAAFBO = function _bindMSAAFBO(renderDepth) {
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    var MSAADepthRenderBuffer = gl.createRenderbuffer();
    var colorTextureLength = this._colorTextures.length;
    this._blitDrawBuffers = new Array(colorTextureLength);
    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    for (var i = 0; i < colorTextureLength; i++) {
      var MSAAColorRenderBuffer = gl.createRenderbuffer();
      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
      this._blitDrawBuffers[i] = gl.NONE;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, this._colorTextures[i]._formatDetail.internalFormat, this._width, this._height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
    }
    gl.drawBuffers(this._oriDrawBuffers);
    if (renderDepth !== null) {
      var _ref = renderDepth instanceof RenderDepthTexture ? renderDepth._formatDetail : Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2), internalFormat = _ref.internalFormat, attachment = _ref.attachment;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, internalFormat, this._width, this._height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
    }
    this._checkFrameBuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  };
  _proto._checkFrameBuffer = function _checkFrameBuffer() {
    var gl = this._rhi.gl;
    var isWebGL2 = this._rhi.isWebGL2;
    var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (e) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw new Error("There is no attachment");
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw new Error(" Height and width of the attachment are not the same.");
      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
    }
    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
      throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
    }
  };
  _createClass(RenderTarget2, [{
    key: "width",
    get: function get4() {
      return this._width;
    }
  }, {
    key: "height",
    get: function get4() {
      return this._height;
    }
  }, {
    key: "colorTextureCount",
    get: function get4() {
      return this._colorTextures.length;
    }
  }, {
    key: "depthTexture",
    get: function get4() {
      return this._depthTexture;
    }
  }, {
    key: "antiAliasing",
    get: function get4() {
      return this._antiAliasing;
    }
  }]);
  return RenderTarget2;
}(EngineObject);
var RenderColorTexture = function(_Texture) {
  _inheritsLoose(RenderColorTexture2, _Texture);
  function RenderColorTexture2(engine, width, height, format, mipmap, isCube) {
    var _this;
    if (format === void 0) {
      format = RenderBufferColorFormat.R8G8B8A8;
    }
    if (mipmap === void 0) {
      mipmap = false;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    _this = _Texture.call(this, engine) || this;
    _this._isCube = false;
    _this._format = void 0;
    _this._autoMipmap = false;
    var rhi = engine._hardwareRenderer;
    var gl = rhi.gl;
    var isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportRenderBufferColorFormat(format, rhi)) {
      throw new Error("RenderBufferColorFormat is not supported:" + RenderBufferColorFormat[format]);
    }
    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }
    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    _this._glTexture = gl.createTexture();
    _this._formatDetail = Texture._getRenderBufferColorFormatDetail(format, gl, isWebGL2);
    _this._isCube = isCube;
    _this._rhi = rhi;
    _this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    _this._mipmap = mipmap;
    _this._width = width;
    _this._height = height;
    _this._format = format;
    _this._mipmapCount = _this._getMipmapCount();
    _this._initMipmap(isCube);
    _this.filterMode = TextureFilterMode.Bilinear;
    _this.wrapModeU = _this.wrapModeV = TextureWrapMode.Clamp;
    return _this;
  }
  var _proto = RenderColorTexture2.prototype;
  _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, out) {
    _Texture.prototype._getPixelBuffer.call(this, face, x, y, width, height, out);
  };
  _createClass(RenderColorTexture2, [{
    key: "format",
    get: function get4() {
      return this._format;
    }
  }, {
    key: "autoGenerateMipmaps",
    get: function get4() {
      return this._autoMipmap;
    },
    set: function set4(value) {
      this._autoMipmap = value;
    }
  }]);
  return RenderColorTexture2;
}(Texture);
var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["Static"] = 0] = "Static";
  BufferUsage2[BufferUsage2["Dynamic"] = 1] = "Dynamic";
  BufferUsage2[BufferUsage2["Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));
var VertexElementFormat;
(function(VertexElementFormat2) {
  VertexElementFormat2[VertexElementFormat2["Float"] = 0] = "Float";
  VertexElementFormat2[VertexElementFormat2["Vector2"] = 1] = "Vector2";
  VertexElementFormat2[VertexElementFormat2["Vector3"] = 2] = "Vector3";
  VertexElementFormat2[VertexElementFormat2["Vector4"] = 3] = "Vector4";
  VertexElementFormat2[VertexElementFormat2["Byte4"] = 4] = "Byte4";
  VertexElementFormat2[VertexElementFormat2["UByte4"] = 5] = "UByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat2[VertexElementFormat2["Short2"] = 8] = "Short2";
  VertexElementFormat2[VertexElementFormat2["UShort2"] = 9] = "UShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat2[VertexElementFormat2["Short4"] = 12] = "Short4";
  VertexElementFormat2[VertexElementFormat2["UShort4"] = 13] = "UShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));
var IndexFormat;
(function(IndexFormat2) {
  IndexFormat2[IndexFormat2["UInt8"] = 0] = "UInt8";
  IndexFormat2[IndexFormat2["UInt16"] = 1] = "UInt16";
  IndexFormat2[IndexFormat2["UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));
var BufferUtil = function() {
  function BufferUtil2() {
  }
  BufferUtil2._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
    switch (bufferUsage) {
      case BufferUsage.Static:
        return gl.STATIC_DRAW;
      case BufferUsage.Dynamic:
        return gl.DYNAMIC_DRAW;
      case BufferUsage.Stream:
        return gl.STREAM_DRAW;
    }
  };
  BufferUtil2._getGLIndexType = function _getGLIndexType(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return DataType.UNSIGNED_BYTE;
      case IndexFormat.UInt16:
        return DataType.UNSIGNED_SHORT;
      case IndexFormat.UInt32:
        return DataType.UNSIGNED_INT;
    }
  };
  BufferUtil2._getElementInfo = function _getElementInfo(format) {
    var size;
    var type;
    switch (format) {
      case VertexElementFormat.Float:
        size = 1;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector2:
        size = 2;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector3:
        size = 3;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector4:
        size = 4;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Byte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        break;
      case VertexElementFormat.Short2:
        size = 2;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.Short4:
        size = 4;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.UShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        break;
    }
    return {
      size,
      type
    };
  };
  return BufferUtil2;
}();
var BufferBindFlag;
(function(BufferBindFlag2) {
  BufferBindFlag2[BufferBindFlag2["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag2[BufferBindFlag2["IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));
var SetDataOptions;
(function(SetDataOptions2) {
  SetDataOptions2[SetDataOptions2["None"] = 0] = "None";
  SetDataOptions2[SetDataOptions2["Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));
var Buffer = function(_RefObject) {
  _inheritsLoose(Buffer2, _RefObject);
  function Buffer2(engine, type, byteLengthOrData, bufferUsage) {
    var _this;
    if (bufferUsage === void 0) {
      bufferUsage = BufferUsage.Static;
    }
    _this = _RefObject.call(this, engine) || this;
    _this._glBindTarget = void 0;
    _this._glBufferUsage = void 0;
    _this._nativeBuffer = void 0;
    _this._hardwareRenderer = void 0;
    _this._type = void 0;
    _this._byteLength = void 0;
    _this._bufferUsage = void 0;
    _this._engine = engine;
    _this._type = type;
    _this._bufferUsage = bufferUsage;
    var hardwareRenderer = engine._hardwareRenderer;
    var gl = hardwareRenderer.gl;
    var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);
    var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    _this._nativeBuffer = gl.createBuffer();
    _this._hardwareRenderer = hardwareRenderer;
    _this._glBufferUsage = glBufferUsage;
    _this._glBindTarget = glBindTarget;
    _this.bind();
    if (typeof byteLengthOrData === "number") {
      _this._byteLength = byteLengthOrData;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    } else {
      _this._byteLength = byteLengthOrData.byteLength;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    }
    gl.bindBuffer(glBindTarget, null);
    return _this;
  }
  var _proto = Buffer2.prototype;
  _proto.bind = function bind() {
    var gl = this._hardwareRenderer.gl;
    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
  };
  _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }
    if (dataOffset === void 0) {
      dataOffset = 0;
    }
    if (options === void 0) {
      options = SetDataOptions.None;
    }
    var gl = this._hardwareRenderer.gl;
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    var glBindTarget = this._glBindTarget;
    this.bind();
    if (options === SetDataOptions.Discard) {
      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
    }
    var byteSize = data.BYTES_PER_ELEMENT || 1;
    var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
    if (dataOffset !== 0 || dataByteLength < data.byteLength) {
      var isArrayBufferView = data.byteOffset !== void 0;
      if (isWebGL2 && isArrayBufferView) {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
      } else {
        var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
      }
    } else {
      gl.bufferSubData(glBindTarget, bufferByteOffset, data);
    }
    gl.bindBuffer(glBindTarget, null);
  };
  _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
    if (bufferByteOffset === void 0) {
      bufferByteOffset = 0;
    }
    if (dataOffset === void 0) {
      dataOffset = 0;
    }
    var isWebGL2 = this._hardwareRenderer.isWebGL2;
    if (isWebGL2) {
      var gl = this._hardwareRenderer.gl;
      this.bind();
      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
    } else {
      throw "Buffer is write-only on WebGL1.0 platforms.";
    }
  };
  _proto._onDestroy = function _onDestroy() {
    var gl = this._hardwareRenderer.gl;
    gl.deleteBuffer(this._nativeBuffer);
    this._nativeBuffer = null;
    this._hardwareRenderer = null;
  };
  _proto.resize = function resize(dataLength) {
    this.bind();
    var gl = this._hardwareRenderer.gl;
    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
    this._byteLength = dataLength;
  };
  _createClass(Buffer2, [{
    key: "engine",
    get: function get4() {
      return this._engine;
    }
  }, {
    key: "type",
    get: function get4() {
      return this._type;
    }
  }, {
    key: "byteLength",
    get: function get4() {
      return this._byteLength;
    }
  }, {
    key: "bufferUsage",
    get: function get4() {
      return this._bufferUsage;
    }
  }]);
  return Buffer2;
}(RefObject);
var PrimitiveTopology;
(function(PrimitiveTopology2) {
  PrimitiveTopology2[PrimitiveTopology2["Points"] = 0] = "Points";
  PrimitiveTopology2[PrimitiveTopology2["Lines"] = 1] = "Lines";
  PrimitiveTopology2[PrimitiveTopology2["LineLoop"] = 2] = "LineLoop";
  PrimitiveTopology2[PrimitiveTopology2["LineStrip"] = 3] = "LineStrip";
  PrimitiveTopology2[PrimitiveTopology2["Triangles"] = 4] = "Triangles";
  PrimitiveTopology2[PrimitiveTopology2["TriangleStrip"] = 5] = "TriangleStrip";
  PrimitiveTopology2[PrimitiveTopology2["TriangleFan"] = 6] = "TriangleFan";
})(PrimitiveTopology || (PrimitiveTopology = {}));
var IndexBufferBinding = function() {
  function IndexBufferBinding2(buffer, format) {
    this._buffer = void 0;
    this._format = void 0;
    this._buffer = buffer;
    this._format = format;
  }
  _createClass(IndexBufferBinding2, [{
    key: "buffer",
    get: function get4() {
      return this._buffer;
    }
  }, {
    key: "format",
    get: function get4() {
      return this._format;
    }
  }]);
  return IndexBufferBinding2;
}();
var VertexBufferBinding = function() {
  function VertexBufferBinding2(buffer, stride) {
    this._buffer = void 0;
    this._stride = void 0;
    this._buffer = buffer;
    this._stride = stride;
  }
  _createClass(VertexBufferBinding2, [{
    key: "buffer",
    get: function get4() {
      return this._buffer;
    }
  }, {
    key: "stride",
    get: function get4() {
      return this._stride;
    }
  }]);
  return VertexBufferBinding2;
}();
var Primitive = function(_RefObject) {
  _inheritsLoose(Primitive2, _RefObject);
  function Primitive2(engine, name) {
    var _this;
    _this = _RefObject.call(this, engine) || this;
    _this.name = void 0;
    _this.instanceCount = 0;
    _this._macroCollection = new ShaderMacroCollection();
    _this._vertexElementMap = {};
    _this._glIndexType = void 0;
    _this._platformPrimitive = void 0;
    _this._vertexBufferBindings = [];
    _this._indexBufferBinding = null;
    _this._vertexElements = [];
    _this.targets = [];
    _this.name = name;
    _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = Primitive2.prototype;
  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, firstIndex) {
    if (strideOrFirstIndex === void 0) {
      strideOrFirstIndex = 0;
    }
    if (firstIndex === void 0) {
      firstIndex = 0;
    }
    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== void 0;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    var bindings = this._vertexBufferBindings;
    bindings.length <= firstIndex && (bindings.length = firstIndex + 1);
    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : firstIndex, binding);
  };
  _proto.setVertexBufferBindings = function setVertexBufferBindings(bufferBindings, firstIndex) {
    if (firstIndex === void 0) {
      firstIndex = 0;
    }
    var bindings = this._vertexBufferBindings;
    var count = bufferBindings.length;
    var needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);
    for (var i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, bufferBindings[i]);
    }
  };
  _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
    var binding = bufferOrBinding;
    var isBinding = binding.buffer !== void 0;
    isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
    this._indexBufferBinding = binding;
    this._glIndexType = BufferUtil._getGLIndexType(binding.format);
  };
  _proto.setVertexElements = function setVertexElements(elements) {
    this._clearVertexElements();
    for (var i = 0, n = elements.length; i < n; i++) {
      this._addVertexElement(elements[i]);
    }
  };
  _proto._draw = function _draw(shaderProgram, subPrimitive) {
    this._platformPrimitive.draw(shaderProgram, subPrimitive);
  };
  _proto._addRefCount = function _addRefCount(value) {
    _RefObject.prototype._addRefCount.call(this, value);
    var vertexBufferBindings = this._vertexBufferBindings;
    for (var i = 0, n = vertexBufferBindings.length; i < n; i++) {
      vertexBufferBindings[i]._buffer._addRefCount(value);
    }
  };
  _proto._onDestroy = function _onDestroy() {
    this._vertexBufferBindings = null;
    this._indexBufferBinding = null;
    this._vertexElements = null;
    this._vertexElementMap = null;
    this._platformPrimitive.destroy();
  };
  _proto._clearVertexElements = function _clearVertexElements() {
    this._vertexElements.length = 0;
    var vertexElementMap = this._vertexElementMap;
    for (var k in vertexElementMap) {
      delete vertexElementMap[k];
    }
    this._macroCollection.disable(Primitive2._uvMacro);
    this._macroCollection.disable(Primitive2._normalMacro);
    this._macroCollection.disable(Primitive2._tangentMacro);
    this._macroCollection.disable(Primitive2._vertexColorMacro);
    this._macroCollection.disable(Primitive2._vertexAlphaMacro);
  };
  _proto._addVertexElement = function _addVertexElement(element) {
    var semantic = element.semantic, format = element.format;
    this._vertexElementMap[semantic] = element;
    this._vertexElements.push(element);
    switch (semantic) {
      case "TEXCOORD_0":
        this._macroCollection.enable(Primitive2._uvMacro);
        break;
      case "NORMAL":
        this._macroCollection.enable(Primitive2._normalMacro);
        break;
      case "TANGENT":
        this._macroCollection.enable(Primitive2._tangentMacro);
        break;
      case "COLOR_0":
        this._macroCollection.enable(Primitive2._vertexColorMacro);
        if (format === VertexElementFormat.Vector4)
          this._macroCollection.enable(Primitive2._vertexAlphaMacro);
        break;
    }
  };
  _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
    if (this._getRefCount() > 0) {
      var lastBinding = this._vertexBufferBindings[index];
      lastBinding && lastBinding._buffer._addRefCount(-1);
      binding._buffer._addRefCount(1);
    }
    this._vertexBufferBindings[index] = binding;
  };
  _createClass(Primitive2, [{
    key: "vertexBufferBindings",
    get: function get4() {
      return this._vertexBufferBindings;
    }
  }, {
    key: "vertexElements",
    get: function get4() {
      return this._vertexElements;
    }
  }, {
    key: "indexBufferBinding",
    get: function get4() {
      return this._indexBufferBinding;
    }
  }]);
  return Primitive2;
}(RefObject);
Primitive._uvMacro = Shader.getMacroByName("O3_HAS_UV");
Primitive._normalMacro = Shader.getMacroByName("O3_HAS_NORMAL");
Primitive._tangentMacro = Shader.getMacroByName("O3_HAS_TANGENT");
Primitive._vertexColorMacro = Shader.getMacroByName("O3_HAS_VERTEXCOLOR");
Primitive._vertexAlphaMacro = Shader.getMacroByName("O3_HAS_VERTEXALPHA");
var VertexElement = function() {
  function VertexElement2(semantic, offset, format, bindingIndex, instanceStepRate) {
    if (instanceStepRate === void 0) {
      instanceStepRate = 0;
    }
    this.normalized = false;
    this._glElementInfo = void 0;
    this._semantic = void 0;
    this._offset = void 0;
    this._format = void 0;
    this._bindingIndex = void 0;
    this._instanceStepRate = void 0;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }
  _createClass(VertexElement2, [{
    key: "semantic",
    get: function get4() {
      return this._semantic;
    }
  }, {
    key: "offset",
    get: function get4() {
      return this._offset;
    }
  }, {
    key: "format",
    get: function get4() {
      return this._format;
    }
  }, {
    key: "bindingIndex",
    get: function get4() {
      return this._bindingIndex;
    }
  }, {
    key: "instanceStepRate",
    get: function get4() {
      return this._instanceStepRate;
    }
  }, {
    key: "elementInfo",
    get: function get4() {
      return this._glElementInfo;
    }
  }]);
  return VertexElement2;
}();
var SubPrimitive = function SubPrimitive2(start, count, topology) {
  if (start === void 0) {
    start = 0;
  }
  if (count === void 0) {
    count = 0;
  }
  if (topology === void 0) {
    topology = PrimitiveTopology.Triangles;
  }
  this.start = void 0;
  this.count = void 0;
  this.topology = void 0;
  this.start = start;
  this.count = count;
  this.topology = topology;
};
var SpriteRenderer = function(_Renderer) {
  _inheritsLoose(SpriteRenderer2, _Renderer);
  function SpriteRenderer2(entity) {
    var _this;
    _this = _Renderer.call(this, entity) || this;
    _this._uvRect = void 0;
    _this._worldSize = [];
    _this._positionQuad = void 0;
    _this._rotationAngle = 0;
    _this._anchor = void 0;
    _this._texture = void 0;
    _this._rect = void 0;
    _this._worldSizeFactor = void 0;
    _this.renderMode = "2D";
    _this.tintColor = new Vector4(1, 1, 1, 1);
    _this.transformMatrix = void 0;
    _this._worldSizeFactor = 100;
    _this.setTexture(void 0);
    _this.setRect(void 0);
    _this.setAnchor(void 0);
    _this.setUvRect();
    _this.setWorldSize();
    _this._positionQuad = {
      leftTop: new Vector3(),
      leftBottom: new Vector3(),
      rightTop: new Vector3(),
      rightBottom: new Vector3()
    };
    return _this;
  }
  var _proto = SpriteRenderer2.prototype;
  _proto.setTexture = function setTexture(texture) {
    if (texture && texture.asset) {
      texture = texture.asset;
    }
    this._texture = texture;
  };
  _proto.setRect = function setRect(rect) {
    var _this$_texture$width, _this$_texture, _this$_texture$height, _this$_texture2;
    var rectObject;
    try {
      if (rect) {
        rectObject = JSON.parse(rect);
      }
    } catch (error2) {
      Logger.warn("Rect is not valid JSON format");
    }
    this._rect = rect || {
      x: 0,
      y: 0,
      width: (_this$_texture$width = (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.width) != null ? _this$_texture$width : 0,
      height: (_this$_texture$height = (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.height) != null ? _this$_texture$height : 0
    };
  };
  _proto.setAnchor = function setAnchor(anchor) {
    this._anchor = anchor || [0.5, 0.5];
  };
  _proto.setWorldSize = function setWorldSize() {
    var _worldSizeFactor = this._worldSizeFactor;
    this._worldSize = [this._rect.width / _worldSizeFactor, this._rect.height / _worldSizeFactor];
  };
  _proto.setUvRect = function setUvRect() {
    var w, h;
    if (this._texture) {
      w = this._texture.width;
      h = this._texture.height;
    } else {
      w = this._rect.width;
      h = this._rect.height;
    }
    this._uvRect = {
      u: this._rect.x / w,
      v: this._rect.y / h,
      width: this._rect.width / w,
      height: this._rect.height / h
    };
  };
  _proto.render = function render(camera) {
    this._updatePositionQuad(camera);
    this._transformByMatrix();
    camera._renderPipeline.pushSprite(this, this._positionQuad, this._uvRect, this.tintColor, this.texture, this.renderMode, camera);
  };
  _proto._transformByMatrix = function _transformByMatrix() {
    if (!this.transformMatrix)
      return;
    var matrix = this.transformMatrix;
    var temp = this._positionQuad.leftTop;
    var leftTop = SpriteRenderer2._tempVec40;
    leftTop.setValue(temp.x, temp.y, temp.z, 1);
    temp = this._positionQuad.leftBottom;
    var leftBottom = SpriteRenderer2._tempVec41;
    leftBottom.setValue(temp.x, temp.y, temp.z, 1);
    temp = this._positionQuad.rightTop;
    var rightTop = SpriteRenderer2._tempVec42;
    rightTop.setValue(temp.x, temp.y, temp.z, 1);
    temp = this._positionQuad.rightBottom;
    var rightBottom = SpriteRenderer2._tempVec43;
    rightBottom.setValue(temp.x, temp.y, temp.z, 1);
    Vector4.transform(leftTop, matrix, leftTop);
    Vector4.transform(leftBottom, matrix, leftBottom);
    Vector4.transform(rightTop, matrix, rightTop);
    Vector4.transform(rightBottom, matrix, rightBottom);
    this._positionQuad.leftTop.setValue(leftTop.x, leftTop.y, leftTop.z);
    this._positionQuad.leftBottom.setValue(leftBottom.x, leftBottom.y, leftBottom.z);
    this._positionQuad.rightTop.setValue(rightTop.x, rightTop.y, rightTop.z);
    this._positionQuad.rightBottom.setValue(rightBottom.x, rightBottom.y, rightBottom.z);
  };
  _proto._updatePositionQuad = function _updatePositionQuad(camera) {
    if (this.renderMode === "2D") {
      var m = camera.viewMatrix.elements;
      var vx = new Vector3(m[0], m[4], m[8]);
      var vy = new Vector3(m[1], m[5], m[9]);
      var c = this.entity.worldPosition.clone();
      var s = this._worldSize;
      var ns = this.entity.scale;
      vx.scale(s[0] * ns.x);
      vy.scale(s[1] * ns.y);
      if (this._rotationAngle !== 0) {
        var vz = new Vector3(m[2], m[6], m[10]);
        var rotation = new Quaternion();
        Quaternion.rotationAxisAngle(vz, this._rotationAngle, rotation);
        Vector3.transformByQuat(vx, rotation, vx);
        Vector3.transformByQuat(vy, rotation, vy);
      }
      var cx = new Vector3();
      var cy = new Vector3();
      Vector3.scale(vx, (this.anchor[0] - 0.5) * 2, cx);
      Vector3.scale(vy, (this.anchor[1] - 0.5) * 2, cy);
      c.subtract(cx).add(cy);
      var leftTop = this._positionQuad.leftTop;
      Vector3.subtract(c, vx, leftTop);
      leftTop.add(vy);
      var leftBottom = this._positionQuad.leftBottom;
      Vector3.subtract(c, vx, leftBottom);
      leftBottom.subtract(vy);
      var rightBottom = this._positionQuad.rightBottom;
      Vector3.add(c, vx, rightBottom);
      rightBottom.subtract(vy);
      var rightTop = this._positionQuad.rightTop;
      Vector3.add(c, vx, rightTop);
      rightTop.add(vy);
    }
  };
  _createClass(SpriteRenderer2, [{
    key: "texture",
    get: function get4() {
      return this._texture;
    },
    set: function set4(v) {
      this.setTexture(v);
      this.setRect();
      this.setUvRect();
      this.setWorldSize();
    }
  }, {
    key: "anchor",
    get: function get4() {
      return this._anchor;
    },
    set: function set4(v) {
      this._anchor = v || [0.5, 0.5];
    }
  }, {
    key: "rect",
    get: function get4() {
      return this._rect;
    },
    set: function set4(v) {
      this.setRect(v);
      this.setUvRect();
      this.setWorldSize();
    }
  }, {
    key: "rotationAngle",
    get: function get4() {
      return this._rotationAngle;
    },
    set: function set4(v) {
      this._rotationAngle = v;
    }
  }]);
  return SpriteRenderer2;
}(Renderer);
SpriteRenderer._tempVec40 = new Vector4();
SpriteRenderer._tempVec41 = new Vector4();
SpriteRenderer._tempVec42 = new Vector4();
SpriteRenderer._tempVec43 = new Vector4();
var WrapMode;
(function(WrapMode2) {
  WrapMode2[WrapMode2["ONCE"] = 0] = "ONCE";
  WrapMode2[WrapMode2["LOOP"] = 1] = "LOOP";
})(WrapMode || (WrapMode = {}));
var AnimationEventType;
(function(AnimationEventType2) {
  AnimationEventType2[AnimationEventType2["FINISHED"] = 0] = "FINISHED";
  AnimationEventType2[AnimationEventType2["LOOP_END"] = 1] = "LOOP_END";
  AnimationEventType2[AnimationEventType2["FRAME_EVENT"] = 2] = "FRAME_EVENT";
})(AnimationEventType || (AnimationEventType = {}));
var InterpolationType;
(function(InterpolationType2) {
  InterpolationType2[InterpolationType2["LINEAR"] = 0] = "LINEAR";
  InterpolationType2[InterpolationType2["CUBICSPLINE"] = 1] = "CUBICSPLINE";
  InterpolationType2[InterpolationType2["STEP"] = 2] = "STEP";
})(InterpolationType || (InterpolationType = {}));
var TagetType;
(function(TagetType2) {
  TagetType2[TagetType2["position"] = 0] = "position";
  TagetType2[TagetType2["rotation"] = 1] = "rotation";
  TagetType2[TagetType2["scale"] = 2] = "scale";
  TagetType2[TagetType2["other"] = 3] = "other";
})(TagetType || (TagetType = {}));
var AnimationClip = function(_EngineObject) {
  _inheritsLoose(AnimationClip2, _EngineObject);
  function AnimationClip2(name) {
    var _this;
    _this = _EngineObject.call(this, null) || this;
    _this.name = name;
    _this.duration = void 0;
    _this.durationIndex = void 0;
    _this.samplers = void 0;
    _this.channels = void 0;
    _this.samplers = [];
    _this.channels = [];
    return _this;
  }
  var _proto = AnimationClip2.prototype;
  _proto.addSampler = function addSampler(_input, _output, _outputSize, _interpolation) {
    if (_interpolation === void 0) {
      _interpolation = InterpolationType.LINEAR;
    }
    if (_interpolation === InterpolationType.CUBICSPLINE) {
      if (_outputSize <= 4) {
        _interpolation = InterpolationType.LINEAR;
      } else {
        _outputSize /= 3;
      }
    }
    var sampler = {
      input: _input,
      output: _output,
      outputSize: _outputSize,
      interpolation: _interpolation
    };
    this.samplers.push(sampler);
  };
  _proto.addChannel = function addChannel(samplerIndex, targetID, targetPath) {
    var bindSampler = this.samplers[samplerIndex];
    var tagetType = AnimationClip2._tagetTypeMap[targetPath];
    var channel = {
      sampler: bindSampler,
      target: {
        id: targetID,
        path: targetPath,
        pathType: tagetType != null ? tagetType : TagetType.other
      }
    };
    this.channels.push(channel);
  };
  _proto.getChannelCount = function getChannelCount() {
    return this.channels.length;
  };
  _proto.getChannelObject = function getChannelObject(channelIndex) {
    return this.channels[channelIndex];
  };
  _proto.getFrameCount = function getFrameCount(channelIndex) {
    var sampler = this.channels[channelIndex].sampler;
    return sampler.input.length;
  };
  _proto.getFrameTime = function getFrameTime(channelIndex, frameIndex) {
    var sampler = this.channels[channelIndex].sampler;
    return sampler.input[frameIndex];
  };
  _proto.getChannelTimeLength = function getChannelTimeLength(channelIndex) {
    var sampler = this.channels[channelIndex].sampler;
    var frameCount = sampler.input.length;
    return sampler.input[frameCount - 1];
  };
  _proto.createChannelValue = function createChannelValue(channelIndex) {
    var sampler = this.channels[channelIndex].sampler;
    return new Float32Array(sampler.outputSize);
  };
  _proto.evaluate = function evaluate(outValue, channelIndex, frameIndex, nextFrameIndex, alpha) {
    var channel = this.channels[channelIndex];
    var output = channel.sampler.output;
    var outputSize = channel.sampler.outputSize;
    switch (channel.sampler.interpolation) {
      case InterpolationType.CUBICSPLINE:
        this.evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
        break;
      case InterpolationType.LINEAR:
        this.evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
        break;
    }
    return outValue;
  };
  _proto.evaluateCubicSpline = function evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
    var squared = alpha * alpha;
    var cubed = alpha * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + alpha;
    var part4 = cubed - squared;
    for (var i = outputSize; i >= 0; i--) {
      var t1 = output[frameIndex * outputSize * 3 + i];
      var v1 = output[frameIndex * outputSize * 3 + outputSize + i];
      var t2 = output[frameIndex * outputSize * 3 + outputSize * 2 + i];
      var v2 = output[nextFrameIndex * outputSize * 3 + outputSize + i];
      outValue[i] = v1 * part1 + v2 * part2 + t1 * part3 + t2 * part4;
    }
  };
  _proto.evaluateLinear = function evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
    switch (outputSize) {
      case 1:
        outValue[0] = output[frameIndex] * (1 - alpha) + output[nextFrameIndex] * alpha;
        break;
      case 4:
        this._quaSlerp(outValue, output, frameIndex * outputSize, output, nextFrameIndex * outputSize, alpha);
        break;
      default:
        for (var i = outputSize; i >= 0; i--) {
          outValue[i] = output[frameIndex * outputSize + i] * (1 - alpha) + output[nextFrameIndex * outputSize + i] * alpha;
        }
        break;
    }
  };
  _proto._quaSlerp = function _quaSlerp(out, a, aIndex, b, bIndex, t) {
    var ax = a[0 + aIndex], ay = a[1 + aIndex], az = a[2 + aIndex], aw = a[3 + aIndex];
    var bx = b[0 + bIndex], by = b[1 + bIndex], bz = b[2 + bIndex], bw = b[3 + bIndex];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > 1e-6) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  };
  return AnimationClip2;
}(EngineObject);
AnimationClip._tagetTypeMap = {
  position: TagetType.position,
  rotation: TagetType.rotation,
  scale: TagetType.scale
};
var AnimationLayer = function(_EventDispatcher) {
  _inheritsLoose(AnimationLayer2, _EventDispatcher);
  function AnimationLayer2() {
    var _this;
    _this = _EventDispatcher.call(this, null) || this;
    _this.layerWeight = void 0;
    _this.mixTagetLayer = void 0;
    _this.isFading = void 0;
    _this.fadeDeltaTime = void 0;
    _this.crossFadeDuration = void 0;
    _this.fadeDuration = void 0;
    _this.crossFadeDeltaTime = void 0;
    _this.isMixLayer = void 0;
    _this.hasMixLayer = void 0;
    _this.mixEntity = void 0;
    _this._activedEvents = void 0;
    _this._animClip = void 0;
    _this._isPlaying = void 0;
    _this._wrapMode = void 0;
    _this._channelStates = void 0;
    _this._animClipLength = void 0;
    _this._frameEvents = void 0;
    _this.layerWeight = 1;
    _this._activedEvents = [];
    return _this;
  }
  var _proto = AnimationLayer2.prototype;
  _proto.canMix = function canMix(nextAnimClip, rootEntity) {
    if (!this._animClip || !this._isPlaying || this.isMixLayer || this.isFading) {
      return false;
    }
    if (this._animClip.getChannelCount() !== nextAnimClip.getChannelCount()) {
      return false;
    }
    var count = this._animClip.getChannelCount();
    for (var i = count - 1; i >= 0; i--) {
      var curChannel = this._animClip.getChannelObject(i);
      var curTargetObject = this._findChannelTarget(rootEntity, curChannel.target);
      var nextChannel = nextAnimClip.getChannelObject(i);
      var nextTargetObject = this._findChannelTarget(rootEntity, nextChannel.target);
      if (curTargetObject !== nextTargetObject) {
        return false;
      }
    }
    return true;
  };
  _proto.mix = function mix(animClip, targetLayer, rootEntity, mixEntity, options) {
    if (options === void 0) {
      options = {};
    }
    this._isPlaying = targetLayer.isPlaying;
    this._animClip = animClip;
    this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : targetLayer._wrapMode;
    this._addEvents(options);
    this._channelStates = [];
    this._animClipLength = 0;
    if (this._isPlaying) {
      var targetChannelStates = targetLayer._channelStates;
      var count = this._animClip.getChannelCount();
      for (var i = count - 1; i >= 0; i--) {
        var channel = this._animClip.getChannelObject(i);
        var targetObject = this._findChannelTarget(mixEntity, channel.target);
        this._channelStates[i] = {
          frameTime: 0,
          currentFrame: 0,
          currentValue: this._animClip.createChannelValue(i),
          mixWeight: targetObject ? 1 : 0
        };
        targetChannelStates[i].mixWeight = targetChannelStates[i].mixWeight === void 0 ? 1 : targetChannelStates[i].mixWeight;
        if (targetChannelStates[i].mixWeight === 1) {
          targetChannelStates[i].mixWeight = targetObject ? 0 : 1;
        }
        var channelTimeLength = this._animClip.getChannelTimeLength(i);
        this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
      }
      return true;
    }
    return false;
  };
  _proto.removeMixWeight = function removeMixWeight() {
    var count = this._channelStates.length;
    for (var i = count - 1; i >= 0; i--) {
      if (this._channelStates[i].mixWeight === 1) {
        this.mixTagetLayer._channelStates[i].mixWeight = 1;
      }
    }
  };
  _proto.play = function play(animClip, rootEntity, options) {
    if (options === void 0) {
      options = {
        wrapMode: WrapMode.LOOP
      };
    }
    this._isPlaying = !!animClip;
    this._animClip = animClip;
    this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : WrapMode.LOOP;
    this._addEvents(options);
    this._channelStates = [];
    this._animClipLength = 0;
    if (this._isPlaying) {
      var count = this._animClip.getChannelCount();
      var channelTargets = [];
      for (var i = count - 1; i >= 0; i--) {
        var channel = this._animClip.getChannelObject(i);
        var targetObject = this._findChannelTarget(rootEntity, channel.target);
        if (!targetObject) {
          Logger.warn("Can not find channel target:" + channel.target.id);
        }
        this._channelStates[i] = {
          frameTime: 0,
          currentFrame: 0,
          currentValue: this._animClip.createChannelValue(i)
        };
        channelTargets[i] = {
          targetObject,
          path: channel.target.path,
          pathType: channel.target.pathType,
          outputSize: channel.sampler.outputSize
        };
        var channelTimeLength = this._animClip.getChannelTimeLength(i);
        this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
      }
      return channelTargets;
    }
    return false;
  };
  _proto.stop = function stop(rightnow) {
    if (!this._animClip || !this._isPlaying) {
      return;
    }
    if (rightnow) {
      this._isPlaying = false;
    } else {
      this._wrapMode = WrapMode.ONCE;
    }
  };
  _proto.updateState = function updateState(deltaTime) {
    if (!this._animClip || !this._isPlaying) {
      return;
    }
    if (this.isFading) {
      this.fadeDeltaTime += deltaTime;
      this.layerWeight = 1 - this.fadeDeltaTime / this.fadeDuration;
      if (this.layerWeight <= 0) {
        this._isPlaying = false;
      }
    } else if (this.crossFadeDuration) {
      this.crossFadeDeltaTime += deltaTime;
      this.layerWeight = this.crossFadeDeltaTime / this.crossFadeDuration;
      if (this.layerWeight >= 1) {
        this.layerWeight = 1;
        delete this.crossFadeDuration;
      }
    }
    deltaTime = deltaTime / 1e3;
    this._activeEvents(deltaTime);
    var count = this._animClip.getChannelCount();
    var playingCount = 0;
    for (var i = count - 1; i >= 0; i--) {
      if (this._updateChannelState(deltaTime, i)) {
        playingCount++;
      }
    }
    if (playingCount === 0) {
      this._isPlaying = false;
      if (this.isMixLayer) {
        this.removeMixWeight();
      }
    }
  };
  _proto.getChannelLayerWeight = function getChannelLayerWeight(channelIndex) {
    if ((this.hasMixLayer || this.isMixLayer) && channelIndex < this._channelStates.length) {
      var mixWeight = this._channelStates[channelIndex].mixWeight;
      var layerWeight = this.isMixLayer ? this.mixTagetLayer.layerWeight : this.layerWeight;
      return mixWeight * layerWeight;
    }
    return this.layerWeight;
  };
  _proto.getChannelValue = function getChannelValue(channelIndex) {
    return this._channelStates[channelIndex].currentValue;
  };
  _proto.triggerEvents = function triggerEvents() {
    var _this2 = this;
    this._activedEvents && this._activedEvents.forEach(function(event) {
      _this2.trigger(event);
    });
    this._activedEvents.length = 0;
  };
  _proto.jumpToFrame = function jumpToFrame(frameTime) {
    var count = this._animClip.getChannelCount();
    for (var i = count - 1; i >= 0; i--) {
      var channelState = this._channelStates[i];
      channelState.frameTime = 0;
      this._updateChannelState(frameTime, i);
    }
  };
  _proto._updateChannelState = function _updateChannelState(deltaTime, channelIndex) {
    var animClip = this._animClip;
    var channelState = this._channelStates[channelIndex];
    var animClipLength = animClip.getChannelTimeLength(channelIndex);
    channelState.frameTime += deltaTime;
    if (channelState.frameTime > animClipLength) {
      switch (this._wrapMode) {
        case WrapMode.ONCE:
          channelState.frameTime = animClipLength;
          break;
        case WrapMode.LOOP:
          channelState.frameTime = channelState.frameTime % this._animClipLength;
          break;
        default:
          Logger.error("Unknown Anim wrap Mode: " + this._wrapMode);
      }
    }
    if (channelState.mixWeight && channelState.mixWeight === 0) {
      return true;
    }
    var frameTime = Math.min(channelState.frameTime, animClipLength);
    var lerpState = this._getKeyAndAlpha(animClip.getChannelObject(channelIndex), frameTime);
    channelState.currentValue = animClip.evaluate(channelState.currentValue, channelIndex, lerpState.currentKey, lerpState.nextKey, lerpState.alpha);
    if (this._wrapMode === WrapMode.ONCE && channelState.frameTime >= animClipLength) {
      return false;
    }
    return true;
  };
  _proto._addEvents = function _addEvents(options) {
    var _this3 = this;
    this.removeAllEventListeners();
    this._frameEvents = [];
    if (options.events) {
      var frameEventIndex = 0;
      var _loop = function _loop2(i2) {
        var event = options.events[i2];
        var eventType = event.type;
        if (event.type === AnimationEventType.FRAME_EVENT) {
          eventType = "frameEvent" + frameEventIndex;
          frameEventIndex++;
          _this3._frameEvents.push({
            eventType,
            triggerTime: event.triggerTime,
            triggered: false
          });
        }
        _this3.addEventListener(eventType, function(e) {
          event.callback();
        });
      };
      for (var i = options.events.length - 1; i >= 0; i--) {
        _loop(i);
      }
    }
  };
  _proto._activeEvents = function _activeEvents(deltaTime) {
    var index = this._animClip.durationIndex;
    if (this._frameEvents.length > 0 && this._channelStates.length > 0) {
      var curFrameTime = this._channelStates[index].frameTime + deltaTime;
      for (var i = this._frameEvents.length - 1; i >= 0; i--) {
        var frameEvent = this._frameEvents[i];
        if (!frameEvent.triggered && curFrameTime > frameEvent.triggerTime) {
          this._activedEvents.push(new Event(frameEvent.eventType, this));
          frameEvent.triggered = true;
        }
      }
    }
    if (this._channelStates.length > 0 && this._channelStates[index].frameTime + deltaTime >= this._animClip.duration) {
      if (this._wrapMode === WrapMode.LOOP) {
        if (this._frameEvents.length > 0) {
          for (var _i = this._frameEvents.length - 1; _i >= 0; _i--) {
            this._frameEvents[_i].triggered = false;
          }
        }
        if (this.hasEvent(AnimationEventType.LOOP_END)) {
          this._activedEvents.push(new Event(AnimationEventType.LOOP_END, this));
        }
      } else if (this.hasEvent(AnimationEventType.FINISHED)) {
        this._activedEvents.push(new Event(AnimationEventType.FINISHED, this));
      }
    }
  };
  _proto._findChannelTarget = function _findChannelTarget(rootNode, target) {
    var targetID = target.id;
    var targetSceneObject = null;
    if (rootNode.name === targetID) {
      targetSceneObject = rootNode;
    } else {
      targetSceneObject = rootNode.findByName(targetID);
    }
    if (target.path === "weights") {
      return targetSceneObject.getComponent(SkinnedMeshRenderer);
    } else {
      return targetSceneObject;
    }
  };
  _proto._getKeyAndAlpha = function _getKeyAndAlpha(channel, time) {
    var keyTime = 0;
    var currentKey = 0;
    var nextKey = 0;
    var timeKeys = channel.sampler.input;
    var numKeys = timeKeys.length;
    for (var i = numKeys - 1; i >= 0; i--) {
      if (time > timeKeys[i]) {
        keyTime = time - timeKeys[i];
        currentKey = i;
        break;
      }
    }
    nextKey = currentKey + 1;
    if (nextKey >= numKeys) {
      switch (this._wrapMode) {
        case WrapMode.ONCE:
          nextKey = numKeys - 1;
          break;
        case WrapMode.LOOP:
          nextKey = 0;
          break;
      }
    }
    var keyLength = timeKeys[nextKey] - timeKeys[currentKey];
    var alpha = nextKey === currentKey || keyLength < 1e-5 ? 1 : keyTime / keyLength;
    return {
      currentKey,
      nextKey,
      alpha
    };
  };
  _createClass(AnimationLayer2, [{
    key: "isPlaying",
    get: function get4() {
      return this._animClip && this._isPlaying;
    }
  }]);
  return AnimationLayer2;
}(EventDispatcher);
var _class$9;
var _descriptor$9;
var _descriptor2$8;
var _descriptor3$6;
var _descriptor4$6;
var _descriptor5$5;
var _temp$9;
var Animation = (_class$9 = (_temp$9 = function(_Component) {
  _inheritsLoose(Animation2, _Component);
  Animation2.lerp = function lerp(outValue, startValue, endValue, alpha, outputSize) {
    switch (outputSize) {
      case 1:
        outValue = startValue * (1 - alpha) + endValue * alpha;
        break;
      case 4:
        var start = _construct(Quaternion, startValue);
        var end = _construct(Quaternion, endValue);
        var quat = new Quaternion();
        Quaternion.slerp(start, end, alpha, quat);
        outValue[0] = quat.x;
        outValue[1] = quat.y;
        outValue[2] = quat.z;
        outValue[3] = quat.w;
        break;
      default:
        for (var i = outputSize; i >= 0; i--) {
          outValue[i] = startValue[i] * (1 - alpha) + endValue[i] * alpha;
        }
        break;
    }
    return outValue;
  };
  function Animation2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _initializerDefineProperty(_this, "_onUpdateIndex", _descriptor$9, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animSet", _descriptor2$8, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_animLayers", _descriptor3$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_timeScale", _descriptor4$6, _assertThisInitialized(_this));
    _initializerDefineProperty(_this, "_channelTargets", _descriptor5$5, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = Animation2.prototype;
  _proto.update = function update(deltaTime) {
    if (!this.isPlaying()) {
      return;
    }
    deltaTime = deltaTime * this._timeScale;
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      var animLayer = this._animLayers[i];
      animLayer.updateState(deltaTime);
    }
    this._updateValues();
    for (var _i = this._animLayers.length - 1; _i >= 0; _i--) {
      var _animLayer = this._animLayers[_i];
      _animLayer.triggerEvents();
      if (!_animLayer.isPlaying && (_animLayer.isFading || _animLayer.isMixLayer)) {
        this._animLayers.splice(_i, 1);
        this._removeRefMixLayers(_animLayer);
      }
    }
  };
  _proto.addAnimationClip = function addAnimationClip(animClip, name) {
    this._animSet[name] = animClip;
  };
  _proto.removeAnimationClip = function removeAnimationClip(name) {
    var animClip = this._animSet[name];
    if (animClip) {
      delete this._animSet[name];
    }
  };
  _proto.getAnimationClipLength = function getAnimationClipLength(name) {
    var animClip = this._animSet[name];
    if (animClip) {
      return animClip.getChannelTimeLength(0);
    } else {
      return 0;
    }
  };
  _proto.getAnimationClip = function getAnimationClip(name) {
    return this._animSet[name] || null;
  };
  _proto.isPlaying = function isPlaying() {
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].isPlaying) {
        return true;
      }
    }
    return false;
  };
  _proto.playAnimationClip = function playAnimationClip(name, options) {
    var animClip = this._animSet[name];
    if (!animClip) {
      Logger.error("can not find anim clip: " + name);
      return;
    }
    var animLayer = null;
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      if (!this._animLayers[i].isFading && !this._animLayers[i].isMixLayer) {
        animLayer = this._animLayers[i];
        break;
      }
    }
    if (!animLayer) {
      animLayer = new AnimationLayer();
      this._animLayers.push(animLayer);
    }
    this._removeRefMixLayers(animLayer);
    this._channelTargets = animLayer.play(animClip, this.entity, options);
  };
  _proto.CrossFade = function CrossFade(name, crossFadeDuration, options) {
    var animClip = this._animSet[name];
    if (!animClip) {
      Logger.error("can not find anim clip: " + name);
      return;
    }
    if (!crossFadeDuration || crossFadeDuration < 0) {
      Logger.error("crossFadeDuration can not less than 0!");
      return;
    }
    var targetAnimLayer = null;
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].canMix(animClip, this.entity)) {
        targetAnimLayer = this._animLayers[i];
        break;
      }
    }
    if (targetAnimLayer) {
      for (var _i2 = this._animLayers.length - 1; _i2 >= 0; _i2--) {
        if (this._animLayers[_i2].isFading) {
          this._animLayers.splice(_i2, 1);
        }
      }
      targetAnimLayer.isFading = true;
      targetAnimLayer.fadeDuration = crossFadeDuration;
      targetAnimLayer.fadeDeltaTime = 0;
      var animLayer = new AnimationLayer();
      animLayer.crossFadeDuration = crossFadeDuration;
      animLayer.crossFadeDeltaTime = 0;
      animLayer.play(animClip, this.entity, options);
      this._animLayers.push(animLayer);
    } else {
      this.playAnimationClip(name, options);
    }
  };
  _proto.mix = function mix(name, mixBoneName, options) {
    var animClip = this._animSet[name];
    if (!animClip) {
      Logger.error("can not find anim clip: " + name);
      return;
    }
    var mixNode = this.entity.findByName(mixBoneName);
    if (!mixNode) {
      Logger.error("can not find mix bone!");
      return;
    }
    var targetAnimLayer = null;
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].canMix(animClip, this.entity)) {
        targetAnimLayer = this._animLayers[i];
        break;
      }
    }
    if (targetAnimLayer) {
      this._removeRefMixLayers(null, mixNode);
      targetAnimLayer.hasMixLayer = true;
      var animLayer = new AnimationLayer();
      animLayer.isMixLayer = true;
      animLayer.mixTagetLayer = targetAnimLayer;
      animLayer.mixEntity = mixNode;
      animLayer.mix(animClip, targetAnimLayer, this.entity, mixNode, options);
      this._animLayers.push(animLayer);
    }
  };
  _proto.stop = function stop(rightnow) {
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].isFading) {
        this._animLayers.splice(i, 1);
      } else {
        this._animLayers[i].stop(rightnow);
      }
    }
  };
  _proto.jumpToFrame = function jumpToFrame(frameTime) {
    frameTime = frameTime / 1e3;
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      this._animLayers[i].jumpToFrame(frameTime);
    }
    this._updateValues();
  };
  _proto._removeRefMixLayers = function _removeRefMixLayers(targetLayer, mixNode) {
    if (targetLayer && targetLayer.hasMixLayer) {
      for (var i = this._animLayers.length - 1; i >= 0; i--) {
        var animLayer = this._animLayers[i];
        if (animLayer.isMixLayer && animLayer.mixTagetLayer === targetLayer) {
          animLayer.removeMixWeight();
          this._animLayers.splice(i, 1);
        }
      }
    }
    if (mixNode) {
      for (var _i3 = this._animLayers.length - 1; _i3 >= 0; _i3--) {
        var _animLayer2 = this._animLayers[_i3];
        if (_animLayer2.isMixLayer && (_animLayer2.mixEntity === mixNode || _animLayer2.mixEntity.findByName(mixNode) || mixNode.findByName(_animLayer2.mixEntity))) {
          _animLayer2.removeMixWeight();
          this._animLayers.splice(_i3, 1);
        }
      }
    }
  };
  _proto._updateValues = function _updateValues() {
    if (this._animLayers.length === 0 || !this._channelTargets) {
      return;
    }
    for (var i = this._channelTargets.length - 1; i >= 0; i--) {
      var channelTarget = this._channelTargets[i];
      var val = this._getChannelValue(i, channelTarget.outputSize);
      var targetObject = channelTarget.targetObject;
      var path = channelTarget.path;
      if (path === "weights") {
        targetObject.setWeights(val);
      } else {
        var v = val;
        var transform = targetObject.transform;
        switch (channelTarget.pathType) {
          case TagetType.position:
            var position = transform.position;
            position.setValue(v[0], v[1], v[2]);
            transform.position = position;
            break;
          case TagetType.rotation:
            var rotation = transform.rotationQuaternion;
            rotation.setValue(v[0], v[1], v[2], v[3]);
            transform.rotationQuaternion = rotation;
            break;
          case TagetType.scale:
            var scale = transform.scale;
            scale.setValue(v[0], v[1], v[2]);
            transform.scale = scale;
            break;
          default:
            targetObject[path] = val;
        }
      }
    }
  };
  _proto._getChannelValue = function _getChannelValue(channelIndex, outputSize) {
    var weights = [];
    var values = [];
    for (var i = this._animLayers.length - 1; i >= 0; i--) {
      var weight = this._animLayers[i].getChannelLayerWeight(channelIndex);
      if (weight > 0) {
        weights.push(weight);
        values.push(this._animLayers[i].getChannelValue(channelIndex));
      }
    }
    if (values.length === 1) {
      return values[0];
    } else if (values.length === 2) {
      return Animation2.lerp(values[0], values[0], values[1], weights[1], outputSize);
    }
    Logger.error("Can not get channel value!");
    return false;
  };
  _proto._onEnable = function _onEnable() {
    this.engine._componentsManager.addOnUpdateAnimations(this);
  };
  _proto._onDisable = function _onDisable() {
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  };
  _createClass(Animation2, [{
    key: "timeScale",
    get: function get4() {
      return this._timeScale;
    },
    set: function set4(val) {
      if (val > 0) {
        this._timeScale = val;
      }
    }
  }]);
  return Animation2;
}(Component), _temp$9), _descriptor$9 = _applyDecoratedDescriptor(_class$9.prototype, "_onUpdateIndex", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer50() {
    return -1;
  }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class$9.prototype, "_animSet", [shallowClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer51() {
    return {};
  }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class$9.prototype, "_animLayers", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer52() {
    return [new AnimationLayer()];
  }
}), _descriptor4$6 = _applyDecoratedDescriptor(_class$9.prototype, "_timeScale", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer53() {
    return 1;
  }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class$9.prototype, "_channelTargets", [ignoreClone], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _class$9);
var BufferGeometry = function(_EngineObject) {
  _inheritsLoose(BufferGeometry2, _EngineObject);
  function BufferGeometry2(engine, name) {
    var _this;
    _this = _EngineObject.call(this, engine) || this;
    _this.name = void 0;
    _this._primitive = void 0;
    _this.bounds = new BoundingBox();
    _this._subGeometries = [];
    _this._primitive = new Primitive(engine);
    _this.name = name;
    return _this;
  }
  var _proto = BufferGeometry2.prototype;
  _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, stride, firstIndex) {
    if (stride === void 0) {
      stride = 0;
    }
    if (firstIndex === void 0) {
      firstIndex = 0;
    }
    this._primitive.setVertexBufferBinding(bufferOrBinding, stride, firstIndex);
  };
  _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
    if (firstIndex === void 0) {
      firstIndex = 0;
    }
    this._primitive.setVertexBufferBindings(vertexBufferBindings, firstIndex);
  };
  _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
    this._primitive.setIndexBufferBinding(bufferOrBinding, format);
  };
  _proto.setVertexElements = function setVertexElements(elements) {
    this._primitive.setVertexElements(elements);
  };
  _proto.addSubGeometry = function addSubGeometry(start, count, topology) {
    if (topology === void 0) {
      topology = PrimitiveTopology.Triangles;
    }
    var subGeometry = new SubPrimitive(start, count, topology);
    this._subGeometries.push(subGeometry);
    return subGeometry;
  };
  _proto.removeSubGeometry = function removeSubGeometry(subGeometry) {
    var subGeometries = this._subGeometries;
    var index = subGeometries.indexOf(subGeometry);
    if (index !== -1) {
      subGeometries.splice(index, 1);
    }
  };
  _proto.clearSubGeometry = function clearSubGeometry() {
    this._subGeometries.length = 0;
  };
  _proto.destroy = function destroy() {
    if (this._primitive) {
      this._primitive.destroy();
      this._primitive = null;
    }
  };
  _createClass(BufferGeometry2, [{
    key: "vertexBufferBindings",
    get: function get4() {
      return this._primitive.vertexBufferBindings;
    }
  }, {
    key: "indexBufferBinding",
    get: function get4() {
      return this._primitive.indexBufferBinding;
    }
  }, {
    key: "vertexElements",
    get: function get4() {
      return this._primitive.vertexElements;
    }
  }, {
    key: "subGeometry",
    get: function get4() {
      return this._subGeometries[0] || null;
    }
  }, {
    key: "subGeometries",
    get: function get4() {
      return this._subGeometries;
    }
  }, {
    key: "instanceCount",
    get: function get4() {
      return this._primitive.instanceCount;
    },
    set: function set4(count) {
      this._primitive.instanceCount = count;
    }
  }]);
  return BufferGeometry2;
}(EngineObject);
var GeometryRenderer = function(_Renderer) {
  _inheritsLoose(GeometryRenderer2, _Renderer);
  function GeometryRenderer2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Renderer.call.apply(_Renderer, [this].concat(args)) || this;
    _this._material = void 0;
    _this._geometry = void 0;
    return _this;
  }
  var _proto = GeometryRenderer2.prototype;
  _proto.render = function render(camera) {
    var geometry = this.geometry;
    if (geometry) {
      var subGeometries = geometry.subGeometries;
      var renderPipeline = camera._renderPipeline;
      var material = this._material;
      for (var i = 0, n = subGeometries.length; i < n; i++) {
        if (material) {
          var element = RenderElement.getFromPool();
          element.setValue(this, geometry._primitive, subGeometries[i], material);
          renderPipeline.pushPrimitive(element);
        }
      }
    } else {
      Logger.error("geometry is null.");
    }
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    var geometry = this._geometry;
    if (geometry) {
      var localBounds = geometry.bounds;
      var worldMatrix = this._entity.transform.worldMatrix;
      BoundingBox.transform(localBounds, worldMatrix, worldBounds);
    } else {
      worldBounds.min.setValue(0, 0, 0);
      worldBounds.max.setValue(0, 0, 0);
    }
  };
  _createClass(GeometryRenderer2, [{
    key: "geometry",
    get: function get4() {
      return this._geometry;
    },
    set: function set4(value) {
      if (this._geometry) {
        this._geometry._primitive._addRefCount(-1);
      }
      value._primitive._addRefCount(1);
      this._geometry = value;
    }
  }, {
    key: "material",
    get: function get4() {
      return this._material;
    },
    set: function set4(value) {
      if (this._material) {
        this._material._addRefCount(-1);
      }
      value._addRefCount(1);
      this._material = value;
    }
  }]);
  return GeometryRenderer2;
}(Renderer);
var ShapeGeometry = function(_BufferGeometry) {
  _inheritsLoose(ShapeGeometry2, _BufferGeometry);
  function ShapeGeometry2() {
    return _BufferGeometry.apply(this, arguments) || this;
  }
  var _proto = ShapeGeometry2.prototype;
  _proto._initialize = function _initialize(engine, vertices, indices) {
    var vertexStride = 32;
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("NORMAL", 12, VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 24, VertexElementFormat.Vector2, 0)];
    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
  };
  _proto._initBuffer = function _initBuffer(engine, vertices, indices, vertexStride, vertexElements) {
    var positionElement = vertexElements[0];
    var vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static);
    var indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Static);
    this.setVertexBufferBinding(vertexBuffer, vertexStride);
    this.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);
    this.setVertexElements(vertexElements);
    this.addSubGeometry(0, indices.length);
    this._computeBounds(positionElement, vertices);
  };
  _proto._computeBounds = function _computeBounds(positionElement, vertices) {
    var vertexElement = positionElement;
    var bufferIndex = vertexElement.bindingIndex;
    var vertexBufferBinding = this._primitive.vertexBufferBindings[bufferIndex];
    var stride = vertexBufferBinding.stride;
    var offset = vertexElement.offset;
    var vertexCount = vertexBufferBinding.buffer.byteLength / stride;
    var arrayBuffer = vertices;
    if (!(arrayBuffer instanceof ArrayBuffer)) {
      arrayBuffer = arrayBuffer.buffer;
    }
    var dataView = new DataView(arrayBuffer, offset);
    var min = new Vector3(Infinity, Infinity, Infinity);
    var max = new Vector3(-Infinity, -Infinity, -Infinity);
    for (var i = 0; i < vertexCount; i++) {
      var base = offset + stride * i;
      var position = new Vector3(dataView.getFloat32(base, true), dataView.getFloat32(base + 4, true), dataView.getFloat32(base + 8, true));
      Vector3.min(min, position, min);
      Vector3.max(max, position, max);
    }
    var bounds = this.bounds;
    min.cloneTo(bounds.min);
    max.cloneTo(bounds.max);
  };
  return ShapeGeometry2;
}(BufferGeometry);
var CuboidGeometry = function(_ShapeGeometry) {
  _inheritsLoose(CuboidGeometry2, _ShapeGeometry);
  function CuboidGeometry2(engine, width, height, depth) {
    var _this;
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (depth === void 0) {
      depth = 1;
    }
    _this = _ShapeGeometry.call(this, engine) || this;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2;
    var vertices = new Float32Array([
      -halfWidth,
      halfHeight,
      -halfDepth,
      0,
      1,
      0,
      0,
      0,
      halfWidth,
      halfHeight,
      -halfDepth,
      0,
      1,
      0,
      1,
      0,
      halfWidth,
      halfHeight,
      halfDepth,
      0,
      1,
      0,
      1,
      1,
      -halfWidth,
      halfHeight,
      halfDepth,
      0,
      1,
      0,
      0,
      1,
      -halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      -1,
      0,
      0,
      1,
      halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      -1,
      0,
      1,
      1,
      halfWidth,
      -halfHeight,
      halfDepth,
      0,
      -1,
      0,
      1,
      0,
      -halfWidth,
      -halfHeight,
      halfDepth,
      0,
      -1,
      0,
      0,
      0,
      -halfWidth,
      halfHeight,
      -halfDepth,
      -1,
      0,
      0,
      0,
      0,
      -halfWidth,
      halfHeight,
      halfDepth,
      -1,
      0,
      0,
      1,
      0,
      -halfWidth,
      -halfHeight,
      halfDepth,
      -1,
      0,
      0,
      1,
      1,
      -halfWidth,
      -halfHeight,
      -halfDepth,
      -1,
      0,
      0,
      0,
      1,
      halfWidth,
      halfHeight,
      -halfDepth,
      1,
      0,
      0,
      1,
      0,
      halfWidth,
      halfHeight,
      halfDepth,
      1,
      0,
      0,
      0,
      0,
      halfWidth,
      -halfHeight,
      halfDepth,
      1,
      0,
      0,
      0,
      1,
      halfWidth,
      -halfHeight,
      -halfDepth,
      1,
      0,
      0,
      1,
      1,
      -halfWidth,
      halfHeight,
      halfDepth,
      0,
      0,
      1,
      0,
      0,
      halfWidth,
      halfHeight,
      halfDepth,
      0,
      0,
      1,
      1,
      0,
      halfWidth,
      -halfHeight,
      halfDepth,
      0,
      0,
      1,
      1,
      1,
      -halfWidth,
      -halfHeight,
      halfDepth,
      0,
      0,
      1,
      0,
      1,
      -halfWidth,
      halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      1,
      0,
      halfWidth,
      halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      0,
      0,
      halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      0,
      1,
      -halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      1,
      1
    ]);
    var indices = new Uint16Array([
      0,
      2,
      1,
      2,
      0,
      3,
      4,
      6,
      7,
      6,
      4,
      5,
      8,
      10,
      9,
      10,
      8,
      11,
      12,
      14,
      15,
      14,
      12,
      13,
      16,
      18,
      17,
      18,
      16,
      19,
      20,
      22,
      23,
      22,
      20,
      21
    ]);
    _this._initialize(engine, vertices, indices);
    return _this;
  }
  return CuboidGeometry2;
}(ShapeGeometry);
var SphereGeometry = function(_ShapeGeometry) {
  _inheritsLoose(SphereGeometry2, _ShapeGeometry);
  function SphereGeometry2(engine, radius, horizontalSegments, verticalSegments, alphaStart, alphaRange, thetaStart, thetaRange) {
    var _this;
    if (radius === void 0) {
      radius = 1;
    }
    if (horizontalSegments === void 0) {
      horizontalSegments = 8;
    }
    if (verticalSegments === void 0) {
      verticalSegments = 6;
    }
    if (alphaStart === void 0) {
      alphaStart = 0;
    }
    if (alphaRange === void 0) {
      alphaRange = Math.PI * 2;
    }
    if (thetaStart === void 0) {
      thetaStart = 0;
    }
    if (thetaRange === void 0) {
      thetaRange = Math.PI;
    }
    _this = _ShapeGeometry.call(this, engine) || this;
    _this._parameters = void 0;
    _this._thetaEnd = void 0;
    _this._parameters = {
      radius: radius || 1,
      horizontalSegments: Math.max(3, Math.floor(horizontalSegments)),
      verticalSegments: Math.max(2, Math.floor(verticalSegments)),
      alphaStart,
      alphaRange,
      thetaStart,
      thetaRange
    };
    _this._thetaEnd = _this._parameters.thetaStart + _this._parameters.thetaRange;
    _this.initialize(engine);
    return _this;
  }
  var _proto = SphereGeometry2.prototype;
  _proto.initialize = function initialize(engine) {
    var _this$_parameters = this._parameters, verticalSegments = _this$_parameters.verticalSegments, horizontalSegments = _this$_parameters.horizontalSegments;
    var index = 0;
    var grid = [];
    var vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
    var indices = [];
    for (var iy = 0; iy <= verticalSegments; iy++) {
      var verticesRow = [];
      var v = iy / verticalSegments;
      for (var ix = 0; ix <= horizontalSegments; ix++) {
        var u = ix / horizontalSegments;
        var posX = -this._parameters.radius * Math.cos(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
        var posY = this._parameters.radius * Math.cos(this._parameters.thetaStart + v * this._parameters.thetaRange);
        var posZ = this._parameters.radius * Math.sin(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
        posX = Math.abs(posX) < 1e-6 ? 0 : posX;
        posY = Math.abs(posY) < 1e-6 ? 0 : posY;
        posZ = Math.abs(posZ) < 1e-6 ? 0 : posZ;
        var offset = index * 8;
        vertices[offset] = posX;
        vertices[offset + 1] = posY;
        vertices[offset + 2] = posZ;
        vertices[offset + 3] = posX;
        vertices[offset + 4] = posY;
        vertices[offset + 5] = posZ;
        vertices[offset + 6] = u;
        vertices[offset + 7] = 1 - v;
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (var _iy = 0; _iy < verticalSegments; _iy++) {
      for (var _ix = 0; _ix < horizontalSegments; _ix++) {
        var a = grid[_iy][_ix + 1];
        var b = grid[_iy][_ix];
        var c = grid[_iy + 1][_ix];
        var d = grid[_iy + 1][_ix + 1];
        if (_iy !== 0 || this._parameters.thetaStart > 0)
          indices.push(a, b, d);
        if (_iy !== verticalSegments - 1 || this._thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this._initialize(engine, vertices, Uint16Array.from(indices));
  };
  return SphereGeometry2;
}(ShapeGeometry);
var PlaneGeometry = function(_ShapeGeometry) {
  _inheritsLoose(PlaneGeometry2, _ShapeGeometry);
  function PlaneGeometry2(engine, width, height, horizontalSegments, verticalSegments) {
    var _this;
    if (width === void 0) {
      width = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (horizontalSegments === void 0) {
      horizontalSegments = 1;
    }
    if (verticalSegments === void 0) {
      verticalSegments = 1;
    }
    _this = _ShapeGeometry.call(this, engine) || this;
    _this._parameters = void 0;
    _this.halfWidth = void 0;
    _this.halfHeight = void 0;
    _this._parameters = {
      width,
      height,
      horizontalSegments: Math.floor(horizontalSegments),
      verticalSegments: Math.floor(verticalSegments)
    };
    _this.halfWidth = _this._parameters.width / 2;
    _this.halfHeight = _this._parameters.height / 2;
    _this.initialize(engine);
    return _this;
  }
  var _proto = PlaneGeometry2.prototype;
  _proto.initialize = function initialize(engine) {
    var _this$_parameters = this._parameters, verticalSegments = _this$_parameters.verticalSegments, horizontalSegments = _this$_parameters.horizontalSegments;
    var index = 0;
    var offset = 0;
    var grid = [];
    var vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
    var indices = new Uint16Array(verticalSegments * horizontalSegments * 6);
    for (var iy = 0; iy <= verticalSegments; iy++) {
      var verticesRow = [];
      var v = iy / verticalSegments;
      for (var ix = 0; ix <= horizontalSegments; ix++) {
        var u = ix / horizontalSegments;
        var posX = u * this._parameters.width - this.halfWidth;
        var posY = v * this._parameters.height - this.halfHeight;
        vertices[offset++] = posX;
        vertices[offset++] = posY;
        vertices[offset++] = 0;
        vertices[offset++] = 0;
        vertices[offset++] = 0;
        vertices[offset++] = 1;
        vertices[offset++] = u;
        vertices[offset++] = 1 - v;
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    index = 0;
    for (var _iy = 0; _iy < verticalSegments; _iy++) {
      for (var _ix = 0; _ix < horizontalSegments; _ix++) {
        var a = grid[_iy][_ix + 1];
        var b = grid[_iy][_ix];
        var c = grid[_iy + 1][_ix];
        var d = grid[_iy + 1][_ix + 1];
        indices[index++] = a;
        indices[index++] = c;
        indices[index++] = b;
        indices[index++] = a;
        indices[index++] = d;
        indices[index++] = c;
      }
    }
    this._initialize(engine, vertices, indices);
  };
  return PlaneGeometry2;
}(ShapeGeometry);
var CylinderGeometry = function(_ShapeGeometry) {
  _inheritsLoose(CylinderGeometry2, _ShapeGeometry);
  function CylinderGeometry2(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength, frontFace) {
    var _this;
    if (radiusTop === void 0) {
      radiusTop = 1;
    }
    if (radiusBottom === void 0) {
      radiusBottom = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radialSegments === void 0) {
      radialSegments = 8;
    }
    if (heightSegments === void 0) {
      heightSegments = 1;
    }
    if (openEnded === void 0) {
      openEnded = false;
    }
    if (thetaStart === void 0) {
      thetaStart = 0;
    }
    if (thetaLength === void 0) {
      thetaLength = 2 * Math.PI;
    }
    if (frontFace === void 0) {
      frontFace = FrontFace.CCW;
    }
    _this = _ShapeGeometry.call(this, engine) || this;
    _this.FrontFace = void 0;
    _this.index = void 0;
    _this.indexArray = void 0;
    _this.halfHeight = void 0;
    _this._parameters = void 0;
    _this._vertices = void 0;
    _this._indices = void 0;
    _this.FrontFace = frontFace;
    _this._parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    _this._vertices = [];
    _this._indices = [];
    _this.index = 0;
    _this.indexArray = [];
    _this.halfHeight = _this._parameters.height / 2;
    _this.generateTorso();
    if (_this._parameters.openEnded === false) {
      if (_this._parameters.radiusTop > 0)
        _this.generateCap(true);
      if (_this._parameters.radiusBottom > 0)
        _this.generateCap(false);
    }
    _this._initialize(engine, Float32Array.from(_this._vertices), Uint16Array.from(_this._indices));
    return _this;
  }
  var _proto = CylinderGeometry2.prototype;
  _proto.generateTorso = function generateTorso() {
    var _this$_parameters = this._parameters, radialSegments = _this$_parameters.radialSegments, heightSegments = _this$_parameters.heightSegments, radiusBottom = _this$_parameters.radiusBottom, radiusTop = _this$_parameters.radiusTop, height = _this$_parameters.height;
    var x, y;
    var normal = new Vector3();
    var slope = (radiusBottom - radiusTop) / height;
    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments;
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        var vertX = radius * sinTheta;
        var vertY = -v * height + this.halfHeight;
        var vertZ = radius * cosTheta;
        this._vertices.push(vertX, vertY, vertZ);
        normal.setValue(sinTheta, slope, cosTheta);
        normal.normalize();
        this._vertices.push(normal.x, normal.y, normal.z);
        if (this.FrontFace === FrontFace.CCW) {
          this._vertices.push(u, v);
        } else {
          this._vertices.push(1 - u, v);
        }
        indexRow.push(this.index++);
      }
      this.indexArray.push(indexRow);
    }
    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        var a = this.indexArray[y][x];
        var b = this.indexArray[y + 1][x];
        var c = this.indexArray[y + 1][x + 1];
        var d = this.indexArray[y][x + 1];
        this._indices.push(a, b, d);
        this._indices.push(b, c, d);
      }
    }
  };
  _proto.generateCap = function generateCap(isTop) {
    var radialSegments = this._parameters.radialSegments;
    var x;
    var radius = isTop === true ? this._parameters.radiusTop : this._parameters.radiusBottom;
    var sign = isTop === true ? 1 : -1;
    var centerIndexStart = this.index;
    for (x = 1; x <= radialSegments; x++) {
      this._vertices.push(0, this.halfHeight * sign, 0);
      this._vertices.push(0, sign, 0);
      this._vertices.push(0.5, 0.5);
      this.index++;
    }
    var centerIndexEnd = this.index;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta);
      var vertexX = radius * sinTheta;
      var vertexY = this.halfHeight * sign;
      var vertexZ = radius * cosTheta;
      this._vertices.push(vertexX, vertexY, vertexZ);
      this._vertices.push(0, sign, 0);
      var uvX = cosTheta * 0.5 + 0.5;
      var uvY = sinTheta * 0.5 * sign + 0.5;
      this._vertices.push(uvX, uvY);
      this.index++;
    }
    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;
      if (isTop === true) {
        this._indices.push(i, i + 1, c);
      } else {
        this._indices.push(i + 1, i, c);
      }
    }
  };
  return CylinderGeometry2;
}(ShapeGeometry);
var CircleGeometry = function(_ShapeGeometry) {
  _inheritsLoose(CircleGeometry2, _ShapeGeometry);
  function CircleGeometry2(engine, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _ShapeGeometry.call(this, engine) || this;
    _this.radius = 1;
    _this.segments = 16;
    _this.thetaStart = 0;
    _this.thetaLength = Math.PI * 2;
    _this.radius = options.radius || _this.radius;
    _this.segments = options.segments || _this.segments;
    _this.thetaStart = options.thetaStart || _this.thetaStart;
    _this.thetaLength = options.thetaLength || _this.thetaLength;
    var _assertThisInitialize = _assertThisInitialized(_this), segments = _assertThisInitialize.segments, radius = _assertThisInitialize.radius;
    var vertices = new Float32Array((segments + 2) * 8);
    vertices.set([0, 0, 0, 0, 0, 1, 0.5, 0.5]);
    var index = 8;
    for (var s = 0; s <= segments; s++) {
      var segment = _this.thetaStart + s / segments * _this.thetaLength;
      var x = radius * Math.cos(segment);
      var y = radius * Math.sin(segment);
      vertices[index++] = x;
      vertices[index++] = y;
      vertices[index++] = 0;
      vertices[index++] = 0;
      vertices[index++] = 0;
      vertices[index++] = 1;
      vertices[index++] = (x / radius + 1) * 0.5;
      vertices[index++] = (y / radius + 1) * 0.5;
    }
    var indices = new Uint16Array(segments * 3);
    index = 0;
    for (var i = 1; i <= segments; i++) {
      indices[index++] = i;
      indices[index++] = i + 1;
      indices[index++] = 0;
    }
    _this._initialize(engine, vertices, indices);
    return _this;
  }
  return CircleGeometry2;
}(ShapeGeometry);
var ScreenQuadGeometry = function(_ShapeGeometry) {
  _inheritsLoose(ScreenQuadGeometry2, _ShapeGeometry);
  function ScreenQuadGeometry2(engine) {
    var _this;
    _this = _ShapeGeometry.call(this, engine) || this;
    var vertices = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
    var indices = new Uint16Array([0, 1, 2, 3]);
    _this._initialize(engine, vertices, indices);
    _this.subGeometry.topology = PrimitiveTopology.TriangleFan;
    return _this;
  }
  var _proto = ScreenQuadGeometry2.prototype;
  _proto._initialize = function _initialize(engine, vertices, indices) {
    var vertexStride = 20;
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)];
    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
  };
  return ScreenQuadGeometry2;
}(ShapeGeometry);
var TorusGeometry = function(_ShapeGeometry) {
  _inheritsLoose(TorusGeometry2, _ShapeGeometry);
  function TorusGeometry2(parameters, engine) {
    var _this;
    if (parameters === void 0) {
      parameters = {};
    }
    _this = _ShapeGeometry.call(this, engine) || this;
    _this.parameters = parameters;
    var radius = _this.parameters.radius || 1;
    var tube = _this.parameters.tube || 0.4;
    var radialSegments = Math.floor(_this.parameters.radialSegments) || 8;
    var tubularSegments = Math.floor(_this.parameters.tubularSegments) || 6;
    var arc = _this.parameters.arc || Math.PI * 2;
    var vertices = new Float32Array((radialSegments + 1) * (tubularSegments + 1) * 3);
    var indices = new Uint16Array(radialSegments * tubularSegments * 6);
    var index = 0;
    for (var j = 0; j <= radialSegments; j++) {
      for (var i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;
        vertices[index++] = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertices[index++] = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertices[index++] = tube * Math.sin(v);
      }
    }
    index = 0;
    for (var _j = 1; _j <= radialSegments; _j++) {
      for (var _i = 1; _i <= tubularSegments; _i++) {
        var a = (tubularSegments + 1) * _j + _i - 1;
        var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
        var c = (tubularSegments + 1) * (_j - 1) + _i;
        var d = (tubularSegments + 1) * _j + _i;
        indices[index++] = a;
        indices[index++] = b;
        indices[index++] = d;
        indices[index++] = b;
        indices[index++] = c;
        indices[index++] = d;
      }
    }
    _this._initialize(engine, vertices, indices);
    return _this;
  }
  var _proto = TorusGeometry2.prototype;
  _proto._initialize = function _initialize(engine, vertices, indices) {
    var vertexStride = 12;
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0)];
    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
  };
  return TorusGeometry2;
}(ShapeGeometry);
var Model = function(_GeometryRenderer) {
  _inheritsLoose(Model2, _GeometryRenderer);
  function Model2(entity) {
    var _this;
    _this = _GeometryRenderer.call(this, entity) || this;
    _this._props = void 0;
    _this._geometryType = void 0;
    return _this;
  }
  var _proto = Model2.prototype;
  _proto.init = function init2(props) {
    this._props = props;
    var _props$geometryType = props.geometryType, geometryType = _props$geometryType === void 0 ? GeometryType.Box : _props$geometryType;
    this.material = props.material;
    this.geometryType = geometryType;
  };
  _proto.setProp = function setProp(key, value) {
    this._props[key] = value;
    if (key === "material") {
      this.material = value;
    } else {
      this.geometryType = this._props.geometryType;
    }
  };
  _createClass(Model2, [{
    key: "geometryType",
    get: function get4() {
      return this._geometryType;
    },
    set: function set4(value) {
      switch (value) {
        case "Sphere":
          var _ref = this._props, sphereRadius = _ref.sphereRadius, sphereHorizontalSegments = _ref.sphereHorizontalSegments, sphereVerticalSegments = _ref.sphereVerticalSegments, sphereAlphaStart = _ref.sphereAlphaStart, sphereAlphaRange = _ref.sphereAlphaRange, sphereThetaStart = _ref.sphereThetaStart, sphereThetaRange = _ref.sphereThetaRange;
          this.geometry = new SphereGeometry(this.engine, sphereRadius, sphereHorizontalSegments, sphereVerticalSegments, sphereAlphaStart, sphereAlphaRange, sphereThetaStart, sphereThetaRange);
          break;
        case "Cylinder":
          var _ref2 = this._props, cylinderRadiusTop = _ref2.cylinderRadiusTop, cylinderRadiusBottom = _ref2.cylinderRadiusBottom, cylinderHeight = _ref2.cylinderHeight, cylinderRadialSegments = _ref2.cylinderRadialSegments, cylinderHeightSegments = _ref2.cylinderHeightSegments, cylinderOpenEnded = _ref2.cylinderOpenEnded;
          this.geometry = new CylinderGeometry(this.engine, cylinderRadiusTop, cylinderRadiusBottom, cylinderHeight, cylinderRadialSegments, cylinderHeightSegments, cylinderOpenEnded, void 0, void 0, void 0);
          break;
        case "Plane":
          var _ref3 = this._props, planeWidth = _ref3.planeWidth, planeHeight = _ref3.planeHeight, planeHorizontalSegments = _ref3.planeHorizontalSegments, planeVerticalSegments = _ref3.planeVerticalSegments;
          this.geometry = new PlaneGeometry(this.engine, planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments);
          break;
        case "Box":
          var _ref4 = this._props, boxWidth = _ref4.boxWidth, boxHeight = _ref4.boxHeight, boxDepth = _ref4.boxDepth;
          this.geometry = new CuboidGeometry(this.engine, boxWidth, boxHeight, boxDepth);
          break;
      }
      this._geometryType = value;
    }
  }, {
    key: "material",
    get: function get4() {
      return this._material;
    },
    set: function set4(mtl) {
      if (!mtl) {
        this._material = new BlinnPhongMaterial(this.engine);
      } else {
        this._material = mtl;
      }
    }
  }]);
  return Model2;
}(GeometryRenderer);
var GeometryType;
(function(GeometryType2) {
  GeometryType2["Box"] = "Box";
  GeometryType2["Cylinder"] = "Cylinder";
  GeometryType2["Plane"] = "Plane";
  GeometryType2["Sphere"] = "Sphere";
})(GeometryType || (GeometryType = {}));
var SkyBoxMaterial = function(_Material) {
  _inheritsLoose(SkyBoxMaterial2, _Material);
  function SkyBoxMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("skybox")) || this;
    _this.renderState.rasterState.cullMode = CullMode.Off;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    return _this;
  }
  return SkyBoxMaterial2;
}(Material);
var SkyBox = function(_GeometryRenderer) {
  _inheritsLoose(SkyBox2, _GeometryRenderer);
  function SkyBox2(entity) {
    var _this;
    _this = _GeometryRenderer.call(this, entity) || this;
    _this._skyBoxMap = void 0;
    _this._matrix = new Matrix();
    _this._initBounds = false;
    _this.geometry = new CuboidGeometry(_this.engine, 2, 2, 2);
    _this.material = new SkyBoxMaterial(_this.engine);
    return _this;
  }
  var _proto = SkyBox2.prototype;
  _proto.render = function render(camera) {
    if (!this._skyBoxMap)
      return;
    var modelMatrix = this.entity.transform.worldMatrix;
    var view = camera.viewMatrix;
    var proj = camera.projectionMatrix;
    var matrix = this._matrix;
    Matrix.multiply(view, modelMatrix, matrix);
    var e = matrix.elements;
    e[12] = e[13] = e[14] = 0;
    Matrix.multiply(proj, matrix, matrix);
    this.shaderData.setMatrix("u_mvpNoscale", matrix);
    _GeometryRenderer.prototype.render.call(this, camera);
  };
  _proto._updateBounds = function _updateBounds(worldBounds) {
    if (!this._initBounds) {
      worldBounds.min.setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
      worldBounds.max.setValue(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
      this._initBounds = true;
    }
  };
  _createClass(SkyBox2, [{
    key: "skyBoxMap",
    get: function get4() {
      return this._skyBoxMap;
    },
    set: function set4(v) {
      this._skyBoxMap = v;
      v && this.material.shaderData.setTexture("u_cube", v);
    }
  }]);
  return SkyBox2;
}(GeometryRenderer);
var DirtyFlagType;
(function(DirtyFlagType2) {
  DirtyFlagType2[DirtyFlagType2["Position"] = 1] = "Position";
  DirtyFlagType2[DirtyFlagType2["Velocity"] = 2] = "Velocity";
  DirtyFlagType2[DirtyFlagType2["Acceleration"] = 4] = "Acceleration";
  DirtyFlagType2[DirtyFlagType2["Color"] = 8] = "Color";
  DirtyFlagType2[DirtyFlagType2["Apha"] = 16] = "Apha";
  DirtyFlagType2[DirtyFlagType2["Size"] = 32] = "Size";
  DirtyFlagType2[DirtyFlagType2["StartAngle"] = 64] = "StartAngle";
  DirtyFlagType2[DirtyFlagType2["StartTime"] = 128] = "StartTime";
  DirtyFlagType2[DirtyFlagType2["LifeTime"] = 256] = "LifeTime";
  DirtyFlagType2[DirtyFlagType2["RotateVelocity"] = 512] = "RotateVelocity";
  DirtyFlagType2[DirtyFlagType2["Scale"] = 1024] = "Scale";
  DirtyFlagType2[DirtyFlagType2["Everything"] = 4294967295] = "Everything";
})(DirtyFlagType || (DirtyFlagType = {}));
var ParticleRendererBlendMode;
(function(ParticleRendererBlendMode2) {
  ParticleRendererBlendMode2[ParticleRendererBlendMode2["Transparent"] = 0] = "Transparent";
  ParticleRendererBlendMode2[ParticleRendererBlendMode2["Additive"] = 1] = "Additive";
})(ParticleRendererBlendMode || (ParticleRendererBlendMode = {}));
var ParticleRenderer = function(_GeometryRenderer) {
  _inheritsLoose(ParticleRenderer2, _GeometryRenderer);
  ParticleRenderer2._getRandom = function _getRandom() {
    return Math.random() - 0.5;
  };
  function ParticleRenderer2(props) {
    var _this;
    _this = _GeometryRenderer.call(this, props) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._maxCount = 1e3;
    _this._position = new Vector3();
    _this._positionRandomness = new Vector3();
    _this._positionArray = void 0;
    _this._velocity = new Vector3();
    _this._velocityRandomness = new Vector3();
    _this._acceleration = new Vector3();
    _this._accelerationRandomness = new Vector3();
    _this._color = new Color(1, 1, 1, 1);
    _this._colorRandomness = 0;
    _this._size = 1;
    _this._sizeRandomness = 0;
    _this._alpha = 1;
    _this._alphaRandomness = 0;
    _this._startAngle = 0;
    _this._startAngleRandomness = 0;
    _this._rotateVelocity = 0;
    _this._rotateVelocityRandomness = 0;
    _this._lifetime = 5;
    _this._startTimeRandomness = 0;
    _this._scale = 1;
    _this._isOnce = false;
    _this._time = 0;
    _this._isInit = false;
    _this._isStart = false;
    _this._updateDirtyFlag = DirtyFlagType.Everything;
    _this._isRotateToVelocity = false;
    _this._isUseOriginColor = false;
    _this._isScaleByLifetime = false;
    _this._is2d = true;
    _this._isFadeIn = false;
    _this._isFadeOut = false;
    _this._playOnEnable = true;
    _this._blendMode = ParticleRendererBlendMode.Transparent;
    _this.spriteSheet = void 0;
    _this._material = _this._createMaterial();
    return _this;
  }
  var _proto = ParticleRenderer2.prototype;
  _proto.update = function update(deltaTime) {
    if (!this._isInit || !this._isStart) {
      return;
    }
    if (this._updateDirtyFlag) {
      this._updateBuffer();
      this._updateDirtyFlag = 0;
    }
    this._time += deltaTime / 1e3;
    this.shaderData.setFloat("u_time", this._time);
  };
  _proto._onEnable = function _onEnable() {
    _GeometryRenderer.prototype._onEnable.call(this);
    if (this._playOnEnable) {
      this.start();
    }
  };
  _proto.start = function start() {
    this._isStart = true;
    this._time = 0;
    this.shaderData.setInt("u_active", 1);
  };
  _proto.stop = function stop() {
    this.shaderData.setInt("u_active", 0);
  };
  _proto._createMaterial = function _createMaterial() {
    var material = new Material(this.engine, Shader.find("particle-shader"));
    var renderState = material.renderState;
    var target = renderState.blendState.targetBlendState;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
    renderState.depthState.writeEnabled = false;
    material.renderQueueType = RenderQueueType.Transparent;
    this.isUseOriginColor = true;
    this.is2d = true;
    this.isFadeOut = true;
    return material;
  };
  _proto._createGeometry = function _createGeometry() {
    var geometry = new BufferGeometry(this._entity.engine, "particleGeometry");
    var vertexStride = 96;
    var vertexFloatCount = this._maxCount * 4 * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var indices = new Uint16Array(6 * this._maxCount);
    for (var i = 0, idx = 0; i < this._maxCount; ++i) {
      var startIndex = i * 4;
      indices[idx++] = startIndex + 0;
      indices[idx++] = startIndex + 1;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 0;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 3;
    }
    var vertexElements = [new VertexElement("a_position", 0, VertexElementFormat.Vector3, 0), new VertexElement("a_velocity", 12, VertexElementFormat.Vector3, 0), new VertexElement("a_acceleration", 24, VertexElementFormat.Vector3, 0), new VertexElement("a_color", 36, VertexElementFormat.Vector4, 0), new VertexElement("a_lifeAndSize", 52, VertexElementFormat.Vector4, 0), new VertexElement("a_rotation", 68, VertexElementFormat.Vector2, 0), new VertexElement("a_uv", 76, VertexElementFormat.Vector3, 0), new VertexElement("a_normalizedUv", 88, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
    var indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
    geometry.setVertexBufferBinding(vertexBuffer, vertexStride);
    geometry.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);
    geometry.setVertexElements(vertexElements);
    geometry.addSubGeometry(0, indices.length);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride / 4;
    this._vertices = vertices;
    return geometry;
  };
  _proto._updateBuffer = function _updateBuffer() {
    for (var x = 0; x < this._maxCount; x++) {
      this._updateSingleBuffer(x);
    }
    this._vertexBuffer.setData(this._vertices);
  };
  _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
    var _updateDirtyFlag = this._updateDirtyFlag, vertices = this._vertices, vertexStride = this._vertexStride;
    var getRandom = ParticleRenderer2._getRandom;
    var offset = i * 4;
    var k0 = offset * vertexStride;
    var k1 = (offset + 1) * vertexStride;
    var k2 = (offset + 2) * vertexStride;
    var k3 = (offset + 3) * vertexStride;
    if (_updateDirtyFlag & DirtyFlagType.Position) {
      var _this$_position = this._position, x = _this$_position.x, y = _this$_position.y, z = _this$_position.z;
      var _positionArray = this._positionArray, _positionRandomness = this._positionRandomness;
      if (_positionArray) {
        if (_positionArray.length !== this._maxCount) {
          throw Error("The length of positionArray must be equal to maxCount.");
        }
        var pos = _positionArray[i];
        x += pos.x;
        y += pos.y;
        z += pos.z;
      } else {
        x += getRandom() * _positionRandomness.x;
        y += getRandom() * _positionRandomness.y;
        z += getRandom() * _positionRandomness.z;
      }
      vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
      vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
      vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Velocity) {
      var _velocity = this._velocity, _velocityRandomness = this._velocityRandomness;
      vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
      vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
      vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Acceleration) {
      var _acceleration = this._acceleration, _accelerationRandomness = this._accelerationRandomness;
      vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
      vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
      vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
    }
    if (_updateDirtyFlag & DirtyFlagType.Color) {
      var _color = this._color, _colorRandomness = this._colorRandomness;
      vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = MathUtil.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = MathUtil.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
      vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = MathUtil.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
    }
    if (_updateDirtyFlag & DirtyFlagType.Apha) {
      vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = MathUtil.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
    }
    if (_updateDirtyFlag & DirtyFlagType.StartTime) {
      vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
    }
    if (_updateDirtyFlag & DirtyFlagType.LifeTime) {
      var _lifetime = this._lifetime;
      vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
    }
    if (_updateDirtyFlag & DirtyFlagType.Size) {
      var _size = this._size;
      vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
    }
    if (_updateDirtyFlag & DirtyFlagType.Scale) {
      vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
    }
    if (_updateDirtyFlag & DirtyFlagType.StartAngle) {
      vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
    }
    if (_updateDirtyFlag & DirtyFlagType.RotateVelocity) {
      vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
    }
    this._updateSingleUv(i, k0, k1, k2, k3);
  };
  _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
    var spriteSheet = this.spriteSheet;
    var texture = this._material.shaderData.getTexture("u_texture");
    var vertices = this._vertices;
    if (texture) {
      var width = texture.width;
      var height = texture.height;
      if (spriteSheet) {
        var _spriteSheet = spriteSheet[i % spriteSheet.length], x = _spriteSheet.x, y = _spriteSheet.y, w = _spriteSheet.w, h = _spriteSheet.h;
        var u = x / width;
        var v = y / height;
        var p = u + w / width;
        var q = v + h / height;
        var ratio = h / w;
        vertices[k0 + 19] = u;
        vertices[k0 + 20] = q;
        vertices[k0 + 21] = ratio;
        vertices[k1 + 19] = p;
        vertices[k1 + 20] = q;
        vertices[k1 + 21] = ratio;
        vertices[k2 + 19] = p;
        vertices[k2 + 20] = v;
        vertices[k2 + 21] = ratio;
        vertices[k3 + 19] = u;
        vertices[k3 + 20] = v;
        vertices[k3 + 21] = ratio;
      } else {
        var _ratio = height / width;
        vertices[k0 + 19] = 0;
        vertices[k0 + 20] = 1;
        vertices[k0 + 21] = _ratio;
        vertices[k1 + 19] = 1;
        vertices[k1 + 20] = 1;
        vertices[k1 + 21] = _ratio;
        vertices[k2 + 19] = 1;
        vertices[k2 + 20] = 0;
        vertices[k2 + 21] = _ratio;
        vertices[k3 + 19] = 0;
        vertices[k3 + 20] = 0;
        vertices[k3 + 21] = _ratio;
      }
    } else {
      vertices[k0 + 19] = 0;
      vertices[k0 + 20] = 0;
      vertices[k0 + 21] = 1;
      vertices[k1 + 19] = 1;
      vertices[k1 + 20] = 0;
      vertices[k1 + 21] = 1;
      vertices[k2 + 19] = 1;
      vertices[k2 + 20] = 1;
      vertices[k2 + 21] = 1;
      vertices[k3 + 19] = 0;
      vertices[k3 + 20] = 1;
      vertices[k3 + 21] = 1;
    }
    vertices[k0 + 22] = -0.5;
    vertices[k0 + 23] = -0.5;
    vertices[k1 + 22] = 0.5;
    vertices[k1 + 23] = -0.5;
    vertices[k2 + 22] = 0.5;
    vertices[k2 + 23] = 0.5;
    vertices[k3 + 22] = -0.5;
    vertices[k3 + 23] = 0.5;
  };
  _createClass(ParticleRenderer2, [{
    key: "texture",
    get: function get4() {
      return this.material.shaderData.getTexture("u_texture");
    },
    set: function set4(texture) {
      if (texture) {
        this.shaderData.enableMacro("particleTexture");
        this.material.shaderData.setTexture("u_texture", texture);
      } else {
        this.shaderData.disableMacro("particleTexture");
      }
    }
  }, {
    key: "position",
    get: function get4() {
      return this._position;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._position = value;
    }
  }, {
    key: "positionRandomness",
    get: function get4() {
      return this._positionRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionRandomness = value;
    }
  }, {
    key: "positionArray",
    get: function get4() {
      return this._positionArray;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Position;
      this._positionArray = value;
    }
  }, {
    key: "velocity",
    get: function get4() {
      return this._velocity;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocity = value;
    }
  }, {
    key: "velocityRandomness",
    get: function get4() {
      return this._velocityRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Velocity;
      this._velocityRandomness = value;
    }
  }, {
    key: "acceleration",
    get: function get4() {
      return this._acceleration;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._acceleration = value;
    }
  }, {
    key: "accelerationRandomness",
    get: function get4() {
      return this._accelerationRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Acceleration;
      this._accelerationRandomness = value;
    }
  }, {
    key: "color",
    get: function get4() {
      return this._color;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._color = value;
    }
  }, {
    key: "colorRandomness",
    get: function get4() {
      return this._colorRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Color;
      this._colorRandomness = value;
    }
  }, {
    key: "size",
    get: function get4() {
      return this._size;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._size = value;
    }
  }, {
    key: "sizeRandomness",
    get: function get4() {
      return this._sizeRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Size;
      this._sizeRandomness = value;
    }
  }, {
    key: "alpha",
    get: function get4() {
      return this._alpha;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Apha;
      this._alpha = value;
    }
  }, {
    key: "alphaRandomness",
    get: function get4() {
      return this._alphaRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Apha;
      this._alphaRandomness = value;
    }
  }, {
    key: "angle",
    get: function get4() {
      return this._startAngle;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngle = value;
    }
  }, {
    key: "angleRandomness",
    get: function get4() {
      return this._startAngleRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartAngle;
      this._startAngleRandomness = value;
    }
  }, {
    key: "rotateVelocity",
    get: function get4() {
      return this._rotateVelocity;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocity = value;
    }
  }, {
    key: "rotateVelocityRandomness",
    get: function get4() {
      return this._rotateVelocityRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.RotateVelocity;
      this._rotateVelocityRandomness = value;
    }
  }, {
    key: "lifetime",
    get: function get4() {
      return this._lifetime;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.LifeTime;
      this._lifetime = value;
    }
  }, {
    key: "startTimeRandomness",
    get: function get4() {
      return this._startTimeRandomness;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.StartTime;
      this._startTimeRandomness = value;
    }
  }, {
    key: "scale",
    get: function get4() {
      return this._scale;
    },
    set: function set4(value) {
      this._updateDirtyFlag |= DirtyFlagType.Scale;
      this._scale = value;
    }
  }, {
    key: "maxCount",
    get: function get4() {
      return this._maxCount;
    },
    set: function set4(value) {
      this._isStart = false;
      this._isInit = false;
      this._maxCount = value;
      this._updateDirtyFlag = DirtyFlagType.Everything;
      this.geometry = this._createGeometry();
      this._updateBuffer();
      this._isInit = true;
    }
  }, {
    key: "isOnce",
    get: function get4() {
      return this._isOnce;
    },
    set: function set4(value) {
      this._time = 0;
      this.shaderData.setInt("u_once", value ? 1 : 0);
      this._isOnce = value;
    }
  }, {
    key: "isRotateToVelocity",
    get: function get4() {
      return this._isRotateToVelocity;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("rotateToVelocity");
      } else {
        this.shaderData.disableMacro("rotateToVelocity");
      }
      this._isRotateToVelocity = value;
    }
  }, {
    key: "isUseOriginColor",
    get: function get4() {
      return this._isUseOriginColor;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("useOriginColor");
      } else {
        this.shaderData.disableMacro("useOriginColor");
      }
      this._isUseOriginColor = value;
    }
  }, {
    key: "isScaleByLifetime",
    get: function get4() {
      return this._isScaleByLifetime;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("isScaleByLifetime");
      } else {
        this.shaderData.disableMacro("isScaleByLifetime");
      }
      this._isScaleByLifetime = value;
    }
  }, {
    key: "is2d",
    get: function get4() {
      return this._is2d;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("is2d");
      } else {
        this.shaderData.disableMacro("is2d");
        this.material.renderState.rasterState.cullMode = CullMode.Off;
      }
      this._is2d = value;
    }
  }, {
    key: "isFadeIn",
    get: function get4() {
      return this._isFadeIn;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("fadeIn");
      } else {
        this.shaderData.disableMacro("fadeIn");
      }
      this._isFadeIn = value;
    }
  }, {
    key: "isFadeOut",
    get: function get4() {
      return this._isFadeOut;
    },
    set: function set4(value) {
      if (value) {
        this.shaderData.enableMacro("fadeOut");
      } else {
        this.shaderData.disableMacro("fadeOut");
      }
      this._isFadeOut = value;
    }
  }, {
    key: "playOnEnable",
    get: function get4() {
      return this._playOnEnable;
    },
    set: function set4(value) {
      this._playOnEnable = value;
      if (value) {
        this.start();
      } else {
        this.stop();
      }
    }
  }, {
    key: "blendMode",
    get: function get4() {
      return this._blendMode;
    },
    set: function set4(value) {
      var blendState = this.material.renderState.blendState;
      var target = blendState.targetBlendState;
      if (value === ParticleRendererBlendMode.Transparent) {
        target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
      } else if (value === ParticleRendererBlendMode.Additive) {
        target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
      }
      this._blendMode = value;
    }
  }]);
  return ParticleRenderer2;
}(GeometryRenderer);
var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}";
var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 u_projMat;uniform mat4 u_viewMat;void main(){gl_Position=u_projMat*u_viewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}";
Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = function(_Material) {
  _inheritsLoose(TrailMaterial2, _Material);
  function TrailMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("trail")) || this;
    var target = _this.renderState.blendState.targetBlendState;
    target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
    target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
    _this.renderState.depthState.writeEnabled = false;
    return _this;
  }
  return TrailMaterial2;
}(Material);
var _tempVector3 = new Vector3();
var TrailRenderer = function(_GeometryRenderer) {
  _inheritsLoose(TrailRenderer2, _GeometryRenderer);
  function TrailRenderer2(entity, props) {
    var _this;
    _this = _GeometryRenderer.call(this, entity) || this;
    _this._vertexStride = void 0;
    _this._vertices = void 0;
    _this._vertexBuffer = void 0;
    _this._stroke = void 0;
    _this._minSeg = void 0;
    _this._lifetime = void 0;
    _this._maxPointNum = void 0;
    _this._points = void 0;
    _this._pointStates = void 0;
    _this._strapPoints = void 0;
    _this._curPointNum = void 0;
    _this._prePointsNum = void 0;
    _this._stroke = props.stroke || 0.2;
    _this._minSeg = props.minSeg || 0.02;
    _this._lifetime = props.lifetime || 1e3;
    _this._maxPointNum = _this._lifetime / 1e3 * entity.engine.targetFrameRate;
    _this._points = [];
    _this._pointStates = [];
    _this._strapPoints = [];
    for (var i = 0; i < _this._maxPointNum; i++) {
      _this._points.push(new Vector3());
      _this._pointStates.push(_this._lifetime);
      _this._strapPoints.push(new Vector3());
      _this._strapPoints.push(new Vector3());
    }
    _this._curPointNum = 0;
    var mtl = props.material || new TrailMaterial(_this.engine);
    _this.material = mtl;
    _this.setTexture(props.texture);
    _this._initGeometry();
    return _this;
  }
  var _proto = TrailRenderer2.prototype;
  _proto.update = function update(deltaTime) {
    var mov = 0, newIdx = 0;
    for (var i = 0; i < this._curPointNum; i++) {
      this._pointStates[i] -= deltaTime;
      if (this._pointStates[i] < 0) {
        mov++;
      } else if (mov > 0) {
        newIdx = i - mov;
        this._pointStates[newIdx] = this._pointStates[i];
        this._points[i].cloneTo(this._points[newIdx]);
      }
    }
    this._curPointNum -= mov;
    var appendNewPoint = true;
    if (this._curPointNum === this._maxPointNum) {
      appendNewPoint = false;
    } else if (this._curPointNum > 0) {
      var lastPoint = this._points[this._points.length - 1];
      if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {
        appendNewPoint = false;
      }
    }
    if (appendNewPoint) {
      this._pointStates[this._curPointNum] = this._lifetime;
      this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);
      this._curPointNum++;
    }
  };
  _proto.render = function render(camera) {
    this._updateStrapVertices(camera, this._points);
    this._updateStrapCoords();
    this._vertexBuffer.setData(this._vertices);
    _GeometryRenderer.prototype.render.call(this, camera);
  };
  _proto.setTexture = function setTexture(texture) {
    if (texture) {
      this.material.shaderData.setTexture("u_texture", texture);
    }
  };
  _proto._initGeometry = function _initGeometry() {
    var geometry = new BufferGeometry(this._entity.engine);
    var vertexStride = 20;
    var vertexCount = this._maxPointNum * 2;
    var vertexFloatCount = vertexCount * vertexStride;
    var vertices = new Float32Array(vertexFloatCount);
    var vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)];
    var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
    geometry.setVertexBufferBinding(vertexBuffer, vertexStride);
    geometry.setVertexElements(vertexElements);
    geometry.addSubGeometry(0, vertexCount, PrimitiveTopology.TriangleStrip);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    this.geometry = geometry;
  };
  _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
    var m = camera.viewMatrix;
    var e = m.elements;
    var vx = new Vector3(e[0], e[4], e[8]);
    var vy = new Vector3(e[1], e[5], e[9]);
    var vz = new Vector3(e[2], e[6], e[10]);
    var s = this._stroke;
    vy.scale(s);
    var up = new Vector3();
    var down = new Vector3();
    var rotation = new Quaternion();
    Vector3.transformByQuat(vx, rotation, vx);
    Vector3.transformByQuat(vy, rotation, vy);
    var dy = new Vector3();
    var cross = new Vector3();
    var perpVector = new Vector3();
    vx.normalize();
    var vertieces = this._vertices;
    for (var i = 0; i < this._maxPointNum; i++) {
      if (i < this._curPointNum) {
        var p = points[i];
        if (i === this._curPointNum - 1 && i !== 0) {
          Vector3.subtract(p, points[i - 1], perpVector);
        } else {
          Vector3.subtract(points[i + 1], p, perpVector);
        }
        this._projectOnPlane(perpVector, vz, perpVector);
        perpVector.normalize();
        var angle = Math.acos(Vector3.dot(vx, perpVector));
        Vector3.cross(vx, perpVector, cross);
        if (Vector3.dot(cross, vz) <= 0) {
          angle = Math.PI * 2 - angle;
        }
        Quaternion.rotationAxisAngle(vz, angle, rotation);
        Vector3.transformByQuat(vy, rotation, dy);
        Vector3.add(p, dy, up);
        Vector3.subtract(p, dy, down);
      }
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertieces[p0] = up.x;
      vertieces[p0 + 1] = up.y;
      vertieces[p0 + 2] = up.z;
      vertieces[p1] = down.x;
      vertieces[p1 + 1] = down.y;
      vertieces[p1 + 2] = down.z;
    }
  };
  _proto._updateStrapCoords = function _updateStrapCoords() {
    if (this._prePointsNum === this._curPointNum) {
      return;
    }
    this._prePointsNum = this._curPointNum;
    var count = this._curPointNum;
    var texDelta = 1 / count;
    var vertieces = this._vertices;
    for (var i = 0; i < count; i++) {
      var d = 1 - i * texDelta;
      var p0 = i * 2 * this._vertexStride / 4;
      var p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertieces[p0] = 0;
      vertieces[p0 + 1] = d;
      vertieces[p1] = 1;
      vertieces[p1 + 1] = d;
    }
  };
  _proto._projectOnVector = function _projectOnVector(a, p, out) {
    var n_p = p.clone();
    Vector3.normalize(n_p, n_p);
    var cosine = Vector3.dot(a, n_p);
    out.x = n_p.x * cosine;
    out.y = n_p.y * cosine;
    out.z = n_p.z * cosine;
  };
  _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
    this._projectOnVector(a, n, _tempVector3);
    Vector3.subtract(a, _tempVector3, out);
  };
  return TrailRenderer2;
}(GeometryRenderer);
var BoxCollider = function(_ABoxCollider) {
  _inheritsLoose(BoxCollider2, _ABoxCollider);
  function BoxCollider2(entity) {
    var _this;
    _this = _ABoxCollider.call(this, entity) || this;
    _this._center = new Vector3();
    _this._size = new Vector3();
    _this.isShowCollider = true;
    _this.center = _this.center;
    _this.size = _this.size;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }
  _createClass(BoxCollider2, [{
    key: "center",
    get: function get4() {
      return this._center;
    },
    set: function set4(value) {
      this._center = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }, {
    key: "size",
    get: function get4() {
      return this._size;
    },
    set: function set4(value) {
      this._size = value;
      this.setBoxCenterSize(this._center, this._size);
    }
  }]);
  return BoxCollider2;
}(ABoxCollider);
var SphereCollider = function(_ASphereCollider) {
  _inheritsLoose(SphereCollider2, _ASphereCollider);
  function SphereCollider2(entity) {
    var _this;
    _this = _ASphereCollider.call(this, entity) || this;
    _this.__center = new Vector3();
    _this.__radius = 1;
    _this.isShowCollider = true;
    _this._center = _this._center;
    _this._radius = _this._radius;
    _this.isShowCollider = _this.isShowCollider;
    return _this;
  }
  _createClass(SphereCollider2, [{
    key: "_center",
    get: function get4() {
      return this.__center;
    },
    set: function set4(value) {
      this.__center = value;
      this.setSphere(this.__center, this.__radius);
    }
  }, {
    key: "_radius",
    get: function get4() {
      return this.__radius;
    },
    set: function set4(value) {
      this.__radius = value;
      this.setSphere(this.__center, this.__radius);
    }
  }]);
  return SphereCollider2;
}(ASphereCollider);
Scene.registerFeature(ColliderFeature);
function intersectBox2Box(boxA, boxB) {
  return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;
}
function intersectSphere2Sphere(sphereA, sphereB) {
  var distance = Vector3.distance(sphereA.center, sphereB.center);
  return distance < sphereA.radius + sphereA.radius;
}
function intersectSphere2Box(sphere, box) {
  var center = sphere.center;
  var closestPoint = new Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));
  var distance = Vector3.distance(center, closestPoint);
  return distance < sphere.radius;
}
var CollisionDetection = function(_Script) {
  _inheritsLoose(CollisionDetection2, _Script);
  function CollisionDetection2(entity) {
    var _this;
    _this = _Script.call(this, entity) || this;
    _this._colliderManager = void 0;
    _this._myCollider = void 0;
    _this._overlopCollider = void 0;
    _this._sphere = void 0;
    _this._box = new BoundingBox();
    _this.hasEvent = void 0;
    _this.eventNames = void 0;
    _this.listenerCount = void 0;
    _this.dispatch = void 0;
    _this.on = void 0;
    _this.once = void 0;
    _this.addEventListener = void 0;
    _this.off = void 0;
    _this.removeEventListener = void 0;
    _this.removeAllEventListeners = void 0;
    _this.trigger = void 0;
    _this._clearEvent = void 0;
    return _this;
  }
  var _proto = CollisionDetection2.prototype;
  _proto.onUpdate = function onUpdate(deltaTime) {
    _Script.prototype.onUpdate.call(this, deltaTime);
    var overlopCollider = null;
    if (this._colliderManager && this._myCollider) {
      var colliders = this._colliderManager.colliders;
      if (this._myCollider instanceof ABoxCollider) {
        this._updateWorldBox(this._myCollider, this._box);
        for (var i = 0, len = colliders.length; i < len; i++) {
          var collider = colliders[i];
          if (collider != this._myCollider && this._boxCollision(collider)) {
            overlopCollider = collider;
            this.dispatch("collision", {
              collider
            });
          }
        }
      } else if (this._myCollider instanceof ASphereCollider) {
        this._sphere = this._getWorldSphere(this._myCollider);
        for (var _i = 0, _len = colliders.length; _i < _len; _i++) {
          var _collider = colliders[_i];
          if (_collider != this._myCollider && this._sphereCollision(_collider)) {
            overlopCollider = _collider;
            this.dispatch("collision", {
              collider: _collider
            });
          }
        }
      }
    }
    if (overlopCollider != null && this._overlopCollider != overlopCollider) {
      this.dispatch("begin_overlop", {
        collider: overlopCollider
      });
    }
    if (this._overlopCollider != null && this._overlopCollider != overlopCollider) {
      var _e = this._overlopCollider;
      this.dispatch("end_overlop", {
        collider: _e
      });
    }
    this._overlopCollider = overlopCollider;
  };
  _proto._updateWorldBox = function _updateWorldBox(boxCollider, out) {
    var mat = boxCollider.entity.transform.worldMatrix;
    var source = CollisionDetection2._tempBox1;
    boxCollider.boxMax.cloneTo(source.max);
    boxCollider.boxMin.cloneTo(source.min);
    BoundingBox.transform(source, mat, out);
  };
  _proto._getWorldSphere = function _getWorldSphere(sphereCollider) {
    var center = new Vector3();
    Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);
    return {
      radius: sphereCollider.radius,
      center
    };
  };
  _proto._boxCollision = function _boxCollision(other) {
    if (other instanceof ABoxCollider) {
      var box = CollisionDetection2._tempBox2;
      this._updateWorldBox(other, box);
      return intersectBox2Box(box, this._box);
    } else if (other instanceof ASphereCollider) {
      var sphere = this._getWorldSphere(other);
      return intersectSphere2Box(sphere, this._box);
    }
    return false;
  };
  _proto._sphereCollision = function _sphereCollision(other) {
    if (other instanceof ABoxCollider) {
      var box = CollisionDetection2._tempBox2;
      this._updateWorldBox(other, box);
      return intersectSphere2Box(this._sphere, box);
    } else if (other instanceof ASphereCollider) {
      var sphere = this._getWorldSphere(other);
      return intersectSphere2Sphere(sphere, this._sphere);
    }
    return false;
  };
  _proto.onAwake = function onAwake() {
    this._colliderManager = this.scene.findFeature(ColliderFeature);
    this._myCollider = this.entity.getComponent(Collider);
  };
  _createClass(CollisionDetection2, [{
    key: "overlopCollider",
    get: function get4() {
      return this._overlopCollider;
    }
  }]);
  return CollisionDetection2;
}(Script);
CollisionDetection._tempVec3 = new Vector3();
CollisionDetection._tempBox1 = new BoundingBox();
CollisionDetection._tempBox2 = new BoundingBox();
applyMixins(CollisionDetection, [EventDispatcher]);
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach(function(baseCtor) {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
      derivedCtor.prototype[name] = baseCtor.prototype[name];
    });
  });
}
var Fog = function(_Component) {
  _inheritsLoose(Fog2, _Component);
  function Fog2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._color = new Color(1, 0, 0, 1);
    _this.color = _this._color;
    return _this;
  }
  var _proto = Fog2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_HAS_FOG");
  };
  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_HAS_FOG");
  };
  _createClass(Fog2, [{
    key: "color",
    get: function get4() {
      return this._color;
    },
    set: function set4(value) {
      this._color = value;
      this.scene.shaderData.setColor(Fog2._colorProperty, value);
    }
  }]);
  return Fog2;
}(Component);
Fog._colorProperty = Shader.getPropertyByName("u_fogColor");
var EXP2Fog = function(_Fog) {
  _inheritsLoose(EXP2Fog2, _Fog);
  function EXP2Fog2(entity) {
    var _this;
    _this = _Fog.call(this, entity) || this;
    _this._density = 25e-4;
    _this.density = _this._density;
    return _this;
  }
  var _proto = EXP2Fog2.prototype;
  _proto._onEnable = function _onEnable() {
    this.scene.shaderData.enableMacro("O3_FOG_EXP2");
  };
  _proto._onDisable = function _onDisable() {
    this.scene.shaderData.disableMacro("O3_FOG_EXP2");
  };
  _createClass(EXP2Fog2, [{
    key: "density",
    get: function get4() {
      return this._density;
    },
    set: function set4(value) {
      this._density = value;
      this.scene.shaderData.setFloat(EXP2Fog2._densityProperty, value);
    }
  }]);
  return EXP2Fog2;
}(Fog);
EXP2Fog._densityProperty = Shader.getPropertyByName("u_fogDensity");
var LinearFog = function(_Fog) {
  _inheritsLoose(LinearFog2, _Fog);
  function LinearFog2(entity) {
    var _this;
    _this = _Fog.call(this, entity) || this;
    _this._near = 1;
    _this._far = 1e3;
    _this.near = _this._near;
    _this.far = _this._far;
    return _this;
  }
  _createClass(LinearFog2, [{
    key: "near",
    get: function get4() {
      return this._near;
    },
    set: function set4(value) {
      this._near = value;
      this.scene.shaderData.setFloat(LinearFog2._nearProperty, value);
    }
  }, {
    key: "far",
    get: function get4() {
      return this._far;
    },
    set: function set4(value) {
      this._far = value;
      this.scene.shaderData.setFloat(LinearFog2._farProperty, value);
    }
  }]);
  return LinearFog2;
}(Fog);
LinearFog._nearProperty = Shader.getPropertyByName("u_fogNear");
LinearFog._farProperty = Shader.getPropertyByName("u_fogFar");
var Probe = function(_Script) {
  _inheritsLoose(Probe2, _Script);
  function Probe2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Script.call.apply(_Script, [this].concat(args)) || this;
    _this.probeLayer = Layer.Everything;
    _this.width = 1024;
    _this.height = 1024;
    _this.antiAliasing = 1;
    _this._isCube = false;
    _this._oriCameraRenderTarget = void 0;
    _this._renderTarget = void 0;
    _this._renderTargetSwap = void 0;
    _this._activeRenderTarget = void 0;
    _this._camera = void 0;
    _this._oriCameraCullingMask = void 0;
    return _this;
  }
  var _proto = Probe2.prototype;
  _proto.onTextureChange = function onTextureChange(renderColorTexture) {
  };
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled)
      return;
    this._camera = camera;
    this._oriCameraCullingMask = camera.cullingMask;
    camera.cullingMask = this.probeLayer;
    if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
      this._renderTarget = new RenderTarget(this.engine, this.width, this.height, new RenderColorTexture(this.engine, this.width, this.height, void 0, void 0, this._isCube), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, new RenderColorTexture(this.engine, this.width, this.height, void 0, void 0, this._isCube), RenderBufferDepthFormat.Depth, this.antiAliasing);
      this._activeRenderTarget = this._renderTarget;
    }
    this._oriCameraRenderTarget = camera.renderTarget;
    camera.renderTarget = this._activeRenderTarget;
  };
  _proto.onEndRender = function onEndRender(camera) {
    if (!this.enabled)
      return;
    this.onTextureChange && this.onTextureChange(this._texture);
    this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
  };
  _proto._reset = function _reset() {
    if (!this.enabled)
      return;
    this._camera.renderTarget = this._oriCameraRenderTarget;
    this._camera.cullingMask = this._oriCameraCullingMask;
  };
  _createClass(Probe2, [{
    key: "_texture",
    get: function get4() {
      var _this$_activeRenderTa;
      return (_this$_activeRenderTa = this._activeRenderTarget) === null || _this$_activeRenderTa === void 0 ? void 0 : _this$_activeRenderTa.getColorTexture();
    }
  }]);
  return Probe2;
}(Script);
var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();
var CubeProbe = function(_Probe) {
  _inheritsLoose(CubeProbe2, _Probe);
  function CubeProbe2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Probe.call.apply(_Probe, [this].concat(args)) || this;
    _this.position = new Vector3(0, 0, 0);
    _this._isCube = true;
    _this.oriViewMatrix = new Matrix();
    _this._oriFieldOfView = void 0;
    return _this;
  }
  var _proto = CubeProbe2.prototype;
  _proto.onBeginRender = function onBeginRender(camera) {
    if (!this.enabled)
      return;
    _Probe.prototype.onBeginRender.call(this, camera);
    this._storeCamera(camera);
    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
      this._setCamera(faceIndex, camera);
      camera.render(TextureCubeFace.PositiveX + faceIndex);
    }
    this._restoreCamera(camera);
    _Probe.prototype._reset.call(this);
  };
  _proto._storeCamera = function _storeCamera(camera) {
    camera.viewMatrix.cloneTo(this.oriViewMatrix);
    this._oriFieldOfView = camera.fieldOfView;
  };
  _proto._restoreCamera = function _restoreCamera(camera) {
    this.oriViewMatrix.cloneTo(camera.viewMatrix);
    camera.fieldOfView = this._oriFieldOfView;
  };
  _proto._setCamera = function _setCamera(faceIndex, camera) {
    switch (faceIndex) {
      case 0:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(1, 0, 0);
        break;
      case 1:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(-1, 0, 0);
        break;
      case 2:
        cacheUp.setValue(0, 0, 1);
        cacheDir.setValue(0, 1, 0);
        break;
      case 3:
        cacheUp.setValue(0, 0, -1);
        cacheDir.setValue(0, -1, 0);
        break;
      case 4:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, 1);
        break;
      case 5:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, -1);
        break;
    }
    Vector3.add(this.position, cacheDir, cacheTarget);
    Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
    camera.fieldOfView = 90;
  };
  return CubeProbe2;
}(Probe);
var LightShadow = function() {
  LightShadow2._updateShaderData = function _updateShaderData(shaderData) {
    var data = LightShadow2._combinedData;
    shaderData.setFloatArray(LightShadow2._viewMatFromLightProperty, data.viewMatrix);
    shaderData.setFloatArray(LightShadow2._projMatFromLightProperty, data.projectionMatrix);
    shaderData.setFloatArray(LightShadow2._shadowBiasProperty, data.bias);
    shaderData.setFloatArray(LightShadow2._shadowIntensityProperty, data.intensity);
    shaderData.setFloatArray(LightShadow2._shadowRadiusProperty, data.radius);
    shaderData.setFloatArray(LightShadow2._shadowMapSizeProperty, data.mapSize);
    shaderData.setTextureArray(LightShadow2._shadowMapsProperty, data.map);
  };
  LightShadow2.clearMap = function clearMap() {
    LightShadow2._combinedData.map.length = 0;
  };
  function LightShadow2(light, props) {
    if (props === void 0) {
      props = {
        engine: null,
        width: 512,
        height: 512
      };
    }
    this._mapSize = void 0;
    this._renderTarget = void 0;
    this.light = void 0;
    this.bias = 5e-3;
    this.intensity = 0.2;
    this.radius = 1;
    this.projectionMatrix = new Matrix();
    this.light = light;
    var _props = props, engine = _props.engine, width = _props.width, height = _props.height;
    this._mapSize = new Vector2(width, height);
    this._renderTarget = new RenderTarget(engine, width, height, new RenderColorTexture(engine, width, height));
  }
  var _proto = LightShadow2.prototype;
  _proto.initShadowProjectionMatrix = function initShadowProjectionMatrix(light) {
    if (light instanceof DirectLight) {
      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
    }
    if (light instanceof PointLight) {
      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
    }
    if (light instanceof SpotLight) {
      var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
    }
  };
  _proto.appendData = function appendData(lightIndex) {
    var viewStart = lightIndex * 16;
    var projectionStart = lightIndex * 16;
    var biasStart = lightIndex;
    var intensityStart = lightIndex;
    var radiusStart = lightIndex;
    var mapSizeStart = lightIndex * 2;
    var mapStart = lightIndex;
    var data = LightShadow2._combinedData;
    data.viewMatrix.set(this.light.viewMatrix.elements, viewStart);
    data.projectionMatrix.set(this.projectionMatrix.elements, projectionStart);
    data.bias[biasStart] = this.bias;
    data.intensity[intensityStart] = this.intensity;
    data.radius[radiusStart] = this.radius;
    data.mapSize[mapSizeStart] = this.mapSize.x;
    data.mapSize[mapSizeStart + 1] = this.mapSize.y;
    data.map[mapStart] = this.map;
  };
  _createClass(LightShadow2, [{
    key: "renderTarget",
    get: function get4() {
      return this._renderTarget;
    }
  }, {
    key: "map",
    get: function get4() {
      return this._renderTarget.getColorTexture();
    }
  }, {
    key: "mapSize",
    get: function get4() {
      return this._mapSize;
    }
  }]);
  return LightShadow2;
}();
LightShadow._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
LightShadow._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
LightShadow._shadowBiasProperty = Shader.getPropertyByName("u_shadowBias");
LightShadow._shadowIntensityProperty = Shader.getPropertyByName("u_shadowIntensity");
LightShadow._shadowRadiusProperty = Shader.getPropertyByName("u_shadowRadius");
LightShadow._shadowMapSizeProperty = Shader.getPropertyByName("u_shadowMapSize");
LightShadow._shadowMapsProperty = Shader.getPropertyByName("u_shadowMaps");
LightShadow._maxLight = 3;
LightShadow._combinedData = {
  viewMatrix: new Float32Array(16 * LightShadow._maxLight),
  projectionMatrix: new Float32Array(16 * LightShadow._maxLight),
  bias: new Float32Array(LightShadow._maxLight),
  intensity: new Float32Array(LightShadow._maxLight),
  radius: new Float32Array(LightShadow._maxLight),
  mapSize: new Float32Array(2 * LightShadow._maxLight),
  map: []
};
Object.defineProperty(Light.prototype, "enableShadow", {
  get: function get() {
    return this._enableShadow;
  },
  set: function set(enabled) {
    this._enableShadow = enabled;
    if (this._enableShadow) {
      if (this instanceof AmbientLight) {
        this._enableShadow = false;
        Logger.warn("Has no shadow!");
        return;
      }
      this.shadow = this.shadow || new LightShadow(this, {
        engine: this.engine,
        width: 512,
        height: 512
      });
      this.shadow.initShadowProjectionMatrix(this);
    }
  }
});
Object.defineProperty(Component.prototype, "recieveShadow", {
  get: function get2() {
    return this._recieveShadow;
  },
  set: function set2(enabled) {
    this._recieveShadow = enabled;
  }
});
Object.defineProperty(Component.prototype, "castShadow", {
  get: function get3() {
    return this._castShadow;
  },
  set: function set3(enabled) {
    this._castShadow = enabled;
  }
});
var ShadowMapMaterial = function(_Material) {
  _inheritsLoose(ShadowMapMaterial2, _Material);
  function ShadowMapMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("shadow-map")) || this;
    _this.shaderData.enableMacro("O3_GENERATE_SHADOW_MAP");
    return _this;
  }
  return ShadowMapMaterial2;
}(Material);
var ShadowMapPass = function(_RenderPass) {
  _inheritsLoose(ShadowMapPass2, _RenderPass);
  function ShadowMapPass2(name, priority, renderTarget, replaceMaterial, mask, light) {
    var _this;
    _this = _RenderPass.call(this, name, priority, renderTarget, replaceMaterial, mask, new Vector4(1, 1, 1, 1)) || this;
    _this.light = void 0;
    _this.light = light;
    return _this;
  }
  var _proto = ShadowMapPass2.prototype;
  _proto.preRender = function preRender(camera, queue) {
    var shaderData = this.replaceMaterial.shaderData;
    shaderData.setMatrix(ShadowMapPass2._viewMatFromLightProperty, this.light.viewMatrix);
    shaderData.setMatrix(ShadowMapPass2._projMatFromLightProperty, this.light.shadow.projectionMatrix);
  };
  return ShadowMapPass2;
}(RenderPass);
ShadowMapPass._viewMatFromLightProperty = Shader.getPropertyByName("u_viewMatFromLight");
ShadowMapPass._projMatFromLightProperty = Shader.getPropertyByName("u_projMatFromLight");
var ShadowMaterial = function(_Material) {
  _inheritsLoose(ShadowMaterial2, _Material);
  function ShadowMaterial2(engine) {
    var _this;
    _this = _Material.call(this, engine, Shader.find("shadow")) || this;
    var targetBlendState = _this.renderState.blendState.targetBlendState;
    targetBlendState.sourceColorBlendFactor = targetBlendState.sourceAlphaBlendFactor = BlendFactor.DestinationColor;
    targetBlendState.destinationColorBlendFactor = targetBlendState.destinationAlphaBlendFactor = BlendFactor.Zero;
    _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
    _this.renderQueueType = RenderQueueType.Transparent;
    return _this;
  }
  return ShadowMaterial2;
}(Material);
var ShadowPass = function(_RenderPass) {
  _inheritsLoose(ShadowPass2, _RenderPass);
  function ShadowPass2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
    _this.clearMode = ClearMode.DONT_CLEAR;
    return _this;
  }
  var _proto = ShadowPass2.prototype;
  _proto.preRender = function preRender(camera, queue) {
    this.enabled = false;
    var lightMgr = camera.scene.findFeature(LightFeature);
    var lights = lightMgr.visibleLights;
    var shaderData = this.replaceMaterial.shaderData;
    var pass = camera._renderPipeline.defaultRenderPass;
    this.renderTarget = pass.renderTarget;
    var shadowMapCount = 0;
    LightShadow.clearMap();
    for (var i = 0, len = lights.length; i < len; i++) {
      var lgt = lights[i];
      if (lgt.enableShadow) {
        lgt.shadow.appendData(shadowMapCount++);
      }
    }
    if (shadowMapCount) {
      this.enabled = true;
      LightShadow._updateShaderData(shaderData);
      shaderData.enableMacro("O3_SHADOW_MAP_COUNT", shadowMapCount.toString());
    } else {
      shaderData.disableMacro("O3_SHADOW_MAP_COUNT");
    }
  };
  return ShadowPass2;
}(RenderPass);
var ShadowFeature = function(_SceneFeature) {
  _inheritsLoose(ShadowFeature2, _SceneFeature);
  function ShadowFeature2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SceneFeature.call.apply(_SceneFeature, [this].concat(args)) || this;
    _this._shadowPass = void 0;
    _this._shadowMapMaterial = void 0;
    return _this;
  }
  var _proto = ShadowFeature2.prototype;
  _proto.preRender = function preRender(scene, camera) {
    var lights = scene.findFeature(LightFeature).visibleLights;
    if (lights.length > 0) {
      if (!this._shadowPass) {
        this.addShadowPass(camera);
      }
      var renderPipeline = camera._renderPipeline;
      for (var i = 0, len = lights.length; i < len; i++) {
        var lgt = lights[i];
        if (lgt.enableShadow && !lgt.shadowMapPass) {
          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
        } else if (!lgt.enableShadow && lgt.shadowMapPass) {
          renderPipeline.removeRenderPass(lgt.shadowMapPass);
          lgt.shadowMapPass = null;
        }
      }
      this.updatePassRenderFlag(renderPipeline.queue);
    }
  };
  _proto.addShadowPass = function addShadowPass(camera) {
    var shadowMaterial = new ShadowMaterial(camera.engine);
    this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, Layer.Layer30);
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(this._shadowPass);
  };
  _proto.addShadowMapPass = function addShadowMapPass(camera, light) {
    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine);
    var shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, Layer.Layer31, light);
    var renderer = camera._renderPipeline;
    renderer.addRenderPass(shadowMapPass);
    return shadowMapPass;
  };
  _proto.updatePassRenderFlag = function updatePassRenderFlag(renderQueue) {
    var items = renderQueue.items;
    for (var i = 0, len = items.length; i < len; i++) {
      var item = items[i];
      var ability = item.component;
      var recieveShadow = ability.recieveShadow;
      var castShadow = ability.castShadow;
      if (recieveShadow === true) {
        ability.entity.layer |= Layer.Layer30;
      } else if (recieveShadow === false) {
        ability.entity.layer &= ~Layer.Layer30;
      }
      if (castShadow === true) {
        ability.entity.layer |= Layer.Layer31;
      } else if (castShadow === false) {
        ability.entity.layer &= ~Layer.Layer31;
      }
    }
  };
  return ShadowFeature2;
}(SceneFeature);
Scene.registerFeature(ShadowFeature);
Scene.registerFeature(LightFeature);
Scene.prototype.hasLight = hasLight;

// node_modules/@oasis-engine/draco/dist/module.js
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
var DRACOWorker = function() {
  function DRACOWorker2(workerSourceURL, decoderWASMBinary) {
    var _this = this;
    this._worker = void 0;
    this._costs = {};
    this._currentLoad = 0;
    this._callbacks = {};
    this._worker = new Worker(workerSourceURL);
    this._worker.onmessage = function(e) {
      var message = e.data;
      switch (message.type) {
        case "decode":
          _this._callbacks[message.id].resolve(message.geometry);
          break;
        case "error":
          _this._callbacks[message.id].reject(message);
          break;
        default:
          Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
      }
    };
    if (decoderWASMBinary) {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {
          wasmBinary: decoderWASMBinary
        }
      });
    } else {
      this._worker.postMessage({
        type: "init",
        decoderConfig: {}
      });
    }
  }
  var _proto = DRACOWorker2.prototype;
  _proto.setCosts = function setCosts(taskId, cost) {
    this._costs[taskId] = cost;
  };
  _proto.addCurrentLoad = function addCurrentLoad(cost) {
    this._currentLoad += cost;
  };
  _proto.setCallback = function setCallback(taskId, resolve, reject) {
    this._callbacks[taskId] = {
      resolve,
      reject
    };
  };
  _proto.decode = function decode(taskId, taskConfig, buffer) {
    this._worker.postMessage({
      type: "decode",
      id: taskId,
      taskConfig,
      buffer
    }, [buffer]);
  };
  _proto.releaseTask = function releaseTask(taskId) {
    this._currentLoad -= this._costs[taskId];
    delete this._callbacks[taskId];
    delete this._costs[taskId];
  };
  _createClass2(DRACOWorker2, [{
    key: "currentLoad",
    get: function get4() {
      return this._currentLoad;
    }
  }]);
  return DRACOWorker2;
}();
var workerString = '#define GLSLIFY 1\nlet decoderPending;let decoderConfig;onmessage=function(e){const message=e.data;switch(message.type){case "init":decoderConfig=message.decoderConfig;decoderPending=new Promise(function(resolve){decoderConfig.onModuleLoaded=function(draco){resolve({draco: draco});};DracoDecoderModule(decoderConfig);});break;case "decode":const buffer=message.buffer;const taskConfig=message.taskConfig;decoderPending.then(module=>{const draco=module.draco;const decoder=new draco.Decoder();const decoderBuffer=new draco.DecoderBuffer();decoderBuffer.Init(new Int8Array(buffer),buffer.byteLength);try{const geometry=decodeGeometry(draco,decoder,decoderBuffer,taskConfig);const buffers=geometry.attributes.map(attr=>attr.array.buffer);if(geometry.index)buffers.push(geometry.index.array.buffer);self.postMessage({type: "decode",id: message.id,geometry},buffers);}catch(error){console.error(error);self.postMessage({type: "error",id: message.id,error: error.message});}finally{draco.destroy(decoderBuffer);draco.destroy(decoder);}});break;}};function decodeGeometry(draco,decoder,decoderBuffer,taskConfig){const attributeIDs=taskConfig.attributeIDs;const attributeTypes=taskConfig.attributeTypes;let dracoGeometry;let decodingStatus;const geometryType=decoder.GetEncodedGeometryType(decoderBuffer);if(geometryType===draco.TRIANGULAR_MESH){dracoGeometry=new draco.Mesh();decodingStatus=decoder.DecodeBufferToMesh(decoderBuffer,dracoGeometry);}else{throw new Error("DRACODecoder worker: Unexpected geometry type.");}if(!decodingStatus.ok()||dracoGeometry.ptr===0){throw new Error("DRACODecoder worker: Decoding failed: "+decodingStatus.error_msg());}const geometry={index: null,attributes:[]};for(let attributeName in attributeIDs){const attributeType=self[attributeTypes[attributeName]];let attribute;let attributeID;if(taskConfig.useUniqueIDs){attributeID=attributeIDs[attributeName];attribute=decoder.GetAttributeByUniqueId(dracoGeometry,attributeID);}else{attributeID=decoder.GetAttributeId(dracoGeometry,draco[attributeIDs[attributeName]]);if(attributeID===-1)continue;attribute=decoder.GetAttribute(dracoGeometry,attributeID);}geometry.attributes.push(decodeAttribute(draco,decoder,dracoGeometry,attributeName,attributeType,attribute));}if(geometryType===draco.TRIANGULAR_MESH){const numFaces=dracoGeometry.num_faces();const numIndices=numFaces*3;let dataSize;let ptr;let index;const indexType=self[taskConfig.indexType];switch(indexType){case Uint16Array:dataSize=numIndices*2;ptr=draco._malloc(dataSize);decoder.GetTrianglesUInt16Array(dracoGeometry,dataSize,ptr);index=new Uint16Array(draco.HEAPU16.buffer,ptr,numIndices).slice();draco._free(ptr);break;case Uint32Array:dataSize=numIndices*4;ptr=draco._malloc(dataSize);decoder.GetTrianglesUInt32Array(dracoGeometry,dataSize,ptr);index=new Uint32Array(draco.HEAPU32.buffer,ptr,numIndices).slice();draco._free(ptr);default:throw new Error("DRACODecoder: Unexpected index type.");}geometry.index={array: index,itemSize: 1};}draco.destroy(dracoGeometry);return geometry;}function decodeAttribute(draco,decoder,dracoGeometry,attributeName,attributeType,attribute){const numComponents=attribute.num_components();const numPoints=dracoGeometry.num_points();const numValues=numPoints*numComponents;let ptr;let array;let dataSize;switch(attributeType){case Float32Array:dataSize=numValues*4;ptr=draco._malloc(dataSize);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_FLOAT32,dataSize,ptr);array=new Float32Array(draco.HEAPF32.buffer,ptr,numValues).slice();draco._free(ptr);break;case Int8Array:ptr=draco._malloc(numValues);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_INT8,numValues,ptr);array=new Int8Array(draco.HEAP8.buffer,ptr,numValues).slice();draco._free(ptr);break;case Int16Array:dataSize=numValues*2;ptr=draco._malloc(dataSize);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_INT16,dataSize,ptr);array=new Int16Array(draco.HEAP16.buffer,ptr,numValues).slice();draco._free(ptr);break;case Int32Array:dataSize=numValues*4;ptr=draco._malloc(dataSize);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_INT32,dataSize,ptr);array=new Int32Array(draco.HEAP32.buffer,ptr,numValues).slice();draco._free(ptr);break;case Uint8Array:ptr=draco._malloc(numValues);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_UINT8,numValues,ptr);array=new Uint8Array(draco.HEAPU8.buffer,ptr,numValues).slice();draco._free(ptr);break;case Uint16Array:dataSize=numValues*2;ptr=draco._malloc(dataSize);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_UINT16,dataSize,ptr);array=new Uint16Array(draco.HEAPU16.buffer,ptr,numValues).slice();draco._free(ptr);break;case Uint32Array:dataSize=numValues*4;ptr=draco._malloc(dataSize);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,draco.DT_UINT32,dataSize,ptr);array=new Uint32Array(draco.HEAPU32.buffer,ptr,numValues).slice();draco._free(ptr);break;default:throw new Error("DRACODecoder: Unexpected attribute type.");}return{name: attributeName,array: array,itemSize: numComponents};}';
var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
var JS_FILE = "draco_decoder_gltf.js";
var WASM_FILE = "draco_decoder_gltf.r3bin";
var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
var DRACODecoder = function() {
  function DRACODecoder2(config) {
    if (config === void 0) {
      config = {
        type: "wasm",
        workerLimit: 4
      };
    }
    this.pool = [];
    this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
    this.useJS = void 0;
    this.currentTaskId = 1;
    this.taskCache = new WeakMap();
    this.loadLibPromise = void 0;
    if (config.workerLimit > this.workerLimit) {
      Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
    } else {
      var _config$workerLimit;
      this.workerLimit = (_config$workerLimit = config.workerLimit) != null ? _config$workerLimit : 4;
    }
    this.useJS = typeof WebAssembly !== "object" || config.type === "js";
    this.loadLibPromise = this.preloadLib();
  }
  var _proto = DRACODecoder2.prototype;
  _proto.preloadLib = function preloadLib() {
    var _this = this;
    if (this.loadLibPromise) {
      return this.loadLibPromise;
    }
    return new Promise(function(resolve, reject) {
      if (_this.useJS) {
        request("" + LIB_PATH + JS_FILE, {
          type: "text"
        }).then(function(jsSource) {
          var body = [jsSource, workerString].join("\n");
          var workerSourceURL = URL.createObjectURL(new Blob([body]));
          resolve({
            workerSourceURL,
            decoderWASMBinary: null
          });
        }).catch(function(reason) {
          reject(reason);
        });
      } else {
        Promise.all([request("" + LIB_PATH + WASM_WRAPPER_FILE, {
          type: "text"
        }), request("" + LIB_PATH + WASM_FILE, {
          type: "arraybuffer"
        })]).then(function(resources) {
          var wrapperSource = resources[0], decoderWASMBinary = resources[1];
          var body = [wrapperSource, workerString].join("\n");
          var workerSourceURL = URL.createObjectURL(new Blob([body]));
          resolve({
            workerSourceURL,
            decoderWASMBinary
          });
        }).catch(function(reason) {
          reject(reason);
        });
      }
    });
  };
  _proto.getWorker = function getWorker() {
    var _this2 = this;
    return this.preloadLib().then(function(worderResources) {
      if (_this2.pool.length < _this2.workerLimit) {
        var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
        _this2.pool.push(dracoWorker);
      } else {
        _this2.pool.sort(function(a, b) {
          return a.currentLoad > b.currentLoad ? -1 : 1;
        });
      }
      return _this2.pool[_this2.pool.length - 1];
    });
  };
  _proto.decode = function decode(buffer, taskConfig) {
    var _this3 = this;
    var taskKey = JSON.stringify(taskConfig);
    if (this.taskCache.has(buffer)) {
      var cachedTask = this.taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error("DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
    }
    var taskId = this.currentTaskId++;
    var cost = buffer.byteLength;
    var taskWorker;
    var task = new Promise(function(resolve, reject) {
      _this3.getWorker().then(function(worker) {
        taskWorker = worker;
        worker.setCosts(taskId, cost);
        worker.addCurrentLoad(cost);
        worker.setCallback(taskId, resolve, reject);
        worker.decode(taskId, taskConfig, buffer);
      }).catch(function(e) {
        reject(e);
      });
    });
    task.finally(function() {
      if (taskWorker && taskId) {
        taskWorker.releaseTask(taskId);
      }
    });
    this.taskCache.set(buffer, {
      key: taskKey,
      promise: task
    });
    return task;
  };
  return DRACODecoder2;
}();

// node_modules/@oasis-engine/loader/dist/module.js
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct2(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct2 = Reflect.construct;
  } else {
    _construct2 = function _construct3(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct2.apply(null, arguments);
}
function _assertThisInitialized2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
function _applyDecoratedDescriptor2(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var _dec2;
var _class4;
function isBase64(url) {
  return /^data:(.+?);base64,/.test(url);
}
_dec2 = resourceLoader(AssetType.Buffer, ["bin", "r3bin"], false), _dec2(_class4 = function(_Loader) {
  _inheritsLoose2(BufferLoader, _Loader);
  function BufferLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = BufferLoader.prototype;
  _proto.load = function load(item) {
    var url = item.url;
    if (isBase64(url)) {
      return new AssetPromise(function(resolve) {
        var base64Str = url.slice(13 + RegExp.$1.length);
        var result = Uint8Array.from(atob(base64Str), function(c) {
          return c.charCodeAt(0);
        });
        resolve(result.buffer);
      });
    }
    return this.request(url, _objectSpread22(_objectSpread22({}, item), {}, {
      type: "arraybuffer"
    }));
  };
  return BufferLoader;
}(Loader)) || _class4;
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function decodeText(array) {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(array);
  }
  var s = "";
  for (var i = 0, il = array.length; i < il; i++) {
    s += String.fromCharCode(array[i]);
  }
  return decodeURIComponent(encodeURIComponent(s));
}
function getAccessorTypeSize(accessorType) {
  var ACCESSOR_TYPE_SIZE = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  return ACCESSOR_TYPE_SIZE[accessorType];
}
function getComponentType(componentType) {
  return WEBGL_COMPONENT_TYPES[componentType];
}
function getAccessorData(gltf, accessor, buffers) {
  var _bufferView$byteStrid;
  var bufferView = gltf.bufferViews[accessor.bufferView];
  var arrayBuffer = buffers[bufferView.buffer];
  var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
  var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
  var byteOffset = accessorByteOffset + bufferViewByteOffset;
  var accessorTypeSize = getAccessorTypeSize(accessor.type);
  var length = accessorTypeSize * accessor.count;
  var byteStride = (_bufferView$byteStrid = bufferView.byteStride) != null ? _bufferView$byteStrid : 0;
  var arrayType = getComponentType(accessor.componentType);
  var uint8Array;
  if (byteStride) {
    uint8Array = new Uint8Array(length * arrayType.BYTES_PER_ELEMENT);
    var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
    var viewAccessor = 0;
    var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
    for (var i = 0; i < accessor.count; i++) {
      viewAccessor = i * byteStride + accessorByteOffset;
      for (var j = 0; j < accessorByteSize; j++) {
        uint8Array[i * accessorByteSize + j] = originalBufferView[viewAccessor + j];
      }
    }
  } else {
    uint8Array = new Uint8Array(arrayBuffer, byteOffset, length * arrayType.BYTES_PER_ELEMENT);
    uint8Array = new Uint8Array(uint8Array);
  }
  return new arrayType(uint8Array.buffer);
}
function getBufferData(bufferView, buffers) {
  var arrayBuffer = buffers[bufferView.buffer];
  var byteOffset = bufferView.byteOffset || 0;
  return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
}
function getVertexStride(accessor) {
  var size = getAccessorTypeSize(accessor.type);
  var componentType = getComponentType(accessor.componentType);
  return size * componentType.BYTES_PER_ELEMENT;
}
function createVertexElement(gltf, semantic, accessor, index) {
  var size = getAccessorTypeSize(accessor.type);
  return new VertexElement(semantic, 0, getElementFormat(accessor.componentType, size), index);
}
function getIndexFormat(type) {
  switch (type) {
    case DataType.UNSIGNED_BYTE:
      return IndexFormat.UInt8;
    case DataType.UNSIGNED_SHORT:
      return IndexFormat.UInt16;
    case DataType.UNSIGNED_INT:
      return IndexFormat.UInt32;
  }
}
function getElementFormat(type, size) {
  if (type == DataType.FLOAT) {
    switch (size) {
      case 1:
        return VertexElementFormat.Float;
      case 2:
        return VertexElementFormat.Vector2;
      case 3:
        return VertexElementFormat.Vector3;
      case 4:
        return VertexElementFormat.Vector4;
    }
  }
  if (type == DataType.UNSIGNED_SHORT) {
    switch (size) {
      case 2:
        return VertexElementFormat.UShort2;
      case 4:
        return VertexElementFormat.UShort4;
    }
  }
}
function loadImageBuffer(imageBuffer, type) {
  return new Promise(function(resolve, reject) {
    var blob = new window.Blob([imageBuffer], {
      type
    });
    var img = new Image();
    img.src = URL.createObjectURL(blob);
    img.crossOrigin = "anonymous";
    img.onerror = function() {
      reject(new Error("Failed to load image buffer"));
    };
    img.onload = function() {
      requestAnimationFrame(function() {
        resolve(img);
      });
    };
  });
}
function isAbsoluteUrl(url) {
  return /^(?:http|blob|data:|\/)/.test(url);
}
function parseRelativeUrl(baseUrl, relativeUrl) {
  if (isAbsoluteUrl(relativeUrl)) {
    return relativeUrl;
  }
  return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
}
var decoder;
var glTFDracoMeshCompression = {
  init: function init() {
    if (!decoder) {
      decoder = new DRACODecoder();
    }
  },
  parse: function parse(extension, gltfPrimitive, gltf, buffers) {
    var bufferViews = gltf.bufferViews, accessors = gltf.accessors;
    var bufferViewIndex = extension.bufferView;
    var gltfAttributeMap = extension.attributes;
    var attributeMap = {};
    var attributeTypeMap = {};
    for (var attributeName in gltfAttributeMap) {
      attributeMap[attributeName] = gltfAttributeMap[attributeName];
    }
    for (var _attributeName in gltfPrimitive.attributes) {
      if (gltfAttributeMap[_attributeName] !== void 0) {
        var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
        attributeTypeMap[_attributeName] = getComponentType(accessorDef.componentType).name;
      }
    }
    var indexAccessor = accessors[gltfPrimitive.indices];
    var indexType = getComponentType(indexAccessor.componentType).name;
    var taskConfig = {
      attributeIDs: attributeMap,
      attributeTypes: attributeTypeMap,
      useUniqueIDs: true,
      indexType
    };
    var buffer = getBufferData(bufferViews[bufferViewIndex], buffers);
    return decoder.decode(buffer, taskConfig).then(function(parsedGeometry) {
      return parsedGeometry;
    });
  }
};
var TARGET_PATH_MAP = {
  translation: "position",
  rotation: "rotation",
  scale: "scale",
  weights: "weights"
};
var nodeCount = 0;
var RegistedObjs = {};
var RegistedCustomMaterials = {};
var getDefaultMaterial = function() {
  return function(engine) {
    var defaultMateril = new BlinnPhongMaterial(engine);
    defaultMateril.emissiveColor = new Color(0.749, 0.749, 0.749, 1);
    return defaultMateril;
  };
}();
var HandledExtensions = {
  PBRMaterial: "PBRMaterial",
  KHR_lights: "KHR_lights",
  KHR_materials_unlit: "KHR_materials_unlit",
  KHR_materials_pbrSpecularGlossiness: "KHR_materials_pbrSpecularGlossiness",
  KHR_techniques_webgl: "KHR_techniques_webgl",
  KHR_draco_mesh_compression: "KHR_draco_mesh_compression"
};
var KHR_lights = null;
var extensionParsers = {
  KHR_lights,
  KHR_materials_unlit: UnlitMaterial,
  KHR_materials_pbrSpecularGlossiness: PBRSpecularMaterial,
  KHR_techniques_webgl: Material,
  KHR_draco_mesh_compression: glTFDracoMeshCompression
};
function RegistExtension(extobj) {
  Object.keys(extobj).forEach(function(name) {
    if (RegistedObjs[name] === void 0) {
      RegistedObjs[name] = extobj[name];
      switch (name) {
        case HandledExtensions.KHR_lights:
          KHR_lights = extobj[name];
          extensionParsers.KHR_lights = KHR_lights;
          break;
        default:
          if (Material.isPrototypeOf(extobj[name]) && extobj[name].TECH_NAME)
            RegistedCustomMaterials[extobj[name].TECH_NAME] = extobj[name];
          break;
      }
    }
  });
}
var GLTFResource = function(_EngineObject) {
  _inheritsLoose2(GLTFResource2, _EngineObject);
  function GLTFResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _EngineObject.call.apply(_EngineObject, [this].concat(args)) || this;
    _this.defaultSceneRoot = void 0;
    _this.defaultScene = void 0;
    _this.scenes = void 0;
    _this.textures = void 0;
    _this.animations = void 0;
    _this.materials = void 0;
    _this.meshes = void 0;
    _this.skins = void 0;
    _this.cameras = void 0;
    _this.meta = void 0;
    return _this;
  }
  return GLTFResource2;
}(EngineObject);
function parseGLTF(data, engine) {
  var resources = {
    engine,
    gltf: data.gltf,
    buffers: data.buffers,
    asset: new GLTFResource(engine)
  };
  resources.asset.textures = data.textures;
  resources.asset.meta = data.gltf;
  if (resources.gltf.asset && resources.gltf.asset.version) {
    resources.gltf.version = Number(resources.gltf.asset.version);
    resources.gltf.isGltf2 = resources.gltf.version >= 2 && resources.gltf.version <= 3;
  }
  parseExtensions(resources);
  return parseResources(resources, "materials", parseMaterial).then(function() {
    return parseResources(resources, "meshes", parseMesh);
  }).then(function() {
    return parseResources(resources, "nodes", parseNode);
  }).then(function() {
    return parseResources(resources, "scenes", parseScene);
  }).then(function() {
    return parseResources(resources, "skins", parseSkin);
  }).then(function() {
    return parseResources(resources, "animations", parseAnimation);
  }).then(function() {
    return buildSceneGraph(resources);
  });
}
function parseExtensions(resources) {
  var gltf = resources.gltf, asset = resources.asset;
  var extensions = gltf.extensions, extensionsUsed = gltf.extensionsUsed, extensionsRequired = gltf.extensionsRequired;
  if (extensionsUsed) {
    Logger.info("extensionsUsed: ", extensionsUsed);
    for (var i = 0; i < extensionsUsed.length; i++) {
      if (Object.keys(extensionParsers).indexOf(extensionsUsed[i]) > -1) {
        if (!extensionParsers[extensionsUsed[i]]) {
          Logger.warn("extension " + extensionsUsed[i] + " is used, you can add this extension into gltf");
        }
      } else {
        Logger.warn("extensionsUsed has unsupported extension " + extensionsUsed[i]);
      }
    }
  }
  if (extensionsRequired) {
    Logger.info("extensionsRequired: " + extensionsRequired);
    for (var _i = 0; _i < extensionsRequired.length; _i++) {
      if (Object.keys(extensionParsers).indexOf(extensionsRequired[_i]) < 0 || !extensionParsers[extensionsRequired[_i]]) {
        Logger.error("model has not supported required extension " + extensionsRequired[_i]);
      }
      if (extensionsRequired[_i] === HandledExtensions.KHR_draco_mesh_compression) {
        extensionParsers.KHR_draco_mesh_compression.init();
      }
    }
  }
  if (extensions) {
    if (KHR_lights && extensions.KHR_lights) {
      asset.lights = KHR_lights.parseLights(extensions.KHR_lights.lights);
    }
  }
}
function parseResources(resources, name, handler) {
  var gltf = resources.gltf, asset = resources.asset;
  if (!asset[name]) {
    asset[name] = [];
  }
  if (gltf.hasOwnProperty(name)) {
    var entities = gltf[name] || [];
    Logger.debug(name + ":", entities);
    var promises = [];
    for (var i = entities.length - 1; i >= 0; i--) {
      promises.push(handler(entities[i], resources));
    }
    return Promise.all(promises).then(function(results) {
      for (var _i2 = 0; _i2 < results.length; _i2++) {
        asset[name].push(results[_i2]);
      }
    });
  }
  return Promise.resolve();
}
function parseMaterial(gltfMaterial, resources) {
  var gltf = resources.gltf, engine = resources.engine;
  if (gltf.isGltf2 && typeof gltfMaterial.technique === "undefined") {
    var _gltfMaterial$extensi = gltfMaterial.extensions, extensions = _gltfMaterial$extensi === void 0 ? {} : _gltfMaterial$extensi, pbrMetallicRoughness = gltfMaterial.pbrMetallicRoughness, normalTexture = gltfMaterial.normalTexture, emissiveTexture = gltfMaterial.emissiveTexture, emissiveFactor = gltfMaterial.emissiveFactor, occlusionTexture = gltfMaterial.occlusionTexture, alphaMode = gltfMaterial.alphaMode, alphaCutoff = gltfMaterial.alphaCutoff, doubleSided = gltfMaterial.doubleSided;
    var isUnlit = extensions.KHR_materials_unlit;
    var isSpecular = extensions.KHR_materials_pbrSpecularGlossiness;
    var material = null;
    if (isUnlit) {
      material = new UnlitMaterial(engine);
    } else if (isSpecular) {
      material = new PBRSpecularMaterial(engine);
    } else {
      material = new PBRMaterial(engine);
    }
    material.doubleSided = doubleSided;
    switch (alphaMode) {
      case "OPAQUE":
        material.alphaMode = AlphaMode.Opaque;
        break;
      case "BLEND":
        material.alphaMode = AlphaMode.Blend;
        break;
      case "MASK":
        material.alphaMode = AlphaMode.CutOff;
        material.alphaCutoff = alphaCutoff === void 0 ? 0.5 : alphaCutoff;
        break;
    }
    if (pbrMetallicRoughness) {
      var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
      if (baseColorTexture) {
        material.baseColorTexture = getItemByIdx("textures", baseColorTexture.index || 0, resources, false);
      }
      if (baseColorFactor) {
        material.baseColor = _construct2(Color, baseColorFactor);
      }
      if (!isUnlit) {
        material = material;
        material.metallicFactor = metallicFactor !== void 0 ? metallicFactor : 1;
        material.roughnessFactor = roughnessFactor !== void 0 ? roughnessFactor : 1;
        if (metallicRoughnessTexture) {
          material.metallicRoughnessTexture = getItemByIdx("textures", metallicRoughnessTexture.index || 0, resources, false);
        }
      }
    }
    if (isUnlit) {
      return Promise.resolve(material);
    }
    material = material;
    if (emissiveTexture) {
      material.emissiveTexture = getItemByIdx("textures", emissiveTexture.index || 0, resources, false);
    }
    if (emissiveFactor) {
      material.emissiveColor = _construct2(Color, emissiveFactor);
    }
    if (normalTexture) {
      var index = normalTexture.index;
      normalTexture.texCoord;
      var scale = normalTexture.scale;
      material = material;
      material.normalTexture = getItemByIdx("textures", index || 0, resources, false);
      if (typeof scale !== void 0) {
        material.normalScale = scale;
      }
    }
    if (occlusionTexture) {
      material = material;
      material.occlusionTexture = getItemByIdx("textures", occlusionTexture.index || 0, resources, false);
      if (occlusionTexture.strength !== void 0) {
        material.occlusionStrength = occlusionTexture.strength;
      }
    }
    if (isSpecular) {
      var _extensions$KHR_mater = extensions.KHR_materials_pbrSpecularGlossiness, diffuseFactor = _extensions$KHR_mater.diffuseFactor, diffuseTexture = _extensions$KHR_mater.diffuseTexture, specularFactor = _extensions$KHR_mater.specularFactor, glossinessFactor = _extensions$KHR_mater.glossinessFactor, specularGlossinessTexture = _extensions$KHR_mater.specularGlossinessTexture;
      material = material;
      if (diffuseFactor) {
        material.baseColor = _construct2(Color, diffuseFactor);
      }
      if (diffuseTexture) {
        material.baseColorTexture = getItemByIdx("textures", diffuseTexture.index || 0, resources, false);
      }
      if (specularFactor) {
        material.specularColor = _construct2(Color, specularFactor);
      }
      if (glossinessFactor !== void 0) {
        material.glossinessFactor = glossinessFactor;
      }
      if (specularGlossinessTexture) {
        material.specularGlossinessTexture = getItemByIdx("textures", specularGlossinessTexture.index || 0, resources, false);
      }
    }
    return Promise.resolve(material);
  } else {
    var techniqueName = gltfMaterial.technique;
    Logger.warn("Deprecated: Please use a model that meets the glTF 2.0 specification");
    if (techniqueName === "Texture") {
      var _material = new UnlitMaterial(engine);
      var _index = gltfMaterial.values._MainTex[0];
      _material.baseColorTexture = getItemByIdx("textures", _index || 0, resources, false);
      return Promise.resolve(_material);
    }
  }
  return Promise.resolve();
}
function parseSkin(gltfSkin, resources) {
  var gltf = resources.gltf, buffers = resources.buffers;
  var jointCount = gltfSkin.joints.length;
  var skin = new Skin(gltfSkin.name);
  var accessor = gltf.accessors[gltfSkin.inverseBindMatrices];
  var buffer = getAccessorData(gltf, accessor, buffers);
  var MAT4_LENGTH = 16;
  for (var i = 0; i < jointCount; i++) {
    var startIdx = MAT4_LENGTH * i;
    var endIdx = startIdx + MAT4_LENGTH;
    skin.inverseBindMatrices[i] = _construct2(Matrix, buffer.subarray(startIdx, endIdx));
  }
  for (var _i3 = 0; _i3 < jointCount; _i3++) {
    var _node = getItemByIdx("nodes", gltfSkin.joints[_i3], resources);
    skin.joints[_i3] = _node.name;
  }
  var node = getItemByIdx("nodes", gltfSkin.skeleton == null ? gltfSkin.joints[0] : gltfSkin.skeleton, resources);
  skin.skeleton = node.name;
  return Promise.resolve(skin);
}
function parsePrimitiveVertex(mesh, primitive, primitiveGroup, gltfPrimitive, gltf, getVertexBufferData, getIndexBufferData, engine) {
  var i = 0;
  var vertexElements = [];
  for (var attributeSemantic in gltfPrimitive.attributes) {
    var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
    var accessor = gltf.accessors[accessorIdx];
    var stride = getVertexStride(accessor);
    var vertexELement = createVertexElement(gltf, attributeSemantic, accessor, i);
    vertexElements.push(vertexELement);
    var bufferData = getVertexBufferData(attributeSemantic);
    var vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, bufferData.byteLength, BufferUsage.Static);
    vertexBuffer.setData(bufferData);
    primitive.setVertexBufferBinding(vertexBuffer, stride, i++);
    if (vertexELement.semantic == "POSITION") {
      var position = new Vector3();
      var vertexCount = bufferData.length / 3;
      var _mesh$bounds = mesh.bounds, min = _mesh$bounds.min, max = _mesh$bounds.max;
      for (var _i4 = 0; _i4 < vertexCount; _i4++) {
        var offset = _i4 * 3;
        position.setValue(bufferData[offset], bufferData[offset + 1], bufferData[offset + 2]);
        Vector3.min(min, position, min);
        Vector3.max(max, position, max);
      }
    }
  }
  primitive.setVertexElements(vertexElements);
  var indexAccessor = gltf.accessors[gltfPrimitive.indices];
  var indexData = getIndexBufferData();
  var indexCount = indexAccessor.count;
  var indexFormat = getIndexFormat(indexAccessor.componentType);
  var indexByteSize = indexFormat == IndexFormat.UInt32 ? 4 : indexFormat == IndexFormat.UInt16 ? 2 : 1;
  var indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indexCount * indexByteSize, BufferUsage.Static);
  indexBuffer.setData(indexData);
  primitive.setIndexBufferBinding(new IndexBufferBinding(indexBuffer, indexFormat));
  primitiveGroup.start = 0;
  primitiveGroup.count = indexCount;
  return Promise.resolve(primitive);
}
function parseMesh(gltfMesh, resources) {
  var gltf = resources.gltf, buffers = resources.buffers, engine = resources.engine;
  var mesh = new Mesh(gltfMesh.name);
  var primitivePromises = [];
  var groups = [];
  var _loop = function _loop2(i2) {
    primitivePromises.push(new Promise(function(resolve, reject) {
      var gltfPrimitive = gltfMesh.primitives[i2];
      var primitive = new Primitive(engine, gltfPrimitive.name || gltfMesh.name || i2);
      var subPrimitive = new SubPrimitive();
      groups.push(subPrimitive);
      subPrimitive.topology = gltfPrimitive.mode == null ? PrimitiveTopology.Triangles : gltfPrimitive.mode;
      if (gltfPrimitive.hasOwnProperty("targets")) {
        primitive.targets = [];
        mesh.weights = gltfMesh.weights || new Array(gltfPrimitive.targets.length).fill(0);
      }
      var vertexPromise;
      if (gltfPrimitive.extensions && gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression]) {
        var extensionParser = extensionParsers.KHR_draco_mesh_compression;
        var extension = gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression];
        vertexPromise = extensionParser.parse(extension, gltfPrimitive, gltf, buffers).then(function(decodedGeometry) {
          return parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, function(attributeSemantic) {
            for (var _i6 = 0; _i6 < decodedGeometry.attributes.length; _i6++) {
              if (decodedGeometry.attributes[_i6].name === attributeSemantic) {
                return decodedGeometry.attributes[_i6].array;
              }
            }
            return null;
          }, function() {
            return decodedGeometry.index.array;
          }, resources.engine);
        });
      } else {
        vertexPromise = parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, function(attributeSemantic) {
          var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
          var accessor = gltf.accessors[accessorIdx];
          return getAccessorData(gltf, accessor, buffers);
        }, function() {
          var indexAccessor = gltf.accessors[gltfPrimitive.indices];
          return getAccessorData(gltf, indexAccessor, buffers);
        }, resources.engine);
      }
      vertexPromise.then(function(processedPrimitive) {
        resolve(processedPrimitive);
      }).catch(function(e) {
        reject(e);
      });
    }));
  };
  for (var i = 0; i < gltfMesh.primitives.length; i++) {
    _loop(i);
  }
  return Promise.all(primitivePromises).then(function(primitives) {
    for (var _i5 = 0; _i5 < primitives.length; _i5++) {
      mesh.primitives.push(primitives[_i5]);
      mesh.groups.push(groups[_i5]);
    }
    return mesh;
  });
}
function parseAnimation(gltfAnimation, resources) {
  var gltf = resources.gltf, buffers = resources.buffers;
  var gltfSamplers = gltfAnimation.samplers || [];
  var gltfChannels = gltfAnimation.channels || [];
  var animationIdx = gltf.animations.indexOf(gltfAnimation);
  var animationClip = new AnimationClip(gltfAnimation.name || "Animation" + animationIdx);
  var duration = -1;
  var durationIndex = -1;
  for (var i = 0; i < gltfSamplers.length; i++) {
    var gltfSampler = gltfSamplers[i];
    var inputAccessor = gltf.accessors[gltfSampler.input];
    var outputAccessor = gltf.accessors[gltfSampler.output];
    var input = getAccessorData(gltf, inputAccessor, buffers);
    var output = getAccessorData(gltf, outputAccessor, buffers);
    var outputAccessorSize = getAccessorTypeSize(outputAccessor.type);
    if (outputAccessorSize * input.length !== output.length)
      outputAccessorSize = output.length / input.length;
    var samplerInterpolation = InterpolationType.LINEAR;
    switch (gltfSampler.interpolation) {
      case "CUBICSPLINE":
        samplerInterpolation = InterpolationType.CUBICSPLINE;
        break;
      case "STEP":
        samplerInterpolation = InterpolationType.STEP;
        break;
    }
    var maxTime = input[input.length - 1];
    if (maxTime > duration) {
      duration = maxTime;
      durationIndex = i;
    }
    animationClip.addSampler(input, output, outputAccessorSize, samplerInterpolation);
  }
  animationClip.durationIndex = durationIndex;
  animationClip.duration = duration;
  for (var _i7 = 0; _i7 < gltfChannels.length; _i7++) {
    var gltfChannel = gltfChannels[_i7];
    var target = gltfChannel.target;
    var samplerIndex = gltfChannel.sampler;
    var targetNode = getItemByIdx("nodes", target.node, resources);
    var targetPath = TARGET_PATH_MAP[target.path];
    animationClip.addChannel(samplerIndex, targetNode.name, targetPath);
  }
  return Promise.resolve(animationClip);
}
function parseNode(gltfNode, resources) {
  var entity = new Entity(resources.engine, gltfNode.name || "GLTF_NODE_" + nodeCount++);
  if (gltfNode.hasOwnProperty("matrix")) {
    var m = gltfNode.matrix;
    var mat = new Matrix();
    mat.setValueByArray(m);
    var pos = new Vector3();
    var scale = new Vector3(1, 1, 1);
    var rot = new Quaternion();
    mat.decompose(pos, rot, scale);
    entity.transform.position = pos;
    entity.transform.rotationQuaternion = rot;
    entity.transform.scale = scale;
  } else {
    for (var key in TARGET_PATH_MAP) {
      if (gltfNode.hasOwnProperty(key)) {
        var mapKey = TARGET_PATH_MAP[key];
        if (mapKey === "weights") {
          entity[mapKey] = gltfNode[key];
        } else {
          var arr = gltfNode[key];
          var len = arr.length;
          var obj = entity[mapKey];
          if (len === 2) {
            obj.setValue(arr[0], arr[1]);
          } else if (len === 3) {
            obj.setValue(arr[0], arr[1], arr[2]);
          } else if (len === 4) {
            obj.setValue(arr[0], arr[1], arr[2], arr[3]);
          }
          entity[mapKey] = obj;
        }
      }
    }
  }
  if (gltfNode.camera !== void 0) {
    var cameraOptions = resources.gltf.cameras[gltfNode.camera];
    var camera = entity.addComponent(Camera);
    if (cameraOptions.type === "orthographic") {
      camera.isOrthographic = true;
      var _cameraOptions$orthog = cameraOptions.orthographic, ymag = _cameraOptions$orthog.ymag, xmag = _cameraOptions$orthog.xmag, zfar = _cameraOptions$orthog.zfar, znear = _cameraOptions$orthog.znear;
      if (znear !== void 0) {
        camera.nearClipPlane = znear;
      }
      if (zfar !== void 0) {
        camera.farClipPlane = zfar;
      }
      if (ymag && xmag) {
        camera.orthographicSize = Math.max(ymag, xmag) / 2;
      }
      if (ymag !== void 0 && xmag) {
        camera.orthographicSize = xmag / 2;
      }
      if (xmag !== void 0 && ymag) {
        camera.orthographicSize = ymag / 2;
      }
    } else {
      var _cameraOptions$perspe = cameraOptions.perspective, aspectRatio = _cameraOptions$perspe.aspectRatio, yfov = _cameraOptions$perspe.yfov, _zfar = _cameraOptions$perspe.zfar, _znear = _cameraOptions$perspe.znear;
      if (aspectRatio !== void 0) {
        camera.aspectRatio = aspectRatio;
      }
      if (yfov !== void 0) {
        camera.fieldOfView = yfov;
      }
      if (_zfar !== void 0) {
        camera.farClipPlane = _zfar;
      }
      if (_znear !== void 0) {
        camera.nearClipPlane = _znear;
      }
    }
  }
  if (gltfNode.extensions) {
    if (KHR_lights && gltfNode.extensions.KHR_lights) {
      var lightIdx = gltfNode.extensions.KHR_lights.light;
      if (lightIdx !== void 0) {
        var light = getItemByIdx("lights", lightIdx, resources);
        if (light) {
          var lightCon = entity.addComponent(light.ability);
          _extends2(lightCon, light.props);
        }
      }
    }
  }
  return Promise.resolve(entity);
}
function parseScene(gltfScene, resources) {
  var sceneNodes = [];
  for (var i = 0; i < gltfScene.nodes.length; i++) {
    var node = getItemByIdx("nodes", gltfScene.nodes[i], resources);
    sceneNodes.push(node);
  }
  if (gltfScene.extensions) {
    if (KHR_lights && gltfScene.extensions.KHR_lights) {
      var lightIdx = gltfScene.extensions.KHR_lights.light;
      if (lightIdx !== void 0) {
        var light = getItemByIdx("lights", lightIdx, resources);
        if (light)
          sceneNodes[0].addComponent(light.ability, light.props);
      }
    }
  }
  return Promise.resolve({
    nodes: sceneNodes
  });
}
function getItemByIdx(name, idx, resources, inverse) {
  if (inverse === void 0) {
    inverse = true;
  }
  var asset = resources.asset;
  var itemIdx = inverse ? asset[name].length - idx - 1 : idx;
  return asset[name][itemIdx];
}
function buildSceneGraph(resources) {
  var _gltf$scene;
  var asset = resources.asset, gltf = resources.gltf;
  var gltfNodes = gltf.nodes || [];
  var gltfMeshes = gltf.meshes;
  asset.defaultScene = getItemByIdx("scenes", (_gltf$scene = gltf.scene) != null ? _gltf$scene : 0, resources);
  for (var i = gltfNodes.length - 1; i >= 0; i--) {
    var gltfNode = gltfNodes[i];
    var node = getItemByIdx("nodes", i, resources);
    if (gltfNode.hasOwnProperty("children")) {
      var children = gltfNode.children || [];
      for (var j = children.length - 1; j >= 0; j--) {
        var childNode = getItemByIdx("nodes", children[j], resources);
        node.addChild(childNode);
      }
    }
    if (gltfNode.hasOwnProperty("mesh")) {
      var meshIndex = gltfNode.mesh;
      node.meshIndex = meshIndex;
      var gltfMeshPrimitives = gltfMeshes[meshIndex].primitives;
      var mesh = getItemByIdx("meshes", meshIndex, resources);
      var renderer = void 0;
      if (gltfNode.hasOwnProperty("skin") || mesh.hasOwnProperty("weights")) {
        var skin = getItemByIdx("skins", gltfNode.skin, resources);
        var weights = mesh.weights;
        var skinRenderer = node.addComponent(SkinnedMeshRenderer);
        skinRenderer.mesh = mesh;
        skinRenderer.skin = skin;
        skinRenderer.setWeights(weights);
        renderer = skinRenderer;
      } else {
        renderer = node.addComponent(MeshRenderer);
        renderer.mesh = mesh;
      }
      for (var _j = 0, m = gltfMeshPrimitives.length; _j < m; _j++) {
        var materialIndex = gltfMeshPrimitives[_j].material;
        mesh.primitives[_j].materialIndex = materialIndex;
        var material = materialIndex !== void 0 ? getItemByIdx("materials", materialIndex, resources) : getDefaultMaterial(node.engine);
        renderer.setSharedMaterial(_j, material);
      }
    }
  }
  var nodes = asset.defaultScene.nodes;
  if (nodes.length === 1) {
    asset.defaultSceneRoot = nodes[0];
  } else {
    var rootNode = new Entity(resources.engine);
    for (var _i8 = 0; _i8 < nodes.length; _i8++) {
      rootNode.addChild(nodes[_i8]);
    }
    asset.defaultSceneRoot = rootNode;
  }
  var animator = asset.defaultSceneRoot.addComponent(Animation);
  var animations = asset.animations;
  if (animations) {
    animations.forEach(function(clip) {
      animator.addAnimationClip(clip, clip.name);
    });
  }
  return resources.asset;
}
function parseGLB(glb) {
  var UINT32_LENGTH = 4;
  var GLB_HEADER_MAGIC = 1179937895;
  var GLB_HEADER_LENGTH = 12;
  var GLB_CHUNK_TYPES = {
    JSON: 1313821514,
    BIN: 5130562
  };
  var dataView = new DataView(glb);
  var header = {
    magic: dataView.getUint32(0, true),
    version: dataView.getUint32(UINT32_LENGTH, true),
    length: dataView.getUint32(2 * UINT32_LENGTH, true)
  };
  if (header.magic !== GLB_HEADER_MAGIC) {
    console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
    return null;
  }
  var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
  var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
  if (chunkType !== GLB_CHUNK_TYPES.JSON) {
    console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
    return null;
  }
  var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
  var gltf = JSON.parse(decodeText(glTFData));
  var buffers = [];
  var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
  while (byteOffset < header.length) {
    chunkLength = dataView.getUint32(byteOffset, true);
    chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
    if (chunkType !== GLB_CHUNK_TYPES.BIN) {
      console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
      return null;
    }
    var currentOffset = byteOffset + 2 * UINT32_LENGTH;
    var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
    buffers.push(buffer);
    byteOffset += chunkLength + 2 * UINT32_LENGTH;
  }
  return {
    gltf,
    buffers
  };
}
var _dec$1;
var _class$12;
var _temp2;
_dec$1 = resourceLoader(AssetType.Perfab, ["gltf", "glb"]), _dec$1(_class$12 = (_temp2 = function(_Loader) {
  _inheritsLoose2(GLTFLoader, _Loader);
  function GLTFLoader() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Loader.call.apply(_Loader, [this].concat(args)) || this;
    _this.baseUrl = void 0;
    _this.requestGLTF = function(item, resourceManager) {
      return _this.request(item.url, _objectSpread22(_objectSpread22({}, item), {}, {
        type: "json"
      })).then(function(res) {
        return _this._loadGLTFResources(item, res, resourceManager);
      });
    };
    _this.requestGLB = function(item, resourceManager) {
      return _this.request(item.url, _objectSpread22(_objectSpread22({}, item), {}, {
        type: "arraybuffer"
      })).then(parseGLB).then(function(res) {
        return _objectSpread22(_objectSpread22({}, res), {}, {
          baseUrl: item.url,
          resourceManager
        });
      }).then(_this._loadImages);
    };
    _this._loadImages = function(_ref) {
      var gltf = _ref.gltf, buffers = _ref.buffers, baseUrl = _ref.baseUrl, resourceManager = _ref.resourceManager;
      if (gltf.images) {
        return Promise.all(gltf.images.map(function(_ref2) {
          var uri = _ref2.uri, bufferViewIndex = _ref2.bufferView, mimeType2 = _ref2.mimeType;
          if (uri) {
            return resourceManager.load({
              url: parseRelativeUrl(baseUrl, uri),
              type: AssetType.Texture2D
            });
          } else {
            var bufferView = gltf.bufferViews[bufferViewIndex];
            var bufferData = getBufferData(bufferView, buffers);
            return loadImageBuffer(bufferData, mimeType2).then(function(image) {
              var tex = new Texture2D(resourceManager.engine, image.width, image.height);
              tex.setImageSource(image);
              tex.generateMipmaps();
              return tex;
            });
          }
        })).then(function(textures) {
          return {
            gltf,
            buffers,
            textures
          };
        });
      }
      return Promise.resolve({
        gltf,
        buffers
      });
    };
    return _this;
  }
  var _proto = GLTFLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this2 = this;
    return new AssetPromise(function(resolve, reject) {
      var requestGLTFResource = _this2.isGLB(item.url) ? _this2.requestGLB : _this2.requestGLTF;
      requestGLTFResource(item, resourceManager).then(function(res) {
        parseGLTF(res, resourceManager.engine).then(function(gltf) {
          resolve(gltf);
        });
      }).catch(function(e) {
        console.error(e);
        reject("Error loading glTF JSON from " + item.url);
      });
    });
  };
  _proto.isGLB = function isGLB(url) {
    return url.substring(url.lastIndexOf(".") + 1) === "glb";
  };
  _proto._loadGLTFResources = function _loadGLTFResources(item, gltf, resourceManager) {
    return this._loadBuffers(item.url, gltf, resourceManager).then(this._loadImages);
  };
  _proto._loadBuffers = function _loadBuffers(baseUrl, gltf, resourceManager) {
    if (gltf.buffers) {
      return Promise.all(gltf.buffers.map(function(item) {
        if (item instanceof ArrayBuffer) {
          return Promise.resolve(item);
        }
        return resourceManager.load({
          url: parseRelativeUrl(baseUrl, item.uri),
          type: AssetType.Buffer
        });
      })).then(function(buffers) {
        return {
          buffers,
          gltf,
          baseUrl,
          resourceManager
        };
      });
    }
    return Promise.resolve({
      baseUrl,
      gltf,
      resourceManager
    });
  };
  return GLTFLoader;
}(Loader), _temp2)) || _class$12;
var _dec$2;
var _class$22;
_dec$2 = resourceLoader(AssetType.JSON, ["json"], false), _dec$2(_class$22 = function(_Loader) {
  _inheritsLoose2(JSONLoader, _Loader);
  function JSONLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = JSONLoader.prototype;
  _proto.load = function load(item) {
    return this.request(item.url, _objectSpread22(_objectSpread22({}, item), {}, {
      type: "json"
    }));
  };
  return JSONLoader;
}(Loader)) || _class$22;
var HEADER_LEN = 12 + 13 * 4;
var COMPRESSED_2D = 0;
function getMipmaps(ktxContainer, loadMipmaps) {
  var mipmaps = [];
  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
  var width = ktxContainer.pixelWidth;
  var height = ktxContainer.pixelHeight;
  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
  for (var level = 0; level < mipmapCount; level++) {
    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];
    dataOffset += 4;
    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
      mipmaps.push({
        data: byteArray,
        width,
        height
      });
      dataOffset += imageSize;
      dataOffset += 3 - (imageSize + 3) % 4;
    }
    width = Math.max(1, width * 0.5);
    height = Math.max(1, height * 0.5);
  }
  return mipmaps;
}
function isValid(data) {
  if (data.byteLength >= 12) {
    var identifier = new Uint8Array(data, 0, 12);
    if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
      return true;
    }
  }
  return false;
}
function getEngineFormat(internalFormat) {
  switch (internalFormat) {
    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
      return TextureFormat.DXT1;
    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
      return TextureFormat.DXT5;
    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
      return TextureFormat.ETC1_RGB;
    case GLCompressedTextureInternalFormat.RGB8_ETC2:
      return TextureFormat.ETC2_RGB;
    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return TextureFormat.ETC2_RGBA5;
    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
      return TextureFormat.ETC2_RGBA8;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGB2;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA2;
    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGB4;
    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
      return TextureFormat.PVRTC_RGBA4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
      return TextureFormat.ASTC_4x4;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
      return TextureFormat.ASTC_5x5;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
      return TextureFormat.ASTC_6x6;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
      return TextureFormat.ASTC_8x8;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
      return TextureFormat.ASTC_10x10;
    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
      return TextureFormat.ASTC_12x12;
    default:
      var formatName = GLCompressedTextureInternalFormat[internalFormat];
      throw new Error("this format is not supported in Oasis Engine: " + formatName);
  }
}
var khronosTextureContainerParser = {
  parse: function parse2(buffer, facesExpected, withMipmaps, mapEngineFormat) {
    if (mapEngineFormat === void 0) {
      mapEngineFormat = false;
    }
    if (!isValid(buffer)) {
      throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
    }
    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(buffer, 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 67305985;
    var parsedResult = {
      buffer,
      glType: headerDataView.getUint32(1 * dataSize, littleEndian),
      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
      loadType: COMPRESSED_2D
    };
    if (parsedResult.glType !== 0) {
      throw new Error("only compressed formats currently supported");
    } else {
      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
    }
    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
      throw new Error("only 2D textures currently supported");
    }
    if (parsedResult.numberOfArrayElements !== 0) {
      throw new Error("texture arrays not currently supported");
    }
    if (parsedResult.numberOfFaces !== facesExpected) {
      throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
    }
    if (withMipmaps) {
      parsedResult.mipmaps = getMipmaps(parsedResult, true);
    }
    if (mapEngineFormat) {
      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
    }
    return parsedResult;
  }
};
function parseSingleKTX(data) {
  var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
  return {
    mipmaps: ktx.mipmaps,
    engineFormat: ktx.engineFormat,
    internalFormat: ktx.glInternalFormat,
    width: ktx.pixelWidth,
    height: ktx.pixelHeight
  };
}
function parseCubeKTX(dataArray) {
  var mipmapsFaces = [];
  var internalFormat;
  var engineFormat;
  var width;
  var height;
  for (var i = 0; i < dataArray.length; i++) {
    var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
    mipmapsFaces.push(ktx.mipmaps);
    if (i === 0) {
      width = ktx.pixelWidth;
      height = ktx.pixelHeight;
      internalFormat = ktx.glInternalFormat;
      engineFormat = ktx.engineFormat;
    }
  }
  return {
    mipmapsFaces,
    engineFormat,
    internalFormat,
    width,
    height
  };
}
var _dec$3;
var _class$32;
_dec$3 = resourceLoader(AssetType.KTXCube, []), _dec$3(_class$32 = function(_Loader) {
  _inheritsLoose2(KTXCubeLoader, _Loader);
  function KTXCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = KTXCubeLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(item.urls.map(function(url) {
        return _this.request(url, _objectSpread22(_objectSpread22({}, item), {}, {
          type: "arraybuffer"
        }));
      })).then(function(data) {
        var parsedData = parseCubeKTX(data);
        var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
        var mipmap = mipmapsFaces[0].length > 1;
        var texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);
        for (var face = 0; face < 6; face++) {
          var length = mipmapsFaces[face].length;
          for (var miplevel = 0; miplevel < length; miplevel++) {
            var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel], _data = _mipmapsFaces$face$mi.data, _width = _mipmapsFaces$face$mi.width, height = _mipmapsFaces$face$mi.height;
            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _data, miplevel, 0, 0, _width, height);
          }
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return KTXCubeLoader;
}(Loader)) || _class$32;
var _dec$4;
var _class$42;
_dec$4 = resourceLoader(AssetType.KTX, ["ktx"]), _dec$4(_class$42 = function(_Loader) {
  _inheritsLoose2(KTXLoader, _Loader);
  function KTXLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = KTXLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _objectSpread22(_objectSpread22({}, item), {}, {
        type: "arraybuffer"
      })).then(function(bin) {
        var parsedData = parseSingleKTX(bin);
        var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
        var mipmap = mipmaps.length > 1;
        var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
        for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
          var _mipmaps$miplevel = mipmaps[miplevel], _width = _mipmaps$miplevel.width, _height = _mipmaps$miplevel.height, data = _mipmaps$miplevel.data;
          texture.setPixelBuffer(data, miplevel, 0, 0, _width, _height);
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return KTXLoader;
}(Loader)) || _class$42;
var _dec$5;
var _class$52;
_dec$5 = resourceLoader(AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"]), _dec$5(_class$52 = function(_Loader) {
  _inheritsLoose2(Texture2DLoader, _Loader);
  function Texture2DLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = Texture2DLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      _this.request(item.url, _objectSpread22(_objectSpread22({}, item), {}, {
        type: "image"
      })).then(function(image) {
        var texture = new Texture2D(resourceManager.engine, image.width, image.height);
        if (!texture._glTexture)
          return;
        texture.setImageSource(image);
        texture.generateMipmaps();
        if (item.url.indexOf("data:") !== 0) {
          var splitPath = item.url.split("/");
          texture.name = splitPath[splitPath.length - 1];
        }
        resolve(texture);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return Texture2DLoader;
}(Loader)) || _class$52;
var _dec$6;
var _class$62;
_dec$6 = resourceLoader(AssetType.TextureCube, [""]), _dec$6(_class$62 = function(_Loader) {
  _inheritsLoose2(TextureCubeLoader, _Loader);
  function TextureCubeLoader() {
    return _Loader.apply(this, arguments) || this;
  }
  var _proto = TextureCubeLoader.prototype;
  _proto.load = function load(item, resourceManager) {
    var _this = this;
    return new AssetPromise(function(resolve, reject) {
      Promise.all(item.urls.map(function(url) {
        return _this.request(url, _objectSpread22(_objectSpread22({}, item), {}, {
          type: "image"
        }));
      })).then(function(images) {
        var _images$ = images[0], width = _images$.width, height = _images$.height;
        if (width !== height) {
          console.error("The cube texture must have the same width and height");
          return;
        }
        var tex = new TextureCubeMap(resourceManager.engine, width);
        if (!tex._glTexture)
          return;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
        }
        tex.generateMipmaps();
        resolve(tex);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  return TextureCubeLoader;
}(Loader)) || _class$62;
var GLTFModel = function(_Component) {
  _inheritsLoose2(GLTFModel2, _Component);
  function GLTFModel2(entity) {
    var _this;
    _this = _Component.call(this, entity) || this;
    _this._animator = void 0;
    _this.animationsNames = void 0;
    _this._asset = void 0;
    _this.GLTFNode = void 0;
    _this._loop = void 0;
    _this._autoPlay = void 0;
    _this._hasBuiltNode = false;
    return _this;
  }
  var _proto = GLTFModel2.prototype;
  _proto.init = function init2(props) {
    var _props$asset = props.asset, asset = _props$asset === void 0 ? null : _props$asset, autoPlay = props.autoPlay, loop = props.loop, isClone = props.isClone;
    if (isClone) {
      var rootName = props.gltfRootName;
      if (rootName) {
        this.GLTFNode = this.entity.findByName(rootName);
      }
    }
    if (!this.GLTFNode) {
      var _rootName = "GLTF-" + Date.now();
      props.gltfRootName = _rootName;
      this.GLTFNode = this.entity.createChild(_rootName);
      this._hasBuiltNode = false;
    } else {
      this._hasBuiltNode = true;
    }
    this.asset = asset;
    this.loop = loop;
    this.autoPlay = autoPlay;
  };
  _proto._onEnable = function _onEnable() {
    this.GLTFNode && (this.GLTFNode.isActive = true);
  };
  _proto._onDisable = function _onDisable() {
    this.GLTFNode && (this.GLTFNode.isActive = false);
  };
  _createClass3(GLTFModel2, [{
    key: "asset",
    get: function get4() {
      return this._asset;
    },
    set: function set4(value) {
      if (value && value.defaultSceneRoot === this.GLTFNode) {
        return;
      }
      if (!this._hasBuiltNode) {
        this.GLTFNode.clearChildren();
        if (value !== null) {
          if (this.GLTFNode) {
            this.GLTFNode.destroy();
          }
          this.GLTFNode = value.defaultSceneRoot.clone();
          this._animator = this.GLTFNode.getComponent(Animation);
          this.entity.addChild(this.GLTFNode);
        }
      }
      this._asset = value;
    }
  }, {
    key: "animator",
    get: function get4() {
      return this._animator;
    }
  }, {
    key: "autoPlay",
    get: function get4() {
      return this._autoPlay;
    },
    set: function set4(value) {
      if (this._animator) {
        if (value) {
          this._animator.playAnimationClip(value, {
            wrapMode: this._loop
          });
        } else {
          this._animator.stop(false);
        }
      }
      this._autoPlay = value;
    }
  }, {
    key: "loop",
    get: function get4() {
      return this._loop;
    },
    set: function set4(value) {
      if (this._animator && this.autoPlay) {
        this._animator.playAnimationClip(this._autoPlay, {
          wrapMode: value
        });
      }
      this._loop = value;
    }
  }]);
  return GLTFModel2;
}(Component);
var PluginManager = function() {
  function PluginManager2() {
    this.registeredPlugins = new Set();
    this.plugins = [];
  }
  var _proto = PluginManager2.prototype;
  _proto.register = function register(plugin) {
    this.registeredPlugins.add(plugin);
  };
  _proto.boot = function boot(oasis) {
    for (var _iterator = _createForOfIteratorHelperLoose2(this.registeredPlugins.values()), _step; !(_step = _iterator()).done; ) {
      var plugin = _step.value;
      if (typeof plugin === "function") {
        plugin = plugin(oasis);
      }
      this.plugins.push(plugin);
    }
  };
  _proto.reset = function reset() {
    this.registeredPlugins.clear();
    this.plugins = [];
  };
  _proto.nodeAdded = function nodeAdded(entity) {
    this.delegateMethod("nodeAdded", entity);
  };
  _proto.delegateMethod = function delegateMethod(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    this.plugins.forEach(function(plugin) {
      return plugin[name] && plugin[name].apply(plugin, args);
    });
  };
  return PluginManager2;
}();
function pluginHook(options) {
  return function(target, propertyName, descriptor) {
    var method = descriptor.value;
    descriptor.value = function() {
      var _this$oasis$pluginMan, _this = this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      options.before && (_this$oasis$pluginMan = this.oasis.pluginManager).delegateMethod.apply(_this$oasis$pluginMan, [options.before].concat(args));
      return Promise.resolve(method.apply(this, arguments)).then(function(returnObj) {
        options.after && _this.oasis.pluginManager.delegateMethod(options.after, returnObj);
        return returnObj;
      });
    };
  };
}
function switchElementsIndex(elements, currentIndex, targetIndex) {
  if (currentIndex === targetIndex || targetIndex === null || targetIndex === void 0) {
    return;
  }
  var _ref = [elements[targetIndex], elements[currentIndex]];
  elements[currentIndex] = _ref[0];
  elements[targetIndex] = _ref[1];
}
function isAsset(config) {
  return config && config.type === "asset";
}
function getAllGetters(obj) {
  var result = [];
  var prototype = Object.getPrototypeOf(obj);
  var prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);
  for (var _i = 0, _Object$entries = Object.entries(prototype_property_descriptors); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i], property = _Object$entries$_i[0], descriptor = _Object$entries$_i[1];
    if (typeof descriptor.get === "function") {
      result.push(property);
    }
  }
  return result;
}
var SchemaResource = function() {
  var _proto = SchemaResource2.prototype;
  _proto.setMeta = function setMeta() {
  };
  function SchemaResource2(resourceManager, _resource) {
    this.resourceManager = resourceManager;
    this._resource = _resource;
    this._meta = {};
    this._attachedResources = [];
    this.setMeta();
  }
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceLoader2, assetConfig, oasis) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.load(resourceLoader2, assetConfig, oasis).then(function() {
        resolve({
          resources: [_this],
          structure: {
            index: 0,
            props: {}
          }
        });
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto.getProps = function getProps() {
    return {};
  };
  _proto.bind = function bind() {
  };
  _proto.attach = function attach() {
  };
  _proto.update = function update(key, value) {
    if (isAsset(value)) {
      var resource = this.resourceManager.get(value.id);
      if (resource) {
        this._resource[key] = resource.resource;
      } else {
        Logger.warn("SchemaResource: " + this.meta.name + " can't find asset, which id is: " + value.id);
      }
    } else {
      this._resource[key] = value;
    }
  };
  _proto.updateMeta = function updateMeta(key, value) {
    this._meta[key] = value;
  };
  _proto.onDestroy = function onDestroy() {
  };
  _createClass3(SchemaResource2, [{
    key: "resource",
    get: function get4() {
      return this._resource;
    }
  }, {
    key: "meta",
    get: function get4() {
      return this._meta;
    }
  }, {
    key: "attachedResources",
    get: function get4() {
      return this._attachedResources;
    }
  }]);
  return SchemaResource2;
}();
var TextureResource = function(_SchemaResource) {
  _inheritsLoose2(TextureResource2, _SchemaResource);
  function TextureResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = TextureResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var _assetConfig$props, _assetConfig$props$co, _url;
      var url;
      var assetType = AssetType.Texture2D;
      if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
        var rhi = oasis.engine._hardwareRenderer;
        var compressions = assetConfig.props.compression.compressions;
        for (var i = 0; i < compressions.length; i++) {
          var compression = compressions[i];
          if (compression.container === "ktx" && rhi.canIUse(GLCapabilityType[compression.type])) {
            url = compression.url;
            assetType = AssetType.KTX;
            break;
          }
        }
      }
      url = (_url = url) != null ? _url : assetConfig.url;
      resourceManager.load({
        url,
        type: assetType
      }).then(function(res) {
        _this._resource = res;
        resolve(_this);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this._meta.name = this.resource.name;
      if (this.resource.image) {
        this._meta.url = this.resource.image.src;
      }
    }
  };
  return TextureResource2;
}(SchemaResource);
var BlinnPhongMaterialResource = function(_SchemaResource) {
  _inheritsLoose2(BlinnPhongMaterialResource2, _SchemaResource);
  function BlinnPhongMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = BlinnPhongMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new BlinnPhongMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      _this2._resource = assetObj;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof BlinnPhongMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load BlinnPhongMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.bind = function bind() {
    var _this4 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this4.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this4.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this4._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("BlinnPhongMaterialResource: " + _this4.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return BlinnPhongMaterialResource2;
}(SchemaResource);
var PBRMaterialResource = function(_SchemaResource) {
  _inheritsLoose2(PBRMaterialResource2, _SchemaResource);
  function PBRMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = PBRMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new PBRMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2._resource = assetObj;
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof PBRMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("PBRMaterialResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return PBRMaterialResource2;
}(SchemaResource);
var PBRSpecularMaterialResource = function(_SchemaResource) {
  _inheritsLoose2(PBRSpecularMaterialResource2, _SchemaResource);
  function PBRSpecularMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = PBRSpecularMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new PBRSpecularMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      _this2._resource = assetObj;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof PBRSpecularMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRSpecularMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("PBRSpecularMaterialResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return PBRSpecularMaterialResource2;
}(SchemaResource);
var UnlitMaterialResource = function(_SchemaResource) {
  _inheritsLoose2(UnlitMaterialResource2, _SchemaResource);
  function UnlitMaterialResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.configProps = void 0;
    return _this;
  }
  var _proto = UnlitMaterialResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig) {
    var _this2 = this;
    return new Promise(function(resolve) {
      var assetObj = new UnlitMaterial(resourceManager.engine);
      _this2.configProps = assetConfig.props;
      for (var k in _this2.configProps) {
        if (!isAsset(_this2.configProps[k])) {
          assetObj[k] = _this2.configProps[k];
        }
      }
      _this2._resource = assetObj;
      _this2.setMeta();
      resolve(_this2);
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig) {
    var _this3 = this;
    return new Promise(function(resolve, reject) {
      var loadPromise;
      if (assetConfig.resource instanceof UnlitMaterial) {
        loadPromise = new Promise(function(resolve2) {
          _this3._resource = assetConfig.resource;
          _this3.setMeta();
          resolve2(_this3);
        });
      } else if (assetConfig.props) {
        loadPromise = _this3.load(resourceManager, assetConfig);
      } else {
        reject("Load PBRMaterial Error");
      }
      if (loadPromise) {
        loadPromise.then(function() {
          var result = {
            resources: [_this3],
            structure: {
              index: 0,
              props: {}
            }
          };
          var material = _this3._resource;
          getAllGetters(_this3._resource).forEach(function(attr) {
            if (!(material[attr] instanceof Texture))
              return;
            var textureResource = new TextureResource(_this3.resourceManager, material[attr]);
            _this3.attachedResources.push(textureResource);
            result.resources.push(textureResource);
            result.structure.props[attr] = {
              index: result.resources.length - 1
            };
          });
          resolve(result);
        });
      }
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  _proto.getProps = function getProps() {
    var _this4 = this;
    var result = {};
    var props = getAllGetters(this.resource);
    props.forEach(function(prop) {
      return result[prop] = _this4.resource[prop];
    });
    return result;
  };
  _proto.bind = function bind() {
    var _this5 = this;
    var resource = this._resource;
    Object.keys(this.configProps).forEach(function(attr) {
      var value = _this5.configProps[attr];
      if (isAsset(value)) {
        var textureResource = _this5.resourceManager.get(value.id);
        if (textureResource && textureResource instanceof TextureResource) {
          resource[attr] = textureResource.resource;
          _this5._attachedResources.push(textureResource);
        } else {
          resource[attr] = null;
          Logger.warn("PBRMaterialResource: " + _this5.meta.name + ` can't find asset "` + attr + '", which id is: ' + value.id);
        }
      } else {
        resource[attr] = value;
      }
    });
  };
  return UnlitMaterialResource2;
}(SchemaResource);
var GLTFResource$1 = function(_SchemaResource) {
  _inheritsLoose2(GLTFResource2, _SchemaResource);
  function GLTFResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = GLTFResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _assetConfig$props, _this = this;
    if (!!((_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && _assetConfig$props.compression)) {
      glTFDracoMeshCompression.init();
    }
    return resourceManager.load({
      url: assetConfig.url,
      type: AssetType.Perfab
    }).then(function(res) {
      var gltf = res;
      if (assetConfig.props) {
        gltf.newMaterial = assetConfig.props.newMaterial;
      }
      _this._resource = gltf;
    });
  };
  _proto.loadWithAttachedResources = function loadWithAttachedResources(resourceManager, assetConfig, oasis) {
    var _this2 = this;
    return new Promise(function(resolve) {
      _this2.load(resourceManager, assetConfig, oasis).then(function() {
        var gltf = _this2.resource;
        var materials = gltf.materials;
        var loadPromises = [];
        var result = {
          resources: [_this2],
          structure: {
            index: 0,
            props: {
              newMaterial: []
            }
          }
        };
        for (var i = 0; i < materials.length; i++) {
          var material = materials[i];
          var materialResource = null;
          var type = "";
          if (material instanceof PBRMaterial) {
            materialResource = new PBRMaterialResource(_this2.resourceManager);
            type = "PBRMaterial";
          } else if (material instanceof UnlitMaterial) {
            materialResource = new UnlitMaterialResource(_this2.resourceManager);
            type = "UnlitMaterial";
          } else if (material instanceof PBRSpecularMaterial) {
            materialResource = new PBRSpecularMaterialResource(_this2.resourceManager);
            type = "PBRSpecularMaterial";
          } else {
            materialResource = new BlinnPhongMaterialResource(_this2.resourceManager);
            type = "BlinnPhongMaterial";
          }
          _this2._attachedResources.push(materialResource);
          loadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {
            type,
            name: material.name,
            resource: material
          }));
        }
        Promise.all(loadPromises).then(function(res) {
          var newMaterial = result.structure.props.newMaterial;
          res.forEach(function(mat) {
            var matStructure = mat.structure;
            var matResource = mat.resources[matStructure.index];
            result.resources.push(matResource);
            matStructure.index = result.resources.length - 1;
            for (var key in matStructure.props) {
              if (matStructure.props.hasOwnProperty(key)) {
                var textureStructure = matStructure.props[key];
                var textureResource = mat.resources[textureStructure.index];
                result.resources.push(textureResource);
                textureStructure.index = result.resources.length - 1;
              }
            }
            newMaterial.push(matStructure);
          });
          resolve(result);
        });
      });
    });
  };
  _proto.setMeta = function setMeta(assetConfig) {
    if (assetConfig) {
      this.meta.name = assetConfig.name;
    }
  };
  _proto.bind = function bind() {
    var resource = this._resource;
    this.bindMaterials(resource.newMaterial);
  };
  _proto.update = function update(key, value) {
    if (key === "newMaterial") {
      this.bindMaterials(value);
    } else {
      this._resource[key] = value;
    }
  };
  _proto.bindMaterials = function bindMaterials(materials) {
    if (!materials || !materials.length) {
      return;
    }
    var gltf = this._resource;
    var meshes = gltf.meshes;
    for (var i = 0; i < materials.length; i++) {
      var mtlResource = this.resourceManager.get(materials[i].id);
      if (mtlResource) {
        this._attachedResources.push(mtlResource);
        gltf.materials[i] = mtlResource.resource;
      } else {
        Logger.warn("GLTFResource: " + this.meta.name + ` can't find asset "material", which id is: ` + materials[i].id);
      }
    }
    for (var j = 0; j < meshes.length; j++) {
      var node = this.getNodeByMeshIndex(gltf.nodes, meshes.length - 1 - j);
      if (node) {
        for (var k = 0; k < meshes[j].primitives.length; k++) {
          var primitive = meshes[j].primitives[k];
          var meshRenderer = node.getComponent(MeshRenderer);
          var material = gltf.materials[gltf.materials.length - 1 - primitive.materialIndex];
          if (meshRenderer && material && material instanceof Material) {
            meshRenderer.setSharedMaterial(k, material);
          }
        }
      }
    }
  };
  _proto.getNodeByMeshIndex = function getNodeByMeshIndex(nodes, index) {
    for (var i = 0; i <= nodes.length; i++) {
      var node = nodes[i];
      if (node.meshIndex === index) {
        return node;
      }
    }
    return null;
  };
  return GLTFResource2;
}(SchemaResource);
var scriptAbility = {};
function script(name) {
  return function(target) {
    scriptAbility[name] = target;
  };
}
var ScriptResource = function(_SchemaResource) {
  _inheritsLoose2(ScriptResource2, _SchemaResource);
  function ScriptResource2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _SchemaResource.call.apply(_SchemaResource, [this].concat(args)) || this;
    _this.isInit = false;
    return _this;
  }
  var _proto = ScriptResource2.prototype;
  _proto.initScriptContext = function initScriptContext() {
    if (this.isInit) {
      return;
    }
    this.isInit = true;
    window.__o3_script_context__ = {
      o3: Parser._components["o3"],
      script: function script2(name) {
        return function(target) {
          scriptAbility[name] = target;
        };
      }
    };
  };
  _proto.load = function load(resourceLoader2, assetConfig, oasis) {
    var _this2 = this;
    this.initScriptContext();
    return new Promise(function(resolve) {
      var config = assetConfig;
      var scripts = config.props.scripts;
      if (!_this2.resourceManager.isLocal) {
        var scriptDom = document.createElement("script");
        scriptDom.crossOrigin = "anonymous";
        _this2.setMeta(assetConfig);
        scriptDom.onload = function() {
          var o3Scripts = window.o3Scripts;
          for (var i2 = 0; i2 < scripts.length; i2++) {
            var name2 = scripts[i2].name;
            _this2._resource = o3Scripts && o3Scripts[name2];
            scriptAbility[name2] = _this2._resource;
          }
          resolve(_this2);
        };
        scriptDom.src = assetConfig.url;
        document.body.appendChild(scriptDom);
      } else {
        for (var i = 0; i < scripts.length; i++) {
          var _oasis$options;
          var name = scripts[i].name;
          scriptAbility[name] = (_oasis$options = oasis.options) === null || _oasis$options === void 0 ? void 0 : _oasis$options.scripts[name];
        }
        resolve(_this2);
      }
    });
  };
  _proto.setMeta = function setMeta(assetConfig) {
    if (assetConfig) {
      this._meta.name = assetConfig.name;
      this._meta.url = assetConfig.url;
      this._meta.source = assetConfig.source;
    }
  };
  return ScriptResource2;
}(SchemaResource);
var imageOrderMap = {
  px: 0,
  nx: 1,
  py: 2,
  ny: 3,
  pz: 4,
  nz: 5
};
var TextureCubeMapResource = function(_SchemaResource) {
  _inheritsLoose2(TextureCubeMapResource2, _SchemaResource);
  function TextureCubeMapResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = TextureCubeMapResource2.prototype;
  _proto.load = function load(resourceManager, assetConfig, oasis) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var _assetConfig$props, _assetConfig$props$co;
      var imageUrls = [];
      var type = AssetType.TextureCube;
      if (_this.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
        var rhi = oasis.engine._hardwareRenderer;
        var compressions = assetConfig.props.compression.compressions;
        for (var i = 0; i < compressions.length; i++) {
          var compression = compressions[i];
          if (compression.container === "ktx" && rhi.canIUse(GLCapabilityType[compression.type])) {
            for (var key in compression.files) {
              if (compression.files.hasOwnProperty(key)) {
                var image = compression.files[key];
                imageUrls[imageOrderMap[key]] = image.url;
              }
            }
            console.warn(compression.type);
            type = AssetType.KTXCube;
            break;
          }
        }
      }
      if (type === AssetType.TextureCube) {
        for (var _key in assetConfig.props.images) {
          if (assetConfig.props.images.hasOwnProperty(_key)) {
            var _image = assetConfig.props.images[_key];
            imageUrls[imageOrderMap[_key]] = _image.url;
          }
        }
      }
      resourceManager.load({
        urls: imageUrls,
        type
      }).then(function(res) {
        _this._resource = res;
        resolve(_this);
      }).catch(function(e) {
        reject(e);
      });
    });
  };
  _proto.setMeta = function setMeta() {
    if (this.resource) {
      this.meta.name = this.resource.name;
    }
  };
  return TextureCubeMapResource2;
}(SchemaResource);
var BaseResource = function(_SchemaResource) {
  _inheritsLoose2(BaseResource2, _SchemaResource);
  function BaseResource2() {
    return _SchemaResource.apply(this, arguments) || this;
  }
  var _proto = BaseResource2.prototype;
  _proto.load = function load(resourceLoader2, assetConfig) {
    var _this = this;
    return new Promise(function(resolve) {
      _this._resource = assetConfig;
      _this.setMetaData("name", _this.resource.name);
      _this.setMetaData("url", _this.resource.url);
      resolve(_this);
    });
  };
  _proto.setMetaData = function setMetaData(key, value) {
    this._meta[key] = value;
  };
  return BaseResource2;
}(SchemaResource);
var _dec$7;
var _dec22;
var _dec3;
var _class$72;
var _temp$12;
var AbilityManager = (_dec$7 = pluginHook({
  after: "abilityAdded",
  before: "beforeAbilityAdded"
}), _dec22 = pluginHook({
  before: "beforeAbilityUpdated",
  after: "abilityUpdated"
}), _dec3 = pluginHook({
  after: "abilityDeleted",
  before: "beforeAbilityDeleted"
}), _class$72 = (_temp$12 = function() {
  function AbilityManager2(oasis) {
    this.oasis = oasis;
    this.abilityMap = {};
  }
  var _proto = AbilityManager2.prototype;
  _proto.add = function add(abilityConfig) {
    var type = abilityConfig.type, nodeId = abilityConfig.node, props = abilityConfig.props, id = abilityConfig.id, index = abilityConfig.index;
    var node = this.oasis.nodeManager.get(nodeId);
    var AbilityConstructor = this.getCompConstructor(type);
    if (!AbilityConstructor) {
      Logger.error(type + " abiltiy is not defined");
      return;
    }
    var abilityProps = this.mixPropsToExplicitProps(props);
    var ability = node.addComponent(AbilityConstructor);
    var enabled = abilityProps.enabled;
    if (enabled !== void 0) {
      ability.enabled = enabled;
    }
    if (type === "Model" || type === "GLTFModel") {
      ability.init(abilityProps);
    } else {
      for (var k in abilityProps) {
        if (abilityProps[k] !== null) {
          ability[k] = abilityProps[k];
        }
      }
    }
    var abilityArray = node._components;
    var currentIndex = abilityArray.length - 1;
    switchElementsIndex(abilityArray, currentIndex, index);
    ability.id = id;
    this.abilityMap[id] = ability;
    return ability;
  };
  _proto.update = function update(id, key, value) {
    if (this.get(id).constructor.name === "Model") {
      if (value && this.checkIsAsset(value)) {
        this.get(id).setProp(key, this.oasis.resourceManager.get(value.id).resource);
      } else {
        this.get(id).setProp(key, value);
      }
    } else {
      if (value && this.checkIsAsset(value)) {
        this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;
      } else {
        this.get(id)[key] = value;
      }
    }
    return {
      id,
      key,
      value
    };
  };
  _proto.get = function get4(id) {
    return this.abilityMap[id];
  };
  _proto.delete = function _delete(id) {
    var ability = this.abilityMap[id];
    ability.destroy();
    delete this.abilityMap[id];
    return id;
  };
  _proto.getCompConstructor = function getCompConstructor(type) {
    var splits = type.split(".");
    if (splits[0] === "script") {
      return scriptAbility[splits[1]];
    }
    var constructor = Parser._components["o3"][type];
    if (!constructor) {
      throw new Error(type + " is not defined");
    }
    return constructor;
  };
  _proto.mixPropsToExplicitProps = function mixPropsToExplicitProps(props) {
    var explicitProps = _objectSpread22({}, props);
    for (var k in props) {
      var prop = props[k];
      if (prop && this.checkIsAsset(prop)) {
        var res = this.oasis.resourceManager.get(prop.id);
        if (res) {
          explicitProps[k] = res.resource;
        } else {
          explicitProps[k] = null;
          Logger.warn(`AbilityManager: can't get asset "` + k + '", which id is ' + prop.id);
        }
      }
    }
    return explicitProps;
  };
  _proto.checkIsAsset = function checkIsAsset(prop) {
    return prop.type === "asset";
  };
  return AbilityManager2;
}(), _temp$12), _applyDecoratedDescriptor2(_class$72.prototype, "add", [_dec$7], Object.getOwnPropertyDescriptor(_class$72.prototype, "add"), _class$72.prototype), _applyDecoratedDescriptor2(_class$72.prototype, "update", [_dec22], Object.getOwnPropertyDescriptor(_class$72.prototype, "update"), _class$72.prototype), _applyDecoratedDescriptor2(_class$72.prototype, "delete", [_dec3], Object.getOwnPropertyDescriptor(_class$72.prototype, "delete"), _class$72.prototype), _class$72);
var _dec$8;
var _dec2$1;
var _dec3$1;
var _class$82;
var _temp$22;
var NodeManager = (_dec$8 = pluginHook({
  after: "nodeAdded"
}), _dec2$1 = pluginHook({
  before: "beforeNodeUpdated",
  after: "nodeUpdated"
}), _dec3$1 = pluginHook({
  before: "beforeNodeDeleted"
}), _class$82 = (_temp$22 = function() {
  function NodeManager2(oasis) {
    this.oasis = oasis;
    this.nodeMap = {};
    this.root = void 0;
    this.root = new Entity(this.oasis.engine, "root");
  }
  var _proto = NodeManager2.prototype;
  _proto.addRootEntity = function addRootEntity() {
    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);
  };
  _proto.add = function add(nodeConfig) {
    this.create(nodeConfig);
    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);
    return this.get(nodeConfig.id);
  };
  _proto.update = function update(id, key, value) {
    this.get(id)[key] = value;
    return {
      id,
      key,
      value
    };
  };
  _proto.get = function get4(id) {
    return this.nodeMap[id];
  };
  _proto.reset = function reset() {
    this.nodeMap = {};
  };
  _proto.delete = function _delete(id) {
    this.nodeMap[id].destroy();
    delete this.nodeMap[id];
  };
  _proto.create = function create(nodeConfig) {
    var isActive = nodeConfig.isActive, position = nodeConfig.position, rotation = nodeConfig.rotation, scale = nodeConfig.scale, id = nodeConfig.id, name = nodeConfig.name;
    var entity = new Entity(this.oasis.engine, name);
    entity.isActive = isActive;
    entity.transform.position = new Vector3(position[0], position[1], position[2]);
    entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);
    entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);
    entity.id = id;
    this.nodeMap[id] = entity;
    return entity;
  };
  _proto.append = function append(childId, parentId, index) {
    var child = this.nodeMap[childId];
    var parent = this.nodeMap[parentId] || this.root;
    parent.addChild(child);
    var children = parent._children;
    var currentIndex = children.length - 1;
    switchElementsIndex(children, currentIndex, index);
  };
  return NodeManager2;
}(), _temp$22), _applyDecoratedDescriptor2(_class$82.prototype, "add", [_dec$8], Object.getOwnPropertyDescriptor(_class$82.prototype, "add"), _class$82.prototype), _applyDecoratedDescriptor2(_class$82.prototype, "update", [_dec2$1], Object.getOwnPropertyDescriptor(_class$82.prototype, "update"), _class$82.prototype), _applyDecoratedDescriptor2(_class$82.prototype, "delete", [_dec3$1], Object.getOwnPropertyDescriptor(_class$82.prototype, "delete"), _class$82.prototype), _class$82);
var _dec$9;
var _dec2$2;
var _class$92;
var _temp$32;
var RESOURCE_CLASS = {
  script: ScriptResource,
  gltf: GLTFResource$1,
  texture: TextureResource,
  cubeTexture: TextureCubeMapResource,
  PBRMaterial: PBRMaterialResource,
  PBRSpecularMaterial: PBRSpecularMaterialResource,
  UnlitMaterial: UnlitMaterialResource,
  BlinnPhongMaterial: BlinnPhongMaterialResource,
  base: BaseResource
};
var RESOURCE_TYPE = new Map();
for (var key in RESOURCE_CLASS) {
  if (RESOURCE_CLASS.hasOwnProperty(key)) {
    element = RESOURCE_CLASS[key];
    RESOURCE_TYPE.set(element, key);
  }
}
var element;
var resourceFactory = {
  createResource: function createResource(resourceManager, type) {
    return new RESOURCE_CLASS[type](resourceManager);
  }
};
function registerResource(type, resource) {
  if (!RESOURCE_CLASS.hasOwnProperty(type)) {
    RESOURCE_CLASS[type] = resource;
    RESOURCE_TYPE.set(resource, type);
  }
}
var SchemaResourceManager = (_dec$9 = pluginHook({
  before: "beforeResourceRemove"
}), _dec2$2 = pluginHook({
  after: "resourceUpdated",
  before: "beforeResourceUpdate"
}), _class$92 = (_temp$32 = function() {
  function SchemaResourceManager2(oasis) {
    this.oasis = oasis;
    this.resourceMap = {};
    this.resourceIdMap = new WeakMap();
    this.maxId = 0;
    this.engineResourceManager = void 0;
    this.engineResourceManager = this.oasis.engine.resourceManager;
  }
  var _proto = SchemaResourceManager2.prototype;
  _proto.load = function load(asset) {
    var _this = this;
    var resource = resourceFactory.createResource(this, asset.type);
    var loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);
    this.maxId = Math.max(+asset.id, this.maxId);
    loadPromise.then(function() {
      _this.resourceMap[asset.id] = resource;
      _this.resourceIdMap.set(resource, asset.id);
    });
    return loadPromise;
  };
  _proto.add = function add(asset) {
    var _this2 = this;
    var resource = resourceFactory.createResource(this, asset.type);
    return new Promise(function(resolve) {
      resource.loadWithAttachedResources(_this2.oasis.engine.resourceManager, asset, _this2.oasis).then(function(result) {
        resolve(_this2.getAddResourceResult(result.resources, result.structure));
      });
    });
  };
  _proto.remove = function remove(id) {
    var _this3 = this;
    return new Promise(function(resolve) {
      var resource = _this3.resourceMap[id];
      var result = [id];
      var hasAttachedResource = false;
      delete _this3.resourceMap[id];
      if (resource) {
        var attached = resource.attachedResources;
        for (var index = 0; index < attached.length; index++) {
          var attachedResource = attached[index];
          var attachedResourceId = _this3.resourceIdMap.get(attachedResource);
          if (attachedResourceId) {
            hasAttachedResource = true;
            _this3.remove(attachedResourceId).then(function(attachedResourceRemoveResult) {
              result.push.apply(result, attachedResourceRemoveResult);
              resolve(result);
            });
          }
        }
      }
      if (!hasAttachedResource) {
        resolve(result);
      }
    });
  };
  _proto.update = function update(id, key, value) {
    var resource = this.get(id);
    if (resource) {
      resource.update(key, value);
    }
    return {
      resource,
      id,
      key,
      value
    };
  };
  _proto.updateMeta = function updateMeta(id, key, value) {
    var resource = this.get(id);
    if (resource) {
      resource.updateMeta(key, value);
    }
  };
  _proto.get = function get4(id) {
    return this.resourceMap[id];
  };
  _proto.getAll = function getAll() {
    return ObjectValues(this.resourceMap);
  };
  _proto.getAddResourceResult = function getAddResourceResult(resources, structure) {
    var _this4 = this;
    var addResourceResult = {};
    var resource = resources[structure.index];
    var id = "" + ++this.maxId;
    this.resourceMap[id] = resource;
    this.resourceIdMap.set(resource, id);
    addResourceResult.id = this.maxId;
    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);
    addResourceResult.meta = resource.meta;
    addResourceResult.props = {};
    for (var _key in structure.props) {
      if (structure.props.hasOwnProperty(_key)) {
        var _element = structure.props[_key];
        if (_element) {
          if (Array.isArray(_element)) {
            addResourceResult.props[_key] = _element.map(function(child) {
              return _this4.getAddResourceResult(resources, child);
            });
          } else {
            addResourceResult.props[_key] = this.getAddResourceResult(resources, _element);
          }
        }
      }
    }
    return addResourceResult;
  };
  _createClass3(SchemaResourceManager2, [{
    key: "isLocal",
    get: function get4() {
      return this.oasis.options.local;
    }
  }, {
    key: "useCompressedTexture",
    get: function get4() {
      var _this$oasis$options$u;
      return (_this$oasis$options$u = this.oasis.options.useCompressedTexture) != null ? _this$oasis$options$u : true;
    }
  }]);
  return SchemaResourceManager2;
}(), _temp$32), _applyDecoratedDescriptor2(_class$92.prototype, "remove", [_dec$9], Object.getOwnPropertyDescriptor(_class$92.prototype, "remove"), _class$92.prototype), _applyDecoratedDescriptor2(_class$92.prototype, "update", [_dec2$2], Object.getOwnPropertyDescriptor(_class$92.prototype, "update"), _class$92.prototype), _class$92);
var _dec$a;
var _class$a;
var _temp$42;
var Oasis = (_dec$a = pluginHook({
  after: "schemaParsed"
}), _class$a = (_temp$42 = function(_EventDispatcher) {
  _inheritsLoose2(Oasis2, _EventDispatcher);
  function Oasis2(_options, pluginManager) {
    var _options$scripts;
    var _this;
    _this = _EventDispatcher.call(this, _options.engine) || this;
    _this._options = _options;
    _this.pluginManager = pluginManager;
    _this.engine = null;
    _this.nodeManager = void 0;
    _this.abilityManager = void 0;
    _this.resourceManager = void 0;
    _this._canvas = void 0;
    _this.schema = void 0;
    _this.timeout = void 0;
    _this.oasis = _assertThisInitialized2(_this);
    _this.engine = _options.engine;
    _this.schema = _options.config;
    _this.timeout = _options.timeout;
    _options.scripts = (_options$scripts = _options.scripts) != null ? _options$scripts : {};
    _this.nodeManager = new NodeManager(_assertThisInitialized2(_this));
    _this.abilityManager = new AbilityManager(_assertThisInitialized2(_this));
    _this.nodeManager.add = _this.nodeManager.add.bind(_this.nodeManager);
    _this.abilityManager.add = _this.abilityManager.add.bind(_this.abilityManager);
    _this.resourceManager = new SchemaResourceManager(_assertThisInitialized2(_this));
    if (_options.fps) {
      _this.engine.targetFrameRate = _options.fps;
      _this.engine.vSyncCount = 0;
    }
    return _this;
  }
  var _proto = Oasis2.prototype;
  _proto.updateConfig = function updateConfig(config) {
    this.schema = config;
    this.init();
  };
  _proto.init = function init2() {
    var _this2 = this;
    return this.loadResources().then(function() {
      _this2.bindResources();
      _this2.parseEntities();
      _this2.attach();
      _this2.nodeManager.addRootEntity();
      _this2.parseNodeAbilities();
      _this2.pluginManager.boot(_this2);
    });
  };
  _proto.loadResources = function loadResources() {
    var _this3 = this;
    var _this$schema$assets = this.schema.assets, assets = _this$schema$assets === void 0 ? {} : _this$schema$assets;
    var loadingPromises = ObjectValues(assets).filter(function(asset) {
      if (RESOURCE_CLASS[asset.type]) {
        return true;
      }
      console.warn(asset.type + " loader is not defined. the " + asset.type + " type will be ignored.");
      return false;
    }).map(function(asset) {
      return _this3.resourceManager.load(asset);
    });
    return Promise.all(loadingPromises);
  };
  _proto.bindResources = function bindResources() {
    this.resourceManager.getAll().forEach(function(resource) {
      resource.bind();
    });
  };
  _proto.parseEntities = function parseEntities() {
    var nodes = this.schema.nodes;
    var indices = this.bfsNodes();
    indices.map(function(index) {
      return nodes[index];
    }).forEach(this.nodeManager.add);
  };
  _proto.parseNodeAbilities = function parseNodeAbilities() {
    var abilities = this.schema.abilities;
    Object.keys(abilities).map(function(id) {
      return _objectSpread22({
        id
      }, abilities[id]);
    }).forEach(this.abilityManager.add);
  };
  _proto.bfsNodes = function bfsNodes() {
    var nodes = this.schema.nodes;
    var roots = ObjectValues(nodes).filter(function(node) {
      return !nodes[node.parent];
    }).map(function(node) {
      return node.id;
    });
    var result = [];
    var traverseChildren = function traverseChildren2(roots2) {
      result = result.concat(roots2);
      roots2.forEach(function(id) {
        var children = nodes[id].children;
        children && traverseChildren2(children);
      });
    };
    traverseChildren(roots);
    return result;
  };
  _proto.attach = function attach() {
    this.resourceManager.getAll().forEach(function(resource) {
      resource.attach();
    });
  };
  Oasis2.create = function create(options, pluginManager) {
    var oasis = new Oasis2(options, pluginManager);
    return oasis.init().then(function() {
      options.autoPlay && oasis.engine.run();
      return oasis;
    });
  };
  _createClass3(Oasis2, [{
    key: "canvas",
    get: function get4() {
      return this._options.canvas;
    }
  }, {
    key: "options",
    get: function get4() {
      return this._options;
    }
  }]);
  return Oasis2;
}(EventDispatcher), _temp$42), _applyDecoratedDescriptor2(_class$a.prototype, "init", [_dec$a], Object.getOwnPropertyDescriptor(_class$a.prototype, "init"), _class$a.prototype), _class$a);
function compatibleToV2(config) {
  var _config$abilities = config.abilities, abilities = _config$abilities === void 0 ? {} : _config$abilities, _config$assets = config.assets, assets = _config$assets === void 0 ? {} : _config$assets;
  var ids = Object.keys(abilities);
  var assetKeys = Object.keys(assets);
  for (var i = 0, l = ids.length; i < l; ++i) {
    handleComponents(abilities[ids[i]].props);
  }
  for (var _i = 0, _l = assetKeys.length; _i < _l; ++_i) {
    handleAssets(assets[assetKeys[_i]].props);
  }
  return config;
}
function handleComponents(props) {
  var keys = Object.keys(props);
  for (var i = 0, l = keys.length; i < l; ++i) {
    var k = keys[i];
    var v = props[k];
    if (Array.isArray(v)) {
      if (["color", "diffuseColor", "specularColor"].indexOf(k) !== -1) {
        props[k] = new Color(v[0], v[1], v[2], v[3]);
      } else if (v.length === 4) {
        props[k] = new Vector4(v[0], v[1], v[2], v[3]);
      } else if (v.length === 3) {
        props[k] = new Vector3(v[0], v[1], v[2]);
      } else if (v.length === 2) {
        props[k] = new Vector2(v[0], v[1]);
      }
    }
  }
}
function handleAssets(props) {
  if (props === void 0) {
    props = {};
  }
  if (!props) {
    return;
  }
  var keys = Object.keys(props);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    var value = props[key];
    if (key === "newMaterial" || key === "scripts") {
      continue;
    }
    if (Array.isArray(value)) {
      if (["emissiveColor", "diffuseColor", "specularColor", "baseColor"].indexOf(key) !== -1) {
        props[key] = new Color(value[0], value[1], value[2], value[3]);
      } else if (value.length === 4) {
        props[key] = new Vector4(value[0], value[1], value[2], value[3]);
      } else if (value.length === 3) {
        props[key] = new Vector3(value[0], value[1], value[2]);
      } else if (value.length === 2) {
        props[key] = new Vector2(value[0], value[1]);
      }
    }
  }
}
var CURRENT_SCHEMA_VERSION = 3;
var Parser = function() {
  var _proto = Parser2.prototype;
  _proto.parse = function parse3(options) {
    var _options$config;
    if ((options === null || options === void 0 ? void 0 : (_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.version) !== CURRENT_SCHEMA_VERSION) {
      var _options$config2;
      console.warn('schema-parser: schema version "' + (options === null || options === void 0 ? void 0 : (_options$config2 = options.config) === null || _options$config2 === void 0 ? void 0 : _options$config2.version) + '" is out of date, please re-pull the latest version (version ' + CURRENT_SCHEMA_VERSION + ") of the schema");
    }
    compatibleToV2(options.config);
    return Oasis.create(options, this.pluginManager);
  };
  _proto.register = function register(plugin) {
    this.pluginManager.register(plugin);
  };
  _proto.resetPlugins = function resetPlugins() {
    this.pluginManager.reset();
  };
  function Parser2() {
    this.pluginManager = new PluginManager();
  }
  Parser2.create = function create() {
    var parser2 = new Parser2();
    return parser2;
  };
  Parser2.registerComponents = function registerComponents(namespace, components) {
    if (!this._components[namespace]) {
      this._components[namespace] = {};
    }
    _extends2(this._components[namespace], components);
  };
  return Parser2;
}();
Parser._components = {};
var parser = Parser.create();

// node_modules/@oasis-engine/rhi-webgl/dist/module.js
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  return Constructor;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread23(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
var WebCanvas = function() {
  var _proto = WebCanvas2.prototype;
  _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
    if (pixelRatio === void 0) {
      pixelRatio = window.devicePixelRatio;
    }
    var webCanvas = this._webCanvas;
    if (webCanvas instanceof HTMLCanvasElement) {
      var width = webCanvas.clientWidth;
      var height = webCanvas.clientHeight;
      this.width = width * pixelRatio;
      this.height = height * pixelRatio;
    }
  };
  function WebCanvas2(webCanvas) {
    this._webCanvas = void 0;
    this._width = void 0;
    this._height = void 0;
    this._scale = new Vector2();
    var width = webCanvas.width;
    var height = webCanvas.height;
    this._webCanvas = webCanvas;
    this._width = width;
    this._height = height;
  }
  _proto.setScale = function setScale(x, y) {
    this._scale.setValue(x, y);
    this.scale = this._scale;
  };
  _createClass4(WebCanvas2, [{
    key: "width",
    get: function get4() {
      return this._width;
    },
    set: function set4(value) {
      if (this._width !== value) {
        this._webCanvas.width = value;
        this._width = value;
      }
    }
  }, {
    key: "height",
    get: function get4() {
      return this._height;
    },
    set: function set4(value) {
      if (this._height !== value) {
        this._webCanvas.height = value;
        this._height = value;
      }
    }
  }, {
    key: "scale",
    get: function get4() {
      var webCanvas = this._webCanvas;
      if (webCanvas instanceof HTMLCanvasElement) {
        this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
      }
      return this._scale;
    },
    set: function set4(value) {
      var webCanvas = this._webCanvas;
      if (webCanvas instanceof HTMLCanvasElement) {
        webCanvas.style.transformOrigin = "left top";
        webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
      }
    }
  }]);
  return WebCanvas2;
}();
var GLCapability = function() {
  function GLCapability2(rhi) {
    this._maxDrawBuffers = void 0;
    this._maxAnisoLevel = void 0;
    this._maxAntiAliasing = void 0;
    this._rhi = void 0;
    this.capabilityList = void 0;
    this._rhi = rhi;
    this.capabilityList = new Map();
    this.init();
    this.compatibleAllInterface();
  }
  var _proto = GLCapability2.prototype;
  _proto.canIUse = function canIUse(capabilityType) {
    return this.capabilityList.get(capabilityType);
  };
  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
    var RGBA_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR, RGBA_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR, SRGB8_ALPHA8_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR, SRGB8_ALPHA8_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR, RGB_ETC1_WEBGL = GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL, R11_EAC = GLCompressedTextureInternalFormat.R11_EAC, SRGB8_ALPHA8_ETC2_EAC = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC, RGB_PVRTC_4BPPV1_IMG = GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1_IMG = GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG, RGB_S3TC_DXT1_EXT = GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT, RGBA_S3TC_DXT5_EXT = GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;
    if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
      return this.canIUse(GLCapabilityType.astc);
    } else if (internalType === RGB_ETC1_WEBGL) {
      return this.canIUse(GLCapabilityType.etc1);
    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
      return this.canIUse(GLCapabilityType.etc);
    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
      return this.canIUse(GLCapabilityType.pvrtc);
    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
      return this.canIUse(GLCapabilityType.s3tc);
    }
    return false;
  };
  _proto.init = function init2() {
    var cap = this.capabilityList;
    var isWebGL2 = this.rhi.isWebGL2;
    var requireExtension = this.rhi.requireExtension.bind(this.rhi);
    var standardDerivatives = GLCapabilityType.standardDerivatives, shaderTextureLod = GLCapabilityType.shaderTextureLod, elementIndexUint = GLCapabilityType.elementIndexUint, depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, multipleSample = GLCapabilityType.multipleSample, drawBuffers = GLCapabilityType.drawBuffers, astc = GLCapabilityType.astc, astc_webkit = GLCapabilityType.astc_webkit, etc = GLCapabilityType.etc, etc_webkit = GLCapabilityType.etc_webkit, etc1 = GLCapabilityType.etc1, etc1_webkit = GLCapabilityType.etc1_webkit, pvrtc = GLCapabilityType.pvrtc, pvrtc_webkit = GLCapabilityType.pvrtc_webkit, s3tc = GLCapabilityType.s3tc, s3tc_webkit = GLCapabilityType.s3tc_webkit, textureFloat = GLCapabilityType.textureFloat, textureHalfFloat = GLCapabilityType.textureHalfFloat, textureFloatLinear = GLCapabilityType.textureFloatLinear, textureHalfFloatLinear = GLCapabilityType.textureHalfFloatLinear, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat, colorBufferFloat = GLCapabilityType.colorBufferFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic;
    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
    cap.set(multipleSample, isWebGL2);
    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
    cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
    cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
  };
  _proto.compatibleInterface = function compatibleInterface(capabilityType, flatItem) {
    var rhi = this.rhi;
    var gl = rhi.gl;
    var ext = null;
    if (ext = rhi.requireExtension(capabilityType)) {
      for (var _glKey in flatItem) {
        var _extensionKey = flatItem[_glKey];
        var extensionVal = ext[_extensionKey];
        if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
          gl[_glKey] = extensionVal.bind(ext);
        } else {
          gl[_glKey] = extensionVal;
        }
      }
    }
  };
  _proto.compatibleAllInterface = function compatibleAllInterface() {
    var depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, drawBuffers = GLCapabilityType.drawBuffers, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic, textureHalfFloat = GLCapabilityType.textureHalfFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat;
    var isWebGL2 = this.rhi.isWebGL2;
    if (!isWebGL2) {
      this.compatibleInterface(depthTexture, {
        UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
      });
      this.compatibleInterface(vertexArrayObject, {
        createVertexArray: "createVertexArrayOES",
        deleteVertexArray: "deleteVertexArrayOES",
        isVertexArray: "isVertexArrayOES",
        bindVertexArray: "bindVertexArrayOES"
      });
      this.compatibleInterface(instancedArrays, {
        drawArraysInstanced: "drawArraysInstancedANGLE",
        drawElementsInstanced: "drawElementsInstancedANGLE",
        vertexAttribDivisor: "vertexAttribDivisorANGLE"
      });
      this.compatibleInterface(drawBuffers, {
        MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
      });
      var items = {};
      if (this.canIUse(GLCapabilityType.drawBuffers)) {
        var maxDrawBuffers = this.maxDrawBuffers;
        for (var i = 0; i < maxDrawBuffers; i++) {
          i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
          items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
        }
        this.compatibleInterface(drawBuffers, _objectSpread23({
          drawBuffers: "drawBuffersWEBGL"
        }, items));
      }
      this.compatibleInterface(textureHalfFloat, {
        HAFL_FLOAT: "HALF_FLOAT_OES"
      });
      this.compatibleInterface(colorBufferHalfFloat, {
        RGBA16F: "RBGA16F_EXT"
      });
      this.compatibleInterface(WEBGL_colorBufferFloat, {
        RGBA32F: "RBGA32F_EXT"
      });
    }
    this.compatibleInterface(textureFilterAnisotropic, {
      TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
    });
  };
  _createClass4(GLCapability2, [{
    key: "maxDrawBuffers",
    get: function get4() {
      if (!this._maxDrawBuffers) {
        if (this.canIUse(GLCapabilityType.drawBuffers)) {
          this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
        } else {
          this._maxDrawBuffers = 1;
        }
      }
      return this._maxDrawBuffers;
    }
  }, {
    key: "maxAnisoLevel",
    get: function get4() {
      if (!this._maxAnisoLevel) {
        var ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);
        this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
      }
      return this._maxAnisoLevel;
    }
  }, {
    key: "maxAntiAliasing",
    get: function get4() {
      if (!this._maxAntiAliasing) {
        var gl = this._rhi.gl;
        var canMSAA = this.canIUse(GLCapabilityType.multipleSample);
        this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
      }
      return this._maxAntiAliasing;
    }
  }, {
    key: "rhi",
    get: function get4() {
      return this._rhi;
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get4() {
      return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
    }
  }]);
  return GLCapability2;
}();
var GLExtensions = function() {
  function GLExtensions2(rhi) {
    this.rhi = void 0;
    this._requireResult = void 0;
    this.rhi = rhi;
    this._requireResult = {};
  }
  var _proto = GLExtensions2.prototype;
  _proto.requireExtension = function requireExtension(ext) {
    if (this._requireResult[ext] !== void 0) {
      return this._requireResult[ext];
    }
    this._requireResult[ext] = this.rhi.gl.getExtension(ext);
    return this._requireResult[ext];
  };
  return GLExtensions2;
}();
var GLPrimitive = function() {
  function GLPrimitive2(rhi, primitive) {
    this._primitive = void 0;
    this.attribLocArray = void 0;
    this.canUseInstancedArrays = void 0;
    this.gl = void 0;
    this.vao = new Map();
    this._useVao = void 0;
    this._primitive = primitive;
    this.canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);
    this.gl = rhi.gl;
  }
  var _proto = GLPrimitive2.prototype;
  _proto.draw = function draw(shaderProgram, subPrimitive) {
    var gl = this.gl;
    var primitive = this._primitive;
    if (this._useVao) {
      if (!this.vao.has(shaderProgram.id)) {
        this.registerVAO(shaderProgram);
      }
      var vao = this.vao.get(shaderProgram.id);
      gl.bindVertexArray(vao);
    } else {
      this.bindBufferAndAttrib(shaderProgram);
    }
    var indexBufferBinding = primitive.indexBufferBinding, instanceCount = primitive.instanceCount, _glIndexType = primitive._glIndexType;
    var topology = subPrimitive.topology, start = subPrimitive.start, count = subPrimitive.count;
    if (!instanceCount) {
      if (indexBufferBinding) {
        if (this._useVao) {
          gl.drawElements(topology, count, _glIndexType, start);
        } else {
          var _nativeBuffer = indexBufferBinding.buffer._nativeBuffer;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
          gl.drawElements(topology, count, _glIndexType, start);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
      } else {
        gl.drawArrays(topology, start, count);
      }
    } else {
      if (this.canUseInstancedArrays) {
        if (indexBufferBinding) {
          if (this._useVao) {
            gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);
          } else {
            var _nativeBuffer2 = indexBufferBinding.buffer._nativeBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
            gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }
        } else {
          gl.drawArraysInstanced(topology, start, count, instanceCount);
        }
      } else {
        Logger.error("ANGLE_instanced_arrays extension is not supported");
      }
    }
    if (this._useVao) {
      gl.bindVertexArray(null);
    } else {
      this.disableAttrib();
    }
  };
  _proto.destroy = function destroy() {
    if (this._useVao) {
      var gl = this.gl;
      this.vao.forEach(function(vao) {
        gl.deleteVertexArray(vao);
      });
    }
  };
  _proto.bindBufferAndAttrib = function bindBufferAndAttrib(shaderProgram) {
    var gl = this.gl;
    var primitive = this._primitive;
    var vertexBufferBindings = primitive.vertexBufferBindings;
    this.attribLocArray = [];
    var attributeLocation = shaderProgram.attributeLocation;
    var attributes = primitive._vertexElementMap;
    var vbo;
    var lastBoundVbo;
    for (var name in attributeLocation) {
      var loc = attributeLocation[name];
      if (loc === -1)
        continue;
      var element = attributes[name];
      if (element) {
        var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex], buffer = _vertexBufferBindings.buffer, stride = _vertexBufferBindings.stride;
        vbo = buffer._nativeBuffer;
        if (lastBoundVbo !== vbo) {
          lastBoundVbo = vbo;
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        }
        gl.enableVertexAttribArray(loc);
        var _element$_glElementIn = element._glElementInfo, size = _element$_glElementIn.size, type = _element$_glElementIn.type;
        gl.vertexAttribPointer(loc, size, type, element.normalized, stride, element.offset);
        if (this.canUseInstancedArrays) {
          gl.vertexAttribDivisor(loc, element.instanceDivisor);
        }
        this.attribLocArray.push(loc);
      } else {
        Logger.warn("vertex attribute not found: " + name);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  };
  _proto.disableAttrib = function disableAttrib() {
    var gl = this.gl;
    for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
      gl.disableVertexAttribArray(this.attribLocArray[i]);
    }
  };
  _proto.registerVAO = function registerVAO(shaderProgram) {
    var gl = this.gl;
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    var indexBufferBinding = this._primitive.indexBufferBinding;
    if (indexBufferBinding) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferBinding.buffer._nativeBuffer);
    }
    this.bindBufferAndAttrib(shaderProgram);
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.disableAttrib();
    this.vao.set(shaderProgram.id, vao);
  };
  return GLPrimitive2;
}();
var GLRenderStates = function() {
  function GLRenderStates2(gl) {
    this._gl = void 0;
    this._parameters = {};
    this._gl = gl;
    this._parameters = {};
    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    gl.colorMask(true, true, true, true);
    gl.blendColor(0, 0, 0, 0);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.depthMask(true);
    gl.disable(gl.STENCIL_TEST);
    gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 255);
    gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 255);
    gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilMask(255);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.polygonOffset(0, 0);
  }
  var _proto = GLRenderStates2.prototype;
  _proto.getParameter = function getParameter(pname) {
    return this._parameters[pname];
  };
  return GLRenderStates2;
}();
var GLSprite = function() {
  function GLSprite2(gl) {
    this.gl = void 0;
    this._vbo = void 0;
    this._maxBatchCount = void 0;
    this._vertBuffer = void 0;
    this._vertCursor = void 0;
    this._drawSpriteCount = void 0;
    this._vertAttributes = void 0;
    this.gl = gl;
    this._initVertexAttributes(gl);
    this._vbo = gl.createBuffer();
    this._maxBatchCount = 0;
    this._vertBuffer = null;
    this._vertCursor = 0;
    this._drawSpriteCount = 0;
  }
  var _proto = GLSprite2.prototype;
  _proto.setMaxBatchCount = function setMaxBatchCount(count) {
    var requireSize = count * 6 * 9;
    if (this._vertBuffer && this._vertBuffer.length >= requireSize) {
      return;
    }
    this._maxBatchCount = count;
    this._vertBuffer = new Float32Array(requireSize);
  };
  _proto.beginDraw = function beginDraw(count) {
    this._vertCursor = 0;
    this._drawSpriteCount = 0;
    if (count > this._maxBatchCount) {
      this.setMaxBatchCount(count);
    }
  };
  _proto.drawSprite = function drawSprite(positionQuad, uvRect, tintColor) {
    this._drawSpriteCount++;
    if (this._drawSpriteCount > this._maxBatchCount) {
      Logger.warn("Sprite: sprite count overflow");
      return;
    }
    var color = tintColor;
    var u = uvRect.u;
    var v = uvRect.v;
    var p = uvRect.u + uvRect.width;
    var q = uvRect.v + uvRect.height;
    this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);
    this._pushVertex(positionQuad.leftBottom, new Vector2(u, q), color);
    this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);
    this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);
    this._pushVertex(positionQuad.rightTop, new Vector2(p, v), color);
    this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);
  };
  _proto.endDraw = function endDraw(shaderProgram) {
    var vertCount = this._vertCursor / 9;
    if (vertCount <= 0)
      return;
    var gl = this.gl;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
    gl.bufferData(gl.ARRAY_BUFFER, this._vertBuffer, gl.DYNAMIC_DRAW);
    var attributeLocation = shaderProgram.attributeLocation;
    for (var k in attributeLocation) {
      var location = attributeLocation[k];
      var attrib = this._vertAttributes[k];
      gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      gl.enableVertexAttribArray(location);
    }
    gl.drawArrays(gl.TRIANGLES, 0, vertCount);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    for (var _k in attributeLocation) {
      gl.disableVertexAttribArray(attributeLocation[_k]);
    }
  };
  _proto._initVertexAttributes = function _initVertexAttributes(gl) {
    var vertexStride = (3 + 2 + 4) * 4;
    var posAtt = {};
    posAtt.name = "a_pos";
    posAtt.size = 3;
    posAtt.offset = 0;
    var uvAtt = {};
    uvAtt.name = "a_uv";
    uvAtt.size = 2;
    uvAtt.offset = 3 * 4;
    var colorAtt = {};
    colorAtt.name = "a_color";
    colorAtt.size = 4;
    colorAtt.offset = 5 * 4;
    this._vertAttributes = {
      a_pos: posAtt,
      a_uv: uvAtt,
      a_color: colorAtt
    };
    for (var k in this._vertAttributes) {
      var att = this._vertAttributes[k];
      att.type = gl.FLOAT;
      att.normalized = false;
      att.stride = vertexStride;
    }
  };
  _proto._pushVertex = function _pushVertex(pos, uv, color) {
    var vb = this._vertBuffer;
    var id = this._vertCursor;
    vb[id] = pos.x;
    vb[id + 1] = pos.y;
    vb[id + 2] = pos.z;
    vb[id + 3] = uv.x;
    vb[id + 4] = uv.y;
    vb[id + 5] = color.x;
    vb[id + 6] = color.y;
    vb[id + 7] = color.z;
    vb[id + 8] = color.w;
    this._vertCursor += 9;
  };
  _proto.finalize = function finalize() {
    if (this._vbo) {
      this.gl.deleteBuffer(this._vbo);
      this._vbo = null;
    }
  };
  return GLSprite2;
}();
var spriteVertShader = "\nprecision highp float;\n\nuniform mat4 matProjection;\nuniform mat4 matView;\n\nattribute vec3 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  gl_Position = matProjection * matView * vec4(a_pos,1.0);\n  v_uv = a_uv;\n  v_color = a_color;\n}\n";
var spriteFragmentShader = "\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D s_diffuse;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  // Only use the Alpha of the texture as a mask, so that the tint color can still be controlled to fade out.\n  vec4 baseColor = texture2D(s_diffuse, v_uv);\n  gl_FragColor = baseColor * v_color;\n}\n";
Shader.create("Sprite", spriteVertShader, spriteFragmentShader);
var GLSpriteBatcher = function() {
  function GLSpriteBatcher2(rhi) {
    this._gl = void 0;
    this._batchedQueue = void 0;
    this._targetTexture = void 0;
    this._glSprite = void 0;
    this._camera = void 0;
    this._gl = rhi.gl;
    this._batchedQueue = [];
    this._targetTexture = null;
    this._glSprite = new GLSprite(rhi.gl);
    this._camera = null;
  }
  var _proto = GLSpriteBatcher2.prototype;
  _proto.flush = function flush(engine, material) {
    if (this._batchedQueue.length === 0) {
      return;
    }
    if (!this._targetTexture) {
      Logger.error("No texture!");
      return;
    }
    var materialData = material.shaderData;
    materialData.setTexture("s_diffuse", this._targetTexture);
    materialData.setMatrix("matView", this._camera.viewMatrix);
    materialData.setMatrix("matProjection", this._camera.projectionMatrix);
    var compileMacros = RenderQueue.compileMacros;
    compileMacros.clear();
    var program = material.shader._getShaderProgram(engine, compileMacros);
    if (!program.isValid) {
      return;
    }
    program.bind();
    program.groupingOtherUniformBlock();
    program.uploadAll(program.materialUniformBlock, materialData);
    material.renderState._apply(engine);
    this._glSprite.beginDraw(this._batchedQueue.length);
    for (var i = 0, len = this._batchedQueue.length; i < len; i++) {
      var positionQuad = this._batchedQueue[i].positionQuad;
      var uvRect = this._batchedQueue[i].uvRect;
      var tintColor = this._batchedQueue[i].tintColor;
      this._glSprite.drawSprite(positionQuad, uvRect, tintColor);
    }
    this._glSprite.endDraw(program);
    this._batchedQueue = [];
    this._targetTexture = null;
    this._camera = null;
  };
  _proto.canBatch = function canBatch(texture, renderMode, camera) {
    if (this._targetTexture === null) {
      return true;
    }
    return texture === this._targetTexture && camera === this._camera;
  };
  _proto.drawSprite = function drawSprite(material, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    if (!this.canBatch(texture, renderMode, camera)) {
      this.flush(camera.engine, material);
    }
    this._targetTexture = texture;
    this._camera = camera;
    this._batchedQueue.push({
      positionQuad,
      uvRect,
      tintColor
    });
  };
  _proto.finalize = function finalize() {
    this._glSprite.finalize();
  };
  return GLSpriteBatcher2;
}();
var WebGLMode;
(function(WebGLMode2) {
  WebGLMode2[WebGLMode2["Auto"] = 0] = "Auto";
  WebGLMode2[WebGLMode2["WebGL2"] = 1] = "WebGL2";
  WebGLMode2[WebGLMode2["WebGL1"] = 2] = "WebGL1";
})(WebGLMode || (WebGLMode = {}));
var WebGLRenderer = function() {
  function WebGLRenderer2(options) {
    if (options === void 0) {
      options = {};
    }
    this._currentBind = void 0;
    this._options = void 0;
    this._gl = void 0;
    this._renderStates = void 0;
    this._extensions = void 0;
    this._spriteBatcher = void 0;
    this._capability = void 0;
    this._isWebGL2 = void 0;
    this._activedTextureID = void 0;
    this._activeTextures = new Array(32);
    this._options = options;
  }
  var _proto = WebGLRenderer2.prototype;
  _proto.init = function init2(canvas) {
    var option = this._options;
    var webCanvas = canvas._webCanvas;
    var webGLMode = option.webGLMode || WebGLMode.Auto;
    var gl;
    if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL2) {
      gl = webCanvas.getContext("webgl2", option);
      if (!gl && webCanvas instanceof HTMLCanvasElement) {
        gl = webCanvas.getContext("experimental-webgl2", option);
      }
      this._isWebGL2 = true;
    }
    if (!gl) {
      if (webGLMode == WebGLMode.Auto || webGLMode == WebGLMode.WebGL1) {
        gl = webCanvas.getContext("webgl", option);
        if (!gl && webCanvas instanceof HTMLCanvasElement) {
          gl = webCanvas.getContext("experimental-webgl", option);
        }
        this._isWebGL2 = false;
      }
    }
    if (!gl) {
      throw new Error("Get GL Context FAILED.");
    }
    this._gl = gl;
    this._renderStates = new GLRenderStates(gl);
    this._extensions = new GLExtensions(this);
    this._capability = new GLCapability(this);
    this._options = null;
  };
  _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
    return new GLPrimitive(this, primitive);
  };
  _proto.requireExtension = function requireExtension(ext) {
    return this._extensions.requireExtension(ext);
  };
  _proto.canIUse = function canIUse(capabilityType) {
    return this.capability.canIUse(capabilityType);
  };
  _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
    return this.capability.canIUseCompressedTextureInternalFormat(type);
  };
  _proto.viewport = function viewport(x, y, width, height) {
    var gl = this._gl;
    gl.viewport(x, gl.drawingBufferHeight - y - height, width, height);
  };
  _proto.colorMask = function colorMask(r, g, b, a) {
    this._gl.colorMask(r, g, b, a);
  };
  _proto.clearRenderTarget = function clearRenderTarget(engine, clearMode, clearParam) {
    var gl = this._gl;
    var lastRenderState = engine._lastRenderState;
    var colorWriteMask = lastRenderState.blendState.targetBlendState.colorWriteMask, depthWriteEnabled = lastRenderState.depthState.writeEnabled, stencilWriteMask = lastRenderState.stencilState.writeMask;
    var clearColor = false;
    var clearDepth = false;
    var clearStencil = false;
    switch (clearMode) {
      case ClearMode.SOLID_COLOR:
        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
        clearColor = clearDepth = true;
        break;
      case ClearMode.DEPTH_ONLY:
        clearDepth = true;
        break;
      case ClearMode.COLOR_ONLY:
        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
        clearColor = true;
        break;
      case ClearMode.STENCIL_ONLY:
        gl.clear(gl.STENCIL_BUFFER_BIT);
        clearStencil = true;
        break;
      case ClearMode.ALL_CLEAR:
        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
        clearColor = clearDepth = clearStencil = true;
        break;
    }
    if (clearColor && colorWriteMask !== ColorWriteMask.All) {
      gl.colorMask(true, true, true, true);
      lastRenderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.All;
    }
    if (clearDepth && depthWriteEnabled !== true) {
      gl.depthMask(true);
      lastRenderState.depthState.writeEnabled = true;
    }
    if (clearStencil && stencilWriteMask !== 255) {
      gl.stencilMask(255);
      lastRenderState.stencilState.writeMask = 255;
    }
    gl.clear((clearColor ? gl.COLOR_BUFFER_BIT : 0) | (clearDepth ? gl.DEPTH_BUFFER_BIT : 0) | (clearStencil ? gl.STENCIL_BUFFER_BIT : 0));
  };
  _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
    if (primitive) {
      primitive._draw(shaderProgram, subPrimitive);
    } else {
      Logger.error("draw primitive failed.");
    }
  };
  _proto.drawSprite = function drawSprite(material, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    if (!this._spriteBatcher) {
      this._spriteBatcher = new GLSpriteBatcher(this);
    }
    this._spriteBatcher.drawSprite(material, positionQuad, uvRect, tintColor, texture, renderMode, camera);
  };
  _proto.flushSprite = function flushSprite(engine, material) {
    if (this._spriteBatcher) {
      this._spriteBatcher.flush(engine, material);
    }
  };
  _proto.activeRenderTarget = function activeRenderTarget(renderTarget, camera) {
    var gl = this._gl;
    if (renderTarget) {
      renderTarget._activeRenderTarget();
      var width = renderTarget.width, height = renderTarget.height;
      gl.viewport(0, 0, width, height);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      var viewport = camera.viewport;
      var _width = gl.drawingBufferWidth;
      var _height = gl.drawingBufferHeight;
      this.viewport(viewport.x * _width, viewport.y * _height, viewport.z * _width, viewport.w * _height);
    }
  };
  _proto.blitRenderTarget = function blitRenderTarget(renderTarget) {
    if (renderTarget) {
      if (renderTarget._MSAAFrameBuffer) {
        renderTarget._blitRenderTarget();
        return;
      }
    }
  };
  _proto.setRenderTargetFace = function setRenderTargetFace(renderTarget, cubeFace) {
    if (renderTarget) {
      renderTarget._setRenderTargetFace(cubeFace);
    }
  };
  _proto.destroy = function destroy() {
  };
  _proto.activeTexture = function activeTexture(textureID) {
    if (this._activedTextureID !== textureID) {
      this._gl.activeTexture(textureID);
      this._activedTextureID = textureID;
    }
  };
  _proto.bindTexture = function bindTexture(target, texture) {
    var gl = this._gl;
    if (this._activeTextures[this._activedTextureID - gl.TEXTURE0] !== texture) {
      gl.bindTexture(target, texture);
      this._activeTextures[this._activedTextureID - gl.TEXTURE0] = texture;
    }
  };
  _createClass4(WebGLRenderer2, [{
    key: "isWebGL2",
    get: function get4() {
      return this._isWebGL2;
    }
  }, {
    key: "gl",
    get: function get4() {
      return this._gl;
    }
  }, {
    key: "renderStates",
    get: function get4() {
      return this._renderStates;
    }
  }, {
    key: "capability",
    get: function get4() {
      return this._capability;
    }
  }, {
    key: "canIUseMoreJoints",
    get: function get4() {
      return this.capability.canIUseMoreJoints;
    }
  }]);
  return WebGLRenderer2;
}();
var WebGLEngine = function(_Engine) {
  _inheritsLoose3(WebGLEngine2, _Engine);
  function WebGLEngine2(canvas, webGLRendererOptions) {
    var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
    var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
    return _Engine.call(this, webCanvas, hardwareRenderer) || this;
  }
  _createClass4(WebGLEngine2, [{
    key: "canvas",
    get: function get4() {
      return this._canvas;
    }
  }]);
  return WebGLEngine2;
}(Engine);

// node_modules/oasis-engine/dist/module.js
Parser.registerComponents("o3", {
  GLTFModel,
  SpriteRenderer,
  PointLight,
  AmbientLight,
  DirectLight,
  EnvironmentMapLight,
  ParticleRenderer,
  SkyBox,
  BoxCollider,
  GeometryRenderer,
  Camera,
  Component,
  SphereCollider,
  Model
});
var version = "0.2.0";
console.log("oasis engine version: " + version);
export {
  ABoxCollider,
  Collider as ACollider,
  ASphereCollider,
  AlphaMode,
  AmbientLight,
  Animation,
  AnimationClip,
  AnimationEventType as AnimationEvent,
  AssetPromise,
  AssetPromiseStatus,
  AssetType,
  BasicRenderPipeline,
  BlendFactor,
  BlendFunc,
  BlendOperation,
  BlinnPhongMaterial,
  BoundingBox,
  BoundingFrustum,
  BoundingSphere,
  BoxCollider,
  Buffer,
  BufferBindFlag,
  BufferGeometry,
  BufferUsage,
  BufferUtil,
  Camera,
  CircleGeometry,
  ClearMode,
  ColliderFeature,
  CollisionDetection,
  CollisionUtil,
  Color,
  ColorWriteMask,
  CompFunc,
  CompareFunction,
  Component,
  ContainmentType,
  CubeProbe,
  CuboidGeometry,
  CullFace,
  CullMode,
  CylinderGeometry,
  DataType,
  DirectLight,
  EXP2Fog,
  Engine,
  EngineFeature,
  EngineObject,
  Entity,
  EnvironmentMapLight,
  Event,
  EventDispatcher,
  Fog,
  FrontFace,
  GLCapabilityType,
  GLCompressedTextureInternalFormat,
  GLTFModel,
  GeometryRenderer,
  IndexBufferBinding,
  IndexFormat,
  InternalAssetType,
  InterpolationType,
  LODGroup,
  Layer,
  Light,
  LightFeature,
  LinearFog,
  Loader,
  Logger,
  Material,
  MaterialType,
  MathUtil,
  Matrix,
  Matrix3x3,
  Mesh,
  MeshRenderer,
  Model,
  Oasis,
  ObjectValues,
  PBRMaterial,
  PBRSpecularMaterial,
  Parser,
  ParticleRenderer,
  ParticleRendererBlendMode,
  Plane,
  PlaneCollider,
  PlaneGeometry,
  PlaneIntersectionType,
  PointLight,
  Primitive,
  PrimitiveTopology,
  Probe,
  Quaternion,
  Ray,
  RefObject,
  RefreshRate,
  RegistExtension,
  RenderBufferColorFormat,
  RenderBufferDepthFormat,
  RenderColorTexture,
  RenderDepthTexture,
  RenderElement,
  RenderPass,
  RenderQueue,
  RenderQueueType,
  RenderState,
  RenderTarget,
  Renderer,
  ResourceManager,
  Scene,
  SceneFeature,
  SchemaResource,
  ScreenQuadGeometry,
  Script,
  SetDataOptions,
  Shader,
  ShaderFactory,
  ShapeGeometry,
  Side,
  Skin,
  SkinnedMeshRenderer,
  SkyBox,
  SphereCollider,
  SphereGeometry,
  Spherical,
  SpotLight,
  SpriteRenderer,
  StencilOperation,
  SubPrimitive,
  SystemInfo,
  Texture,
  Texture2D,
  TextureCubeFace,
  TextureCubeMap,
  TextureFilterMode,
  TextureFormat,
  TextureWrapMode,
  Time,
  TorusGeometry,
  TrailMaterial,
  TrailRenderer,
  Transform,
  UniformSemantic,
  UnlitMaterial,
  UpdateFlag,
  Util,
  Vector2,
  Vector3,
  Vector4,
  VertexBufferBinding,
  VertexElement,
  VertexElementFormat,
  WebCanvas,
  WebGLEngine,
  WebGLMode,
  WebGLRenderer,
  WrapMode,
  dependencies,
  parseSingleKTX,
  parser,
  registerResource,
  request,
  resourceLoader,
  script,
  version
};
//# sourceMappingURL=oasis-engine.js.map
